{
  "version": 3,
  "sources": ["../src/index.js", "../src/attributes/guards/guardUnsatisifedException.ts", "../src/attributes/guards/guardPath.ts", "../src/attributes/attribute.ts", "../src/attributes/guards/guard.ts", "../src/Lookup.js", "../src/attributes/guards/while.ts", "../src/attributes/guards/until.ts", "../src/attributes/callbacks/callback.ts", "../src/attributes/callbacks/entry.ts", "../src/attributes/callbacks/exit.ts", "../src/attributes/callbacks/step.ts", "../src/AttributeBuilder.js", "../src/State.js", "../src/nodes/node.js", "../src/nodes/leaf/leaf.js", "../src/nodes/leaf/action.js", "../src/nodes/leaf/condition.js", "../src/nodes/leaf/wait.js", "../src/nodes/decorator/decorator.js", "../src/nodes/decorator/root.js", "../src/nodes/decorator/repeat.js", "../src/nodes/decorator/retry.js", "../src/nodes/decorator/flip.js", "../src/nodes/decorator/succeed.js", "../src/nodes/decorator/fail.js", "../src/nodes/composite/composite.js", "../src/nodes/composite/lotto.js", "../src/nodes/composite/selector.js", "../src/nodes/composite/sequence.js", "../src/nodes/composite/parallel.js", "../src/NodeBuilder.js", "../src/BehaviourTree.js"],
  "sourcesContent": ["import BehaviourTree from \"./BehaviourTree\";\nimport State from \"./State\";\n\nexport { BehaviourTree, State };\n", "/**\r\n * An exception thrown when evaluating node guard path conditions and a conditions fails.\r\n * @param source The node at which a guard condition failed.\r\n */\r\nexport default class GuardUnsatisifedException extends Error {\r\n    constructor(private source: any) {\r\n        super(\"A guard path condition has failed\");\r\n    }\r\n\r\n    /**\r\n     * Gets whether the specified node is the node at which a guard condition failed.\r\n     * @param node The node to check against the source node.\r\n     * @returns Whether the specified node is the node at which a guard condition failed.\r\n     */\r\n    isSourceNode = (node:any) => node === this.source;\r\n}\r\n", "import GuardUnsatisifedException from \"./guardUnsatisifedException\";\r\n\r\n/**\r\n * Represents a path of node guards along a root-to-leaf tree path.\r\n * @param nodes An array of objects defining a node instance -> guard link, ordered by node depth.\r\n */\r\nexport default class GuardPath {\r\n    constructor(private nodes: any[]) {}\r\n\r\n    /**\r\n     * Evaluate guard conditions for all guards in the tree path, moving outwards from the root.\r\n     * @param agent The agent, required for guard evaluation.\r\n     * @returns An evaluation results object.\r\n     */\r\n    evaluate = (agent: any) => {\r\n        // We need to evaluate guard conditions for nodes up the tree, moving outwards from the root.\r\n        for (const details of this.nodes) {\r\n            // There can be multiple guards per node.\r\n            for (const guard of details.guards) {\r\n                // Check whether the guard condition passes, and throw an exception if not.\r\n                if (!guard.isSatisfied(agent)) {\r\n                    throw new GuardUnsatisifedException(details.node);\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\n", "/**\r\n * A base node attribute.\r\n * @param type The node attribute type.\r\n * @param args The array of attribute argument definitions.\r\n */\r\nexport default abstract class Attribute {\r\n    constructor(protected type: string, protected args: any[]) {}\r\n    /**\r\n     * Gets the type of the attribute.\r\n     */\r\n    getType = () => this.type;\r\n\r\n    /**\r\n     * Gets the array of attribute argument definitions.\r\n     */\r\n    getArguments = () => this.args;\r\n\r\n    /**\r\n     * Gets the attribute details.\r\n     */\r\n    getDetails = () => ({\r\n        type: this.getType(),\r\n        arguments: this.getArguments()\r\n    });\r\n}\r\n", "import Attribute from \"../attribute\";\r\n\r\n/**\r\n * A base node guard attribute.\r\n * @param type The node guard attribute type.\r\n * @param args The array of attribute argument definitions.\r\n */\r\nexport default abstract class Guard extends Attribute {\r\n    /**\r\n     * Gets whether this attribute is a guard.\r\n     */\r\n    isGuard = () => true;\r\n\r\n    abstract isSatisfied(agent: any): boolean\r\n}\r\n", "/**\n * A singleton used to store and lookup registered functions and subtrees.\n */\nexport default class Lookup {\n    /**\n     * The object holding any registered functions keyed on function name.\n     */\n    static #functionTable = {};\n    /**\n     * The object holding any registered sub-trees keyed on tree name.\n     */\n    static #subtreeTable = {};\n\n    /**\n     * Gets the function with the specified name.\n     * @param {string} name The name of the function.\n     * @returns The function with the specified name.\n     */\n    static getFunc(name) {\n        return this.#functionTable[name];\n    }\n\n    /**\n     * Sets the function with the specified name for later lookup.\n     * @param {string} name The name of the function.\n     * @param {function} func The function.\n     */\n    static setFunc(name, func) {\n        this.#functionTable[name] = func;\n    }\n\n    /**\n     * Gets the function invoker for the specified agent and function name.\n     * If a function with the specified name exists on the agent object then it will\n     * be returned, otherwise we will then check the registered functions for a match.\n     * @param {object} agent The agent instance that this behaviour tree is modelling behaviour for.\n     * @param {string} name The function name.\n     * @returns The function invoker for the specified agent and function name.\n     */\n    static getFuncInvoker(agent, name) {\n        // Check whether the agent contains the specified function.\n        if (agent[name] && typeof agent[name] === \"function\") {\n            return (args) =>\n                agent[name].apply(\n                    agent,\n                    args.map((arg) => arg.value)\n                );\n        }\n\n        // The agent does not contain the specified function but it may have been registered at some point.\n        if (this.#functionTable[name] && typeof this.#functionTable[name] === \"function\") {\n            return (args) => this.#functionTable[name](agent, ...args.map((arg) => arg.value));\n        }\n\n        // We have no function to invoke.\n        return null;\n    }\n\n    /**\n     * Gets the subtree with the specified name.\n     * @param {string} name The name of the subtree.\n     * @returns The subtree with the specified name.\n     */\n    static getSubtree(name) {\n        return this.#subtreeTable[name];\n    }\n\n    /**\n     * Sets the subtree with the specified name for later lookup.\n     * @param {string} name The name of the subtree.\n     * @param {object} subtree The subtree.\n     */\n    static setSubtree(name, subtree) {\n        this.#subtreeTable[name] = subtree;\n    }\n\n    /**\n     * Removes the registered function or subtree with the specified name.\n     * @param {string} name The name of the registered function or subtree.\n     */\n    static remove(name) {\n        delete this.#functionTable[name];\n        delete this.#subtreeTable[name];\n    }\n\n    /**\n     * Remove all registered functions and subtrees.\n     */\n    static empty() {\n        this.#functionTable = {};\n        this.#subtreeTable = {};\n    }\n}\n", "import Guard from \"./guard\";\r\n// @ts-ignore\r\nimport Lookup from \"../../Lookup\";\r\n\r\n/**\r\n * A WHILE guard which is satisfied as long as the given condition remains true.\r\n * @param condition The name of the condition function that determines whether the guard is satisfied.\r\n * @param args The array of attribute argument definitions.\r\n */\r\nexport default class While extends Guard {\r\n    constructor(private condition: string, args: any[]) {\r\n        super(\"while\", args);\r\n    }\r\n\r\n    /**\r\n     * Gets whether the attribute is a guard.\r\n     */\r\n    isGuard = () => true;\r\n\r\n    /**\r\n     * Gets the attribute details.\r\n     */\r\n    getDetails = () => {\r\n        return {\r\n            type: this.getType(),\r\n            functionName: this.condition,\r\n            arguments: this.getArguments()\r\n        };\r\n    };\r\n\r\n    onReady = () => {};\r\n\r\n    /**\r\n     * Gets whether the guard is satisfied.\r\n     * @param agent The agent.\r\n     * @returns Whether the guard is satisfied.\r\n     */\r\n    isSatisfied = (agent: any) => {\r\n        // Attempt to get the invoker for the condition function.\r\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.condition);\r\n\r\n        // The condition function should be defined.\r\n        if (conditionFuncInvoker === null) {\r\n            throw new Error(\r\n                `cannot evaluate node guard as the condition '${this.condition}' function is not defined on the agent and has not been registered`\r\n            );\r\n        }\r\n\r\n        // Call the condition function to determine whether this guard is satisfied.\r\n        return !!conditionFuncInvoker(this.args);\r\n    };\r\n}\r\n", "import Guard from \"./guard\";\r\n// @ts-ignore\r\nimport Lookup from \"../../Lookup\";\r\n\r\n/**\r\n * An UNTIL guard which is satisfied as long as the given condition remains false.\r\n * @param condition The name of the condition function that determines whether the guard is satisfied.\r\n * @param args The array of attribute argument definitions.\r\n */\r\nexport default class Until extends Guard {\r\n    constructor(private condition: string, args: any[]) {\r\n        super(\"until\", args);\r\n    }\r\n\r\n    /**\r\n     * Gets whether the attribute is a guard.\r\n     */\r\n    isGuard = () => true;\r\n\r\n    /**\r\n     * Gets the attribute details.\r\n     */\r\n    getDetails = () => {\r\n        return {\r\n            type: this.getType(),\r\n            functionName: this.condition,\r\n            arguments: this.getArguments()\r\n        };\r\n    };\r\n\r\n    onReady = () => {};\r\n\r\n    /**\r\n     * Gets whether the guard is satisfied.\r\n     * @param agent The agent.\r\n     * @returns Whether the guard is satisfied.\r\n     */\r\n    isSatisfied = (agent: any) => {\r\n        // Attempt to get the invoker for the condition function.\r\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.condition);\r\n\r\n        // The condition function should be defined.\r\n        if (conditionFuncInvoker === null) {\r\n            throw new Error(\r\n                `cannot evaluate node guard as the condition '${this.condition}' function is not defined on the agent and has not been registered`\r\n            );\r\n        }\r\n\r\n        // Call the condition function to determine whether this guard is satisfied.\r\n        return !!!conditionFuncInvoker(this.args);\r\n    };\r\n}\r\n", "import Attribute from \"../attribute\";\r\n\r\n/**\r\n * A base node callback attribute.\r\n * @param type The node callback attribute type.\r\n * @param args The array of attribute argument definitions.\r\n */\r\nexport default abstract class Callback extends Attribute {\r\n    /**\r\n     * Gets whether this attribute is a guard.\r\n     */\r\n    isGuard = () => false;\r\n}\r\n", "import Callback from \"./callback\";\r\n// @ts-ignore\r\nimport Lookup from \"../../Lookup\";\r\n\r\n/**\r\n * An ENTRY callback which defines an agent function to call when the associated node is updated and moves out of running state.\r\n * @param functionName The name of the agent function to call.\r\n * @param args The array of callback argument definitions.\r\n */\r\nexport default class Entry extends Callback {\r\n    constructor(private functionName: string, args: any[]) {\r\n        super(\"entry\", args);\r\n    }\r\n\r\n    /**\r\n     * Gets the callback details.\r\n     */\r\n    getDetails = () => {\r\n        return {\r\n            type: this.getType(),\r\n            functionName: this.functionName,\r\n            arguments: this.getArguments()\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Attempt to call the agent function that this callback refers to.\r\n     * @param agent The agent.\r\n     */\r\n    callAgentFunction = (agent: any) => {\r\n        // Attempt to get the invoker for the callback function.\r\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.functionName);\r\n\r\n        // The callback function should be defined.\r\n        if (callbackFuncInvoker === null) {\r\n            throw new Error(\r\n                `cannot call entry function '${this.functionName}' as is not defined on the agent and has not been registered`\r\n            );\r\n        }\r\n\r\n        // Call the callback function.\r\n        callbackFuncInvoker(this.args);\r\n    };\r\n}\r\n", "import Callback from \"./callback\";\r\n// @ts-ignore\r\nimport Lookup from \"../../Lookup\";\r\n\r\n/**\r\n * An EXIT callback which defines an agent function to call when the associated node is updated and moves to a finished state or is aborted.\r\n * @param functionName The name of the agent function to call.\r\n * @param args The array of callback argument definitions.\r\n */\r\nexport default class Exit extends Callback {\r\n    constructor(private functionName: string, args: any[]) {\r\n        super(\"exit\", args);\r\n    }\r\n\r\n    /**\r\n     * Gets the callback details.\r\n     */\r\n    getDetails = () => {\r\n        return {\r\n            type: this.getType(),\r\n            functionName: this.functionName,\r\n            arguments: this.getArguments()\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Attempt to call the agent function that this callback refers to.\r\n     * @param agent The agent.\r\n     * @param isSuccess Whether the decorated node was left with a success state.\r\n     * @param isAborted Whether the decorated node was aborted.\r\n     */\r\n    callAgentFunction = (agent: any, isSuccess: boolean, isAborted: boolean) => {\r\n        // Attempt to get the invoker for the callback function.\r\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.functionName);\r\n\r\n        // The callback function should be defined.\r\n        if (callbackFuncInvoker === null) {\r\n            throw new Error(\r\n                `cannot call exit function '${this.functionName}' as is not defined on the agent and has not been registered`\r\n            );\r\n        }\r\n\r\n        // Call the callback function.\r\n        callbackFuncInvoker([{ value: { succeeded: isSuccess, aborted: isAborted } }].concat(this.args));\r\n    };\r\n}\r\n", "import Callback from \"./callback\";\r\n// @ts-ignore\r\nimport Lookup from \"../../Lookup\";\r\n\r\n/**\r\n * A STEP callback which defines an agent function to call when the associated node is updated.\r\n * @param functionName The name of the agent function to call.\r\n * @param args The array of callback argument definitions.\r\n */\r\nexport default class Step extends Callback {\r\n    constructor(private functionName: string, args: any[]) {\r\n        super(\"exit\", args);\r\n    }\r\n\r\n    /**\r\n     * Gets the callback details.\r\n     */\r\n    getDetails = () => {\r\n        return {\r\n            type: this.getType(),\r\n            functionName: this.functionName,\r\n            arguments: this.getArguments()\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Attempt to call the agent function that this callback refers to.\r\n     * @param agent The agent.\r\n     */\r\n    callAgentFunction = (agent: any) => {\r\n        // Attempt to get the invoker for the callback function.\r\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.functionName);\r\n\r\n        // The callback function should be defined.\r\n        if (callbackFuncInvoker === null) {\r\n            throw new Error(\r\n                `cannot call step function '${this.functionName}' as is not defined on the agent and has not been registered`\r\n            );\r\n        }\r\n\r\n        // Call the callback function.\r\n        callbackFuncInvoker(this.args);\r\n    };\r\n}\r\n", "import While from \"./attributes/guards/while\";\r\nimport Until from \"./attributes/guards/until\";\r\nimport Entry from \"./attributes/callbacks/entry\";\r\nimport Exit from \"./attributes/callbacks/exit\";\r\nimport Step from \"./attributes/callbacks/step\";\r\n\r\n/**\r\n * The builder of node attributes.\r\n */\r\nexport default class AttributeBuilder {\r\n    /**\r\n     * The node attribute factories.\r\n     */\r\n    static #factories = {\r\n        WHILE: (condition, attributeArguments) => new While(condition, attributeArguments),\r\n        UNTIL: (condition, attributeArguments) => new Until(condition, attributeArguments),\r\n        ENTRY: (functionName, attributeArguments) => new Entry(functionName, attributeArguments),\r\n        EXIT: (functionName, attributeArguments) => new Exit(functionName, attributeArguments),\r\n        STEP: (functionName, attributeArguments) => new Step(functionName, attributeArguments)\r\n    };\r\n\r\n    /**\r\n     * Pull any attributes off of the token stack.\r\n     * @param tokens The array of remaining tokens.\r\n     * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\r\n     * @returns An array of attributes defined by any directly following tokens.\r\n     */\r\n    static parseFromTokens(tokens, stringArgumentPlaceholders) {\r\n        // Create an array to hold any attributes found.\r\n        const attributes = [];\r\n\r\n        // Keep track of names of attributes that we have found on the token stack, as we cannot have duplicates.\r\n        const attributesFound = [];\r\n\r\n        // Try to get the attribute factory for the next token.\r\n        let attributeFactory = this.#factories[(tokens[0] || \"\").toUpperCase()];\r\n\r\n        // Pull attribute tokens off of the tokens stack until we have no more.\r\n        while (attributeFactory) {\r\n            // Check to make sure that we have not already created a attribute of this type for this node.\r\n            if (attributesFound.indexOf(tokens[0].toUpperCase()) !== -1) {\r\n                throw new Error(`duplicate attribute '${tokens[0].toUpperCase()}' found for node`);\r\n            }\r\n\r\n            // Add the current attribute type to our array of found attributes.\r\n            attributesFound.push(tokens.shift().toUpperCase());\r\n\r\n            // Grab any attribute arguments.\r\n            const attributeArguments = getArguments(tokens, stringArgumentPlaceholders);\r\n\r\n            // The first attribute argument has to be an identifer, this will reference an agent function.\r\n            if (attributeArguments.length === 0 || attributeArguments[0].type !== \"identifier\") {\r\n                throw new Error(\"expected agent function name identifier argument for attribute\");\r\n            }\r\n\r\n            // Grab the first attribute which is an identifier that will reference an agent function.\r\n            const attributeFunctionNameArg = attributeArguments.shift();\r\n\r\n            // Any remaining attribute arguments must have a type of string, number, boolean or null.\r\n            attributeArguments\r\n                .filter((arg) => arg.type === \"identifier\")\r\n                .forEach((arg) => {\r\n                    throw new Error(\r\n                        \"invalid attribute argument value '\" + arg.value + \"', must be string, number, boolean or null\"\r\n                    );\r\n                });\r\n\r\n            // Create the attribute and add it to the array of attribute found.\r\n            attributes.push(attributeFactory(attributeFunctionNameArg.value, attributeArguments));\r\n\r\n            // Try to get the next attribute name token, as there could be multiple.\r\n            attributeFactory = this.#factories[(tokens[0] || \"\").toUpperCase()];\r\n        }\r\n\r\n        return attributes;\r\n    }\r\n}\r\n", "/**\n * Enumeration of node states.\n */\nconst State = {\n    READY: Symbol(\"mistreevous.ready\"),\n    RUNNING: Symbol(\"mistreevous.running\"),\n    SUCCEEDED: Symbol(\"mistreevous.succeeded\"),\n    FAILED: Symbol(\"mistreevous.failed\")\n};\n\nexport { State as default };\n", "import GuardUnsatisifedException from \"../attributes/guards/guardUnsatisifedException\";\r\nimport State from \"../State\";\r\n\r\n/**\r\n * A base node.\r\n * @param type The node type.\r\n * @param attributes The node guard/callback attributes.\r\n * @param args The node argument definitions.\r\n */\r\nexport default function Node(type, attributes, args) {\r\n    /**\r\n     * The node uid.\r\n     */\r\n    const uid = createNodeUid();\r\n    /**\r\n     * The node state.\r\n     */\r\n    let state = State.READY;\r\n    /**\r\n     * The guard path to evaluate as part of a node update.\r\n     */\r\n    let guardPath;\r\n\r\n    /**\r\n     * Gets/Sets the state of the node.\r\n     */\r\n    this.getState = () => state;\r\n    this.setState = (value) => (state = value);\r\n\r\n    /**\r\n     * Gets the unique id of the node.\r\n     */\r\n    this.getUid = () => uid;\r\n\r\n    /**\r\n     * Gets the type of the node.\r\n     */\r\n    this.getType = () => type;\r\n\r\n    /**\r\n     * Gets the node arguments.\r\n     */\r\n    this.getArguments = () => args || [];\r\n\r\n    /**\r\n     * Gets the node guard/callback attributes.\r\n     */\r\n    this.getAttributes = () => attributes || [];\r\n\r\n    /**\r\n     * Gets the node guard/callback attribute with the specified type, or null if it does not exist.\r\n     */\r\n    this.getAttribute = (type) =>\r\n        this.getAttributes().filter((attribute) => attribute.getType().toUpperCase() === type.toUpperCase())[0] || null;\r\n\r\n    /**\r\n     * Gets the node guard attributes.\r\n     */\r\n    this.getGuardAttributes = () => this.getAttributes().filter((attribute) => attribute.isGuard());\r\n\r\n    /**\r\n     * Gets the node callback attributes.\r\n     */\r\n    this.getCallbackAttributes = () => this.getAttributes().filter((attribute) => !attribute.isGuard());\r\n\r\n    /**\r\n     * Sets the guard path to evaluate as part of a node update.\r\n     */\r\n    this.setGuardPath = (value) => (guardPath = value);\r\n\r\n    /**\r\n     * Gets whether a guard path is assigned to this node.\r\n     */\r\n    this.hasGuardPath = () => !!guardPath;\r\n\r\n    /**\r\n     * Gets whether this node is in the specified state.\r\n     * @param value The value to compare to the node state.\r\n     */\r\n    this.is = (value) => {\r\n        return state === value;\r\n    };\r\n\r\n    /**\r\n     * Reset the state of the node.\r\n     */\r\n    this.reset = () => {\r\n        // Reset the state of this node.\r\n        this.setState(State.READY);\r\n    };\r\n\r\n    /**\r\n     * Abort the running of this node.\r\n     * @param agent The agent.\r\n     */\r\n    this.abort = (agent) => {\r\n        // There is nothing to do if this node is not in the running state.\r\n        if (!this.is(State.RUNNING)) {\r\n            return;\r\n        }\r\n\r\n        // Reset the state of this node.\r\n        this.reset();\r\n\r\n        // Try to get the exit callback attribute for this node.\r\n        const exitCallback = this.getAttribute(\"exit\");\r\n\r\n        // Call the exit callback attribute function if it exists.\r\n        if (exitCallback) {\r\n            exitCallback.callAgentFunction(agent, false, true);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Update the node.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns The result of the update.\r\n     */\r\n    this.update = (agent, options) => {\r\n        // If this node is already in a 'SUCCEEDED' or 'FAILED' state then there is nothing to do.\r\n        if (this.is(State.SUCCEEDED) || this.is(State.FAILED)) {\r\n            // We have not changed state.\r\n            return {};\r\n        }\r\n\r\n        // If this node is in a 'READY' state then we may want to carry out some initialisation for any node guard attributes.\r\n        if (this.is(State.READY)) {\r\n            this.getGuardAttributes().forEach((guard) => guard.onReady());\r\n        }\r\n\r\n        try {\r\n            // Evaluate all of the guard path conditions for the current tree path.\r\n            guardPath.evaluate(agent);\r\n\r\n            // If this node is in the READY state then call the entry callback for this node if it exists.\r\n            if (this.is(State.READY)) {\r\n                // Try to get the entry callback attribute for this node.\r\n                const entryCallback = this.getAttribute(\"entry\");\r\n\r\n                // Call the entry callback attribute function if it exists.\r\n                if (entryCallback) {\r\n                    entryCallback.callAgentFunction(agent);\r\n                }\r\n            }\r\n\r\n            // Try to get the step callback attribute for this node.\r\n            const stepCallback = this.getAttribute(\"step\");\r\n\r\n            // Call the step callback attribute function if it exists.\r\n            if (stepCallback) {\r\n                stepCallback.callAgentFunction(agent);\r\n            }\r\n\r\n            // Do the actual update.\r\n            this.onUpdate(agent, options);\r\n\r\n            // If this node is now in a 'SUCCEEDED' or 'FAILED' state then call the EXIT callback for this node if it exists.\r\n            if (this.is(State.SUCCEEDED) || this.is(State.FAILED)) {\r\n                // Try to get the exit callback attribute for this node.\r\n                const exitCallback = this.getAttribute(\"exit\");\r\n\r\n                // Call the exit callback attribute function if it exists.\r\n                if (exitCallback) {\r\n                    exitCallback.callAgentFunction(agent, this.is(State.SUCCEEDED), false);\r\n                }\r\n            }\r\n        } catch (error) {\r\n            // If the error is a GuardUnsatisfiedException then we need to determine if this node is the source.\r\n            if (error instanceof GuardUnsatisifedException && error.isSourceNode(this)) {\r\n                // Abort the current node.\r\n                this.abort(agent);\r\n\r\n                // Any node that is the source of an abort will be a failed node.\r\n                this.setState(State.FAILED);\r\n            } else {\r\n                throw error;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Create a randomly generated node uid.\r\n * @returns A randomly generated node uid.\r\n */\r\nfunction createNodeUid() {\r\n    var S4 = function () {\r\n        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n    };\r\n    return S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4();\r\n}\r\n", "import Node from \"../node\";\n\n/**\n * A leaf node.\n * @param type The node type.\n * @param decorators The node decorators.\n * @param args The node argument definitions.\n */\nexport default function Leaf(type, decorators, args) {\n    Node.call(this, type, decorators, args);\n\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    this.isLeafNode = () => true;\n}\n\nLeaf.prototype = Object.create(Node.prototype);\n", "import Leaf from \"./leaf\";\r\nimport State from \"../../State\";\r\nimport Lookup from \"../../Lookup\";\r\n\r\n/**\r\n * An Action leaf node.\r\n * This represents an immediate or ongoing state of behaviour.\r\n * @param decorators The node decorators.\r\n * @param actionName The action name.\r\n * @param actionArguments The array of action argument definitions.\r\n */\r\nexport default function Action(decorators, actionName, actionArguments) {\r\n    Leaf.call(this, \"action\", decorators, actionArguments);\r\n\r\n    /**\r\n     * Whether there is a pending update promise.\r\n     */\r\n    let isUsingUpdatePromise = false;\r\n\r\n    /**\r\n     * The finished state result of an update promise.\r\n     */\r\n    let updatePromiseStateResult = null;\r\n\r\n    /**\r\n     * Update the node.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns The result of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // If the result of this action depends on an update promise then there is nothing to do until\r\n        // it resolves, unless there has been a value set as a result of the update promise resolving.\r\n        if (isUsingUpdatePromise) {\r\n            // Check whether the update promise has resolved with a state value.\r\n            if (updatePromiseStateResult) {\r\n                // Set the state of this node to match the state returned by the promise.\r\n                this.setState(updatePromiseStateResult);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Attempt to get the invoker for the action function.\r\n        const actionFuncInvoker = Lookup.getFuncInvoker(agent, actionName);\r\n\r\n        // The action function should be defined.\r\n        if (actionFuncInvoker === null) {\r\n            throw new Error(\r\n                `cannot update action node as the action '${actionName}' function is not defined on the agent and has not been registered`\r\n            );\r\n        }\r\n\r\n        // Call the action function, the result of which may be:\r\n        // - The finished state of this action node.\r\n        // - A promise to return a finished node state.\r\n        // - Undefined if the node should remain in the running state.\r\n        const updateResult = actionFuncInvoker(actionArguments);\r\n\r\n        if (updateResult instanceof Promise) {\r\n            updateResult.then(\r\n                (result) => {\r\n                    // If 'isUpdatePromisePending' is null then the promise was cleared as it was resolving, probably via an abort of reset.\r\n                    if (!isUsingUpdatePromise) {\r\n                        return;\r\n                    }\r\n\r\n                    // Check to make sure the result is a valid finished state.\r\n                    if (result !== State.SUCCEEDED && result !== State.FAILED) {\r\n                        throw new Error(\r\n                            \"action node promise resolved with an invalid value, expected a State.SUCCEEDED or State.FAILED value to be returned\"\r\n                        );\r\n                    }\r\n\r\n                    // Set pending update promise state result to be processed on next update.\r\n                    updatePromiseStateResult = result;\r\n                },\r\n                (reason) => {\r\n                    // If 'isUpdatePromisePending' is null then the promise was cleared as it was resolving, probably via an abort of reset.\r\n                    if (!isUsingUpdatePromise) {\r\n                        return;\r\n                    }\r\n\r\n                    // Just throw whatever was returned as the rejection argument.\r\n                    throw new Error(reason);\r\n                }\r\n            );\r\n\r\n            // This node will be in the 'RUNNING' state until the update promise resolves.\r\n            this.setState(State.RUNNING);\r\n\r\n            // We are now waiting for the promise returned by the use to resolve before we know what state this node is in.\r\n            isUsingUpdatePromise = true;\r\n        } else {\r\n            // Validate the returned value.\r\n            this._validateUpdateResult(updateResult);\r\n\r\n            // Set the state of this node, this may be undefined, which just means that the node is still in the 'RUNNING' state.\r\n            this.setState(updateResult || State.RUNNING);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => actionName;\r\n\r\n    /**\r\n     * Reset the state of the node.\r\n     */\r\n    this.reset = () => {\r\n        // Reset the state of this node.\r\n        this.setState(State.READY);\r\n\r\n        // There is no longer an update promise that we care about.\r\n        isUsingUpdatePromise = false;\r\n        updatePromiseStateResult = null;\r\n    };\r\n\r\n    /**\r\n     * Validate the result of an update function call.\r\n     * @param result The result of an update function call.\r\n     */\r\n    this._validateUpdateResult = (result) => {\r\n        switch (result) {\r\n            case State.SUCCEEDED:\r\n            case State.FAILED:\r\n            case undefined:\r\n                return;\r\n            default:\r\n                throw new Error(\r\n                    `action '${actionName}' 'onUpdate' returned an invalid response, expected an optional State.SUCCEEDED or State.FAILED value to be returned`\r\n                );\r\n        }\r\n    };\r\n}\r\n\r\nAction.prototype = Object.create(Leaf.prototype);\r\n", "import Leaf from \"./leaf\";\r\nimport State from \"../../State\";\r\nimport Lookup from \"../../Lookup\";\r\n\r\n/**\r\n * A Condition leaf node.\r\n * This will succeed or fail immediately based on an agent predicate, without moving to the 'RUNNING' state.\r\n * @param decorators The node decorators.\r\n * @param conditionName The name of the condition function.\r\n * @param conditionArguments The array of condition argument definitions.\r\n */\r\nexport default function Condition(decorators, conditionName, conditionArguments) {\r\n    Leaf.call(this, \"condition\", decorators, conditionArguments);\r\n\r\n    /**\r\n     * Update the node.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns The result of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // Attempt to get the invoker for the condition function.\r\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, conditionName);\r\n\r\n        // The condition function should be defined.\r\n        if (conditionFuncInvoker === null) {\r\n            throw new Error(\r\n                `cannot update condition node as the condition '${conditionName}' function is not defined on the agent and has not been registered`\r\n            );\r\n        }\r\n\r\n        // Call the condition function to determine the state of this node.\r\n        this.setState(!!conditionFuncInvoker(conditionArguments) ? State.SUCCEEDED : State.FAILED);\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => conditionName;\r\n}\r\n\r\nCondition.prototype = Object.create(Leaf.prototype);\r\n", "import Leaf from \"./leaf\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A WAIT node.\r\n * The state of this node will change to SUCCEEDED after a duration of time.\r\n * @param decorators The node decorators.\r\n * @param duration The duration that this node will wait to succeed in milliseconds, or the earliest if longestDuration is defined.\r\n * @param longestDuration The longest possible duration in milliseconds that this node will wait to succeed.\r\n */\r\nexport default function Wait(decorators, duration, longestDuration) {\r\n    Leaf.call(this, \"wait\", decorators);\r\n\r\n    /**\r\n     * The time in milliseconds at which this node was first updated.\r\n     */\r\n    let initialUpdateTime;\r\n\r\n    /**\r\n     * The total duration in milliseconds that this node will be waiting for.\r\n     */\r\n    let totalDuration;\r\n\r\n    /**\r\n     * The duration in milliseconds that this node has been waiting for.\r\n     */\r\n    let waitedDuration;\r\n\r\n    /**\r\n     * Update the node.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns The result of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // If this node is in the READY state then we need to set the initial update time.\r\n        if (this.is(State.READY)) {\r\n            // Set the initial update time.\r\n            initialUpdateTime = new Date().getTime();\r\n\r\n            // Set the initial waited duration.\r\n            waitedDuration = 0;\r\n\r\n            // If a longestDuration value was defined then we will be randomly picking a duration between the\r\n            // shortest and longest duration. If it was not defined, then we will be just using the duration.\r\n            totalDuration = longestDuration\r\n                ? Math.floor(Math.random() * (longestDuration - duration + 1) + duration)\r\n                : duration;\r\n\r\n            // The node is now running until we finish waiting.\r\n            this.setState(State.RUNNING);\r\n        }\r\n\r\n        // If we have a 'getDeltaTime' function defined as part of our options then we will use it to figure out how long we have waited for.\r\n        if (typeof options.getDeltaTime === \"function\") {\r\n            // Get the delta time.\r\n            const deltaTime = options.getDeltaTime();\r\n\r\n            // Our delta time must be a valid number and cannot be NaN.\r\n            if (typeof deltaTime !== \"number\" || isNaN(deltaTime)) {\r\n                throw new Error(\"The delta time must be a valid number and not NaN.\");\r\n            }\r\n\r\n            // Update the amount of time that this node has been waiting for based on the delta time.\r\n            waitedDuration += deltaTime * 1000;\r\n        } else {\r\n            // We are not using a delta time, so we will just work out hom much time has passed since the first update.\r\n            waitedDuration = new Date().getTime() - initialUpdateTime;\r\n        }\r\n\r\n        // Have we waited long enough?\r\n        if (waitedDuration >= totalDuration) {\r\n            // We have finished waiting!\r\n            this.setState(State.SUCCEEDED);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => `WAIT ${longestDuration ? duration + \"ms-\" + longestDuration + \"ms\" : duration + \"ms\"}`;\r\n}\r\n\r\nWait.prototype = Object.create(Leaf.prototype);\r\n", "import Node from \"../node\";\nimport State from \"../../State\";\n\n/**\n * A decorator node that wraps a single child node.\n * @param type The node type.\n * @param decorators The node decorators.\n * @param child The child node.\n */\nexport default function Decorator(type, decorators, child) {\n    Node.call(this, type, decorators);\n\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    this.isLeafNode = () => false;\n\n    /**\n     * Gets the children of this node.\n     */\n    this.getChildren = () => [child];\n\n    /**\n     * Reset the state of the node.\n     */\n    this.reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the state of the child node.\n        child.reset();\n    };\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    this.abort = (agent) => {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Abort the child node.\n        child.abort(agent);\n\n        // Reset the state of this node.\n        this.reset();\n\n        // Try to get the exit decorator for this node.\n        const exitDecorator = this.getDecorator(\"exit\");\n\n        // Call the exit decorator function if it exists.\n        if (exitDecorator) {\n            exitDecorator.callAgentFunction(agent, false, true);\n        }\n    };\n}\n\nDecorator.prototype = Object.create(Node.prototype);\n", "import Decorator from \"./decorator\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A Root node.\r\n * The root node will have a single child.\r\n * @param decorators The node decorators.\r\n * @param child The child node.\r\n */\r\nexport default function Root(decorators, child) {\r\n    Decorator.call(this, \"root\", decorators, child);\r\n\r\n    /**\r\n     * Update the node and get whether the node state has changed.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns Whether the state of this node has changed as part of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // If the child has never been updated or is running then we will need to update it now.\r\n        if (child.getState() === State.READY || child.getState() === State.RUNNING) {\r\n            // Update the child of this node.\r\n            child.update(agent, options);\r\n        }\r\n\r\n        // The state of the root node is the state of its child.\r\n        this.setState(child.getState());\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => \"ROOT\";\r\n}\r\n\r\nRoot.prototype = Object.create(Decorator.prototype);\r\n", "import Decorator from \"./decorator\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A REPEAT node.\r\n * The node has a single child which can have:\r\n * -- A number of iterations for which to repeat the child node.\r\n * -- An infinite repeat loop if neither an iteration count or a condition function is defined.\r\n * The REPEAT node will stop and have a 'FAILED' state if its child is ever in a 'FAILED' state after an update.\r\n * The REPEAT node will attempt to move on to the next iteration if its child is ever in a 'SUCCEEDED' state.\r\n * @param decorators The node decorators.\r\n * @param iterations The number of iterations to repeat the child node, or the minimum number of iterations if maximumIterations is defined.\r\n * @param maximumIterations The maximum number of iterations to repeat the child node.\r\n * @param child The child node.\r\n */\r\nexport default function Repeat(decorators, iterations, maximumIterations, child) {\r\n    Decorator.call(this, \"repeat\", decorators, child);\r\n\r\n    /**\r\n     * The number of target iterations to make.\r\n     */\r\n    let targetIterationCount = null;\r\n\r\n    /**\r\n     * The current iteration count.\r\n     */\r\n    let currentIterationCount = 0;\r\n\r\n    /**\r\n     * Update the node.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns The result of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // If this node is in the READY state then we need to reset the child and the target iteration count.\r\n        if (this.is(State.READY)) {\r\n            // Reset the child node.\r\n            child.reset();\r\n\r\n            // Set the target iteration count.\r\n            this._setTargetIterationCount();\r\n        }\r\n\r\n        // Do a check to see if we can iterate. If we can then this node will move into the 'RUNNING' state.\r\n        // If we cannot iterate then we have hit our target iteration count, which means that the node has succeeded.\r\n        if (this._canIterate()) {\r\n            // This node is in the running state and can do its initial iteration.\r\n            this.setState(State.RUNNING);\r\n\r\n            // We may have already completed an iteration, meaning that the child node will be in the SUCCEEDED state.\r\n            // If this is the case then we will have to reset the child node now.\r\n            if (child.getState() === State.SUCCEEDED) {\r\n                child.reset();\r\n            }\r\n\r\n            // Update the child of this node.\r\n            child.update(agent, options);\r\n\r\n            // If the child moved into the FAILED state when we updated it then there is nothing left to do and this node has also failed.\r\n            // If it has moved into the SUCCEEDED state then we have completed the current iteration.\r\n            if (child.getState() === State.FAILED) {\r\n                // The child has failed, meaning that this node has failed.\r\n                this.setState(State.FAILED);\r\n\r\n                return;\r\n            } else if (child.getState() === State.SUCCEEDED) {\r\n                // We have completed an iteration.\r\n                currentIterationCount += 1;\r\n            }\r\n        } else {\r\n            // This node is in the 'SUCCEEDED' state as we cannot iterate any more.\r\n            this.setState(State.SUCCEEDED);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => {\r\n        if (iterations !== null) {\r\n            return `REPEAT ${maximumIterations ? iterations + \"x-\" + maximumIterations + \"x\" : iterations + \"x\"}`;\r\n        }\r\n\r\n        // Return the default repeat node name.\r\n        return \"REPEAT\";\r\n    };\r\n\r\n    /**\r\n     * Reset the state of the node.\r\n     */\r\n    this.reset = () => {\r\n        // Reset the state of this node.\r\n        this.setState(State.READY);\r\n\r\n        // Reset the current iteration count.\r\n        currentIterationCount = 0;\r\n\r\n        // Reset the child node.\r\n        child.reset();\r\n    };\r\n\r\n    /**\r\n     * Gets whether an iteration can be made.\r\n     * @returns Whether an iteration can be made.\r\n     */\r\n    this._canIterate = () => {\r\n        if (targetIterationCount !== null) {\r\n            // We can iterate as long as we have not reached our target iteration count.\r\n            return currentIterationCount < targetIterationCount;\r\n        }\r\n\r\n        // If neither an iteration count or a condition function were defined then we can iterate indefinitely.\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Sets the target iteration count.\r\n     */\r\n    this._setTargetIterationCount = () => {\r\n        // Are we dealing with a finite number of iterations?\r\n        if (typeof iterations === \"number\") {\r\n            // If we have maximumIterations defined then we will want a random iteration count bounded by iterations and maximumIterations.\r\n            targetIterationCount =\r\n                typeof maximumIterations === \"number\"\r\n                    ? Math.floor(Math.random() * (maximumIterations - iterations + 1) + iterations)\r\n                    : iterations;\r\n        } else {\r\n            targetIterationCount = null;\r\n        }\r\n    };\r\n}\r\n\r\nRepeat.prototype = Object.create(Decorator.prototype);\r\n", "import Decorator from \"./decorator\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A RETRY node.\r\n * The node has a single child which can have:\r\n * -- A number of iterations for which to repeat the child node.\r\n * -- An infinite repeat loop if neither an iteration count or a condition function is defined.\r\n * The RETRY node will stop and have a 'SUCCEEDED' state if its child is ever in a 'SUCCEEDED' state after an update.\r\n * The RETRY node will attempt to move on to the next iteration if its child is ever in a 'FAILED' state.\r\n * @param decorators The node decorators.\r\n * @param iterations The number of iterations to repeat the child node, or the minimum number of iterations if maximumIterations is defined.\r\n * @param maximumIterations The maximum number of iterations to repeat the child node.\r\n * @param child The child node.\r\n */\r\nexport default function Retry(decorators, iterations, maximumIterations, child) {\r\n    Decorator.call(this, \"retry\", decorators, child);\r\n\r\n    /**\r\n     * The number of target iterations to make.\r\n     */\r\n    let targetIterationCount = null;\r\n\r\n    /**\r\n     * The current iteration count.\r\n     */\r\n    let currentIterationCount = 0;\r\n\r\n    /**\r\n     * Update the node.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns The result of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // If this node is in the READY state then we need to reset the child and the target iteration count.\r\n        if (this.is(State.READY)) {\r\n            // Reset the child node.\r\n            child.reset();\r\n\r\n            // Set the target iteration count.\r\n            this._setTargetIterationCount();\r\n        }\r\n\r\n        // Do a check to see if we can iterate. If we can then this node will move into the 'RUNNING' state.\r\n        // If we cannot iterate then we have hit our target iteration count, which means that the node has succeeded.\r\n        if (this._canIterate()) {\r\n            // This node is in the running state and can do its initial iteration.\r\n            this.setState(State.RUNNING);\r\n\r\n            // We may have already completed an iteration, meaning that the child node will be in the FAILED state.\r\n            // If this is the case then we will have to reset the child node now.\r\n            if (child.getState() === State.FAILED) {\r\n                child.reset();\r\n            }\r\n\r\n            // Update the child of this node.\r\n            child.update(agent, options);\r\n\r\n            // If the child moved into the SUCCEEDED state when we updated it then there is nothing left to do and this node has also succeeded.\r\n            // If it has moved into the FAILED state then we have completed the current iteration.\r\n            if (child.getState() === State.SUCCEEDED) {\r\n                // The child has succeeded, meaning that this node has succeeded.\r\n                this.setState(State.SUCCEEDED);\r\n\r\n                return;\r\n            } else if (child.getState() === State.FAILED) {\r\n                // We have completed an iteration.\r\n                currentIterationCount += 1;\r\n            }\r\n        } else {\r\n            // This node is in the 'FAILED' state as we cannot iterate any more.\r\n            this.setState(State.FAILED);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => {\r\n        if (iterations !== null) {\r\n            return `RETRY ${maximumIterations ? iterations + \"x-\" + maximumIterations + \"x\" : iterations + \"x\"}`;\r\n        }\r\n\r\n        // Return the default retry node name.\r\n        return \"RETRY\";\r\n    };\r\n\r\n    /**\r\n     * Reset the state of the node.\r\n     */\r\n    this.reset = () => {\r\n        // Reset the state of this node.\r\n        this.setState(State.READY);\r\n\r\n        // Reset the current iteration count.\r\n        currentIterationCount = 0;\r\n\r\n        // Reset the child node.\r\n        child.reset();\r\n    };\r\n\r\n    /**\r\n     * Gets whether an iteration can be made.\r\n     * @returns Whether an iteration can be made.\r\n     */\r\n    this._canIterate = () => {\r\n        if (targetIterationCount !== null) {\r\n            // We can iterate as long as we have not reached our target iteration count.\r\n            return currentIterationCount < targetIterationCount;\r\n        }\r\n\r\n        // If neither an iteration count or a condition function were defined then we can iterate indefinitely.\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Sets the target iteration count.\r\n     */\r\n    this._setTargetIterationCount = () => {\r\n        // Are we dealing with a finite number of iterations?\r\n        if (typeof iterations === \"number\") {\r\n            // If we have maximumIterations defined then we will want a random iteration count bounded by iterations and maximumIterations.\r\n            targetIterationCount =\r\n                typeof maximumIterations === \"number\"\r\n                    ? Math.floor(Math.random() * (maximumIterations - iterations + 1) + iterations)\r\n                    : iterations;\r\n        } else {\r\n            targetIterationCount = null;\r\n        }\r\n    };\r\n}\r\n\r\nRetry.prototype = Object.create(Decorator.prototype);\r\n", "import Decorator from \"./decorator\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A Flip node.\r\n * This node wraps a single child and will flip the state of the child state.\r\n * @param decorators The node decorators.\r\n * @param child The child node.\r\n */\r\nexport default function Flip(decorators, child) {\r\n    Decorator.call(this, \"flip\", decorators, child);\r\n\r\n    /**\r\n     * Update the node.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns The result of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // If the child has never been updated or is running then we will need to update it now.\r\n        if (child.getState() === State.READY || child.getState() === State.RUNNING) {\r\n            child.update(agent, options);\r\n        }\r\n\r\n        // The state of this node will depend in the state of its child.\r\n        switch (child.getState()) {\r\n            case State.RUNNING:\r\n                this.setState(State.RUNNING);\r\n                break;\r\n\r\n            case State.SUCCEEDED:\r\n                this.setState(State.FAILED);\r\n                break;\r\n\r\n            case State.FAILED:\r\n                this.setState(State.SUCCEEDED);\r\n                break;\r\n\r\n            default:\r\n                this.setState(State.READY);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => \"FLIP\";\r\n}\r\n\r\nFlip.prototype = Object.create(Decorator.prototype);\r\n", "import Decorator from \"./decorator\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A Succeed node.\r\n * This node wraps a single child and will always move to the 'SUCCEEDED' state when the child moves to a 'SUCCEEDED' or 'FAILED' state.\r\n * @param decorators The node decorators.\r\n * @param child The child node.\r\n */\r\nexport default function Succeed(decorators, child) {\r\n    Decorator.call(this, \"succeed\", decorators, child);\r\n\r\n    /**\r\n     * Update the node.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns The result of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // If the child has never been updated or is running then we will need to update it now.\r\n        if (child.getState() === State.READY || child.getState() === State.RUNNING) {\r\n            child.update(agent, options);\r\n        }\r\n\r\n        // The state of this node will depend in the state of its child.\r\n        switch (child.getState()) {\r\n            case State.RUNNING:\r\n                this.setState(State.RUNNING);\r\n                break;\r\n\r\n            case State.SUCCEEDED:\r\n            case State.FAILED:\r\n                this.setState(State.SUCCEEDED);\r\n                break;\r\n\r\n            default:\r\n                this.setState(State.READY);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => \"SUCCEED\";\r\n}\r\n\r\nSucceed.prototype = Object.create(Decorator.prototype);\r\n", "import Decorator from \"./decorator\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A Fail node.\r\n * This node wraps a single child and will always move to the 'FAILED' state when the child moves to a 'SUCCEEDED' or 'FAILED' state.\r\n * @param decorators The node decorators.\r\n * @param child The child node.\r\n */\r\nexport default function Fail(decorators, child) {\r\n    Decorator.call(this, \"fail\", decorators, child);\r\n\r\n    /**\r\n     * Update the node.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns The result of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // If the child has never been updated or is running then we will need to update it now.\r\n        if (child.getState() === State.READY || child.getState() === State.RUNNING) {\r\n            child.update(agent, options);\r\n        }\r\n\r\n        // The state of this node will depend in the state of its child.\r\n        switch (child.getState()) {\r\n            case State.RUNNING:\r\n                this.setState(State.RUNNING);\r\n                break;\r\n\r\n            case State.SUCCEEDED:\r\n            case State.FAILED:\r\n                this.setState(State.FAILED);\r\n                break;\r\n\r\n            default:\r\n                this.setState(State.READY);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => \"FAIL\";\r\n}\r\n\r\nFail.prototype = Object.create(Decorator.prototype);\r\n", "import Node from \"../node\";\nimport State from \"../../State\";\n\n/**\n * A composite node that wraps child nodes.\n * @param type The node type.\n * @param decorators The node decorators.\n * @param children The child nodes.\n */\nexport default function Composite(type, decorators, children) {\n    Node.call(this, type, decorators);\n\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    this.isLeafNode = () => false;\n\n    /**\n     * Gets the children of this node.\n     */\n    this.getChildren = () => children;\n\n    /**\n     * Reset the state of the node.\n     */\n    this.reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the state of any child nodes.\n        this.getChildren().forEach((child) => child.reset());\n    };\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    this.abort = (agent) => {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Abort any child nodes.\n        this.getChildren().forEach((child) => child.abort(agent));\n\n        // Reset the state of this node.\n        this.reset();\n\n        // Try to get the exit decorator for this node.\n        const exitDecorator = this.getDecorator(\"exit\");\n\n        // Call the exit decorator function if it exists.\n        if (exitDecorator) {\n            exitDecorator.callAgentFunction(agent, false, true);\n        }\n    };\n}\n\nComposite.prototype = Object.create(Node.prototype);\n", "import Composite from \"./composite\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A LOTTO node.\r\n * A winning child is picked on the initial update of this node, based on ticket weighting.\r\n * The state of this node will match the state of the winning child.\r\n * @param decorators The node decorators.\r\n * @param tickets The child node tickets\r\n * @param children The child nodes.\r\n */\r\nexport default function Lotto(decorators, tickets, children) {\r\n    Composite.call(this, \"lotto\", decorators, children);\r\n\r\n    /**\r\n     * The winning child node.\r\n     */\r\n    let winningChild;\r\n\r\n    /**\r\n     * Represents a lotto draw.\r\n     */\r\n    function LottoDraw() {\r\n        /**\r\n         * The participants\r\n         */\r\n        this.participants = [];\r\n\r\n        /**\r\n         * Add a participant.\r\n         * @param participant The participant.\r\n         * @param tickets The number of tickets held by the participant.\r\n         */\r\n        this.add = function (participant, tickets) {\r\n            this.participants.push({ participant, tickets });\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Draw a winning participant.\r\n         * @returns A winning participant.\r\n         */\r\n        this.draw = function () {\r\n            // We cannot do anything if there are no participants.\r\n            if (!this.participants.length) {\r\n                throw new Error(\"cannot draw a lotto winner when there are no participants\");\r\n            }\r\n\r\n            const pickable = [];\r\n\r\n            this.participants.forEach(({ participant, tickets }) => {\r\n                for (let ticketCount = 0; ticketCount < tickets; ticketCount++) {\r\n                    pickable.push(participant);\r\n                }\r\n            });\r\n\r\n            return this.getRandomItem(pickable);\r\n        };\r\n\r\n        /**\r\n         * Get a random item form an array.\r\n         * @param items Th array of items.\r\n         * @returns The randomly picked item.\r\n         */\r\n        this.getRandomItem = function (items) {\r\n            // We cant pick a random item from an empty array.\r\n            if (!items.length) {\r\n                return undefined;\r\n            }\r\n\r\n            // Return a random item.\r\n            return items[Math.floor(Math.random() * items.length)];\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Update the node and get whether the node state has changed.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns Whether the state of this node has changed as part of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // If this node is in the READY state then we need to pick a winning child node.\r\n        if (this.is(State.READY)) {\r\n            // Create a lotto draw.\r\n            const lottoDraw = new LottoDraw();\r\n\r\n            // Add each child of this node to a lotto draw, with each child's corresponding ticket weighting, or a single ticket if not defined.\r\n            children.forEach((child, index) => lottoDraw.add(child, tickets[index] || 1));\r\n\r\n            // Randomly pick a child based on ticket weighting.\r\n            winningChild = lottoDraw.draw();\r\n        }\r\n\r\n        // If the winning child has never been updated or is running then we will need to update it now.\r\n        if (winningChild.getState() === State.READY || winningChild.getState() === State.RUNNING) {\r\n            winningChild.update(agent, options);\r\n        }\r\n\r\n        // The state of the lotto node is the state of its winning child.\r\n        this.setState(winningChild.getState());\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => (tickets.length ? `LOTTO [${tickets.join(\",\")}]` : \"LOTTO\");\r\n}\r\n\r\nLotto.prototype = Object.create(Composite.prototype);\r\n", "import Composite from \"./composite\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A SELECTOR node.\r\n * The child nodes are executed in sequence until one succeeds or all fail.\r\n * @param decorators The node decorators.\r\n * @param children The child nodes.\r\n */\r\nexport default function Selector(decorators, children) {\r\n    Composite.call(this, \"selector\", decorators, children);\r\n\r\n    /**\r\n     * Update the node and get whether the node state has changed.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns Whether the state of this node has changed as part of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // Iterate over all of the children of this node.\r\n        for (const child of children) {\r\n            // If the child has never been updated or is running then we will need to update it now.\r\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\r\n                // Update the child of this node.\r\n                child.update(agent, options);\r\n            }\r\n\r\n            // If the current child has a state of 'SUCCEEDED' then this node is also a 'SUCCEEDED' node.\r\n            if (child.getState() === State.SUCCEEDED) {\r\n                // This node is a 'SUCCEEDED' node.\r\n                this.setState(State.SUCCEEDED);\r\n\r\n                // There is no need to check the rest of the selector nodes.\r\n                return;\r\n            }\r\n\r\n            // If the current child has a state of 'FAILED' then we should move on to the next child.\r\n            if (child.getState() === State.FAILED) {\r\n                // Find out if the current child is the last one in the selector.\r\n                // If it is then this sequence node has also failed.\r\n                if (children.indexOf(child) === children.length - 1) {\r\n                    // This node is a 'FAILED' node.\r\n                    this.setState(State.FAILED);\r\n\r\n                    // There is no need to check the rest of the selector as we have completed it.\r\n                    return;\r\n                } else {\r\n                    // The child node failed, try the next one.\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // The node should be in the 'RUNNING' state.\r\n            if (child.getState() === State.RUNNING) {\r\n                // This node is a 'RUNNING' node.\r\n                this.setState(State.RUNNING);\r\n\r\n                // There is no need to check the rest of the selector as the current child is still running.\r\n                return;\r\n            }\r\n\r\n            // The child node was not in an expected state.\r\n            throw new Error(\"child node was not in an expected state.\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => \"SELECTOR\";\r\n}\r\n\r\nSelector.prototype = Object.create(Composite.prototype);\r\n", "import Composite from \"./composite\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A SEQUENCE node.\r\n * The child nodes are executed in sequence until one fails or all succeed.\r\n * @param decorators The node decorators.\r\n * @param children The child nodes.\r\n */\r\nexport default function Sequence(decorators, children) {\r\n    Composite.call(this, \"sequence\", decorators, children);\r\n\r\n    /**\r\n     * Update the node and get whether the node state has changed.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns Whether the state of this node has changed as part of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // Iterate over all of the children of this node.\r\n        for (const child of children) {\r\n            // If the child has never been updated or is running then we will need to update it now.\r\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\r\n                // Update the child of this node.\r\n                child.update(agent, options);\r\n            }\r\n\r\n            // If the current child has a state of 'SUCCEEDED' then we should move on to the next child.\r\n            if (child.getState() === State.SUCCEEDED) {\r\n                // Find out if the current child is the last one in the sequence.\r\n                // If it is then this sequence node has also succeeded.\r\n                if (children.indexOf(child) === children.length - 1) {\r\n                    // This node is a 'SUCCEEDED' node.\r\n                    this.setState(State.SUCCEEDED);\r\n\r\n                    // There is no need to check the rest of the sequence as we have completed it.\r\n                    return;\r\n                } else {\r\n                    // The child node succeeded, but we have not finished the sequence yet.\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            // If the current child has a state of 'FAILED' then this node is also a 'FAILED' node.\r\n            if (child.getState() === State.FAILED) {\r\n                // This node is a 'FAILED' node.\r\n                this.setState(State.FAILED);\r\n\r\n                // There is no need to check the rest of the sequence.\r\n                return;\r\n            }\r\n\r\n            // The node should be in the 'RUNNING' state.\r\n            if (child.getState() === State.RUNNING) {\r\n                // This node is a 'RUNNING' node.\r\n                this.setState(State.RUNNING);\r\n\r\n                // There is no need to check the rest of the sequence as the current child is still running.\r\n                return;\r\n            }\r\n\r\n            // The child node was not in an expected state.\r\n            throw new Error(\"child node was not in an expected state.\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => \"SEQUENCE\";\r\n}\r\n\r\nSequence.prototype = Object.create(Composite.prototype);\r\n", "import Composite from \"./composite\";\r\nimport State from \"../../State\";\r\n\r\n/**\r\n * A PARALLEL node.\r\n * The child nodes are executed concurrently until one fails or all succeed.\r\n * @param decorators The node decorators.\r\n * @param children The child nodes.\r\n */\r\nexport default function Parallel(decorators, children) {\r\n    Composite.call(this, \"parallel\", decorators, children);\r\n\r\n    /**\r\n     * Update the node and get whether the node state has changed.\r\n     * @param agent The agent.\r\n     * @param options The behaviour tree options object.\r\n     * @returns Whether the state of this node has changed as part of the update.\r\n     */\r\n    this.onUpdate = function (agent, options) {\r\n        // Keep a count of the number of succeeded child nodes.\r\n        let succeededCount = 0;\r\n\r\n        let hasChildFailed = false;\r\n\r\n        // Iterate over all of the children of this node.\r\n        for (const child of children) {\r\n            // If the child has never been updated or is running then we will need to update it now.\r\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\r\n                // Update the child of this node.\r\n                child.update(agent, options);\r\n            }\r\n\r\n            // If the current child has a state of 'SUCCEEDED' then we should move on to the next child.\r\n            if (child.getState() === State.SUCCEEDED) {\r\n                // The child node has succeeded, keep track of this to determine if all children have.\r\n                succeededCount++;\r\n\r\n                // The child node succeeded, but we have not finished checking every child node yet.\r\n                continue;\r\n            }\r\n\r\n            // If the current child has a state of 'FAILED' then this node is also a 'FAILED' node.\r\n            if (child.getState() === State.FAILED) {\r\n                hasChildFailed = true;\r\n\r\n                // There is no need to check the rest of the children.\r\n                break;\r\n            }\r\n\r\n            // The node should be in the 'RUNNING' state.\r\n            if (child.getState() !== State.RUNNING) {\r\n                // The child node was not in an expected state.\r\n                throw new Error(\"child node was not in an expected state.\");\r\n            }\r\n        }\r\n\r\n        if (hasChildFailed) {\r\n            // This node is a 'FAILED' node.\r\n            this.setState(State.FAILED);\r\n\r\n            // Abort every running child.\r\n            for (const child of children) {\r\n                if (child.getState() === State.RUNNING) {\r\n                    child.abort(agent);\r\n                }\r\n            }\r\n        } else {\r\n            // If all children have succeeded then this node has also succeeded, otherwise it is still running.\r\n            this.setState(succeededCount === children.length ? State.SUCCEEDED : State.RUNNING);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the node.\r\n     */\r\n    this.getName = () => \"PARALLEL\";\r\n}\r\n\r\nParallel.prototype = Object.create(Composite.prototype);\r\n", "import AttributeBuilder from \"./AttributeBuilder\";\r\nimport Action from \"./nodes/leaf/action\";\r\nimport Condition from \"./nodes/leaf/condition\";\r\nimport Wait from \"./nodes/leaf/wait\";\r\nimport Root from \"./nodes/decorator/root\";\r\nimport Repeat from \"./nodes/decorator/repeat\";\r\nimport Retry from \"./nodes/decorator/retry\";\r\nimport Flip from \"./nodes/decorator/flip\";\r\nimport Succeed from \"./nodes/decorator/succeed\";\r\nimport Fail from \"./nodes/decorator/fail\";\r\nimport Lotto from \"./nodes/composite/lotto\";\r\nimport Selector from \"./nodes/composite/selector\";\r\nimport Sequence from \"./nodes/composite/sequence\";\r\nimport Parallel from \"./nodes/composite/parallel\";\r\n\r\n/**\r\n * The AST node factories.\r\n */\r\nconst ASTNodeFactories = {\r\n    ROOT: () => ({\r\n        type: \"root\",\r\n        attributes: [],\r\n        name: null,\r\n        children: [],\r\n        validate: function (depth) {\r\n            // A root node cannot be the child of another node.\r\n            if (depth > 1) {\r\n                throw new Error(\"a root node cannot be the child of another node\");\r\n            }\r\n\r\n            // A root node must have a single child node.\r\n            if (this.children.length !== 1) {\r\n                throw new Error(\"a root node must have a single child\");\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Root(\r\n                this.attributes,\r\n                this.children[0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\r\n            );\r\n        }\r\n    }),\r\n    BRANCH: () => ({\r\n        type: \"branch\",\r\n        branchName: \"\",\r\n        validate: function (depth) {},\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            // Try to find the root node with a matching branch name.\r\n            const targetRootNode = namedRootNodeProvider(this.branchName);\r\n\r\n            // If we have already visited this branch then we have a circular dependency.\r\n            if (visitedBranches.indexOf(this.branchName) !== -1) {\r\n                throw new Error(`circular dependency found in branch node references for branch '${this.branchName}'`);\r\n            }\r\n\r\n            // If we have a target root node, then the node instance we want will be the first and only child of the referenced root node.\r\n            if (targetRootNode) {\r\n                return targetRootNode\r\n                    .createNodeInstance(namedRootNodeProvider, visitedBranches.concat(this.branchName))\r\n                    .getChildren()[0];\r\n            } else {\r\n                throw new Error(`branch references root node '${this.branchName}' which has not been defined`);\r\n            }\r\n        }\r\n    }),\r\n    SELECTOR: () => ({\r\n        type: \"selector\",\r\n        attributes: [],\r\n        children: [],\r\n        validate: function (depth) {\r\n            // A selector node must have at least a single node.\r\n            if (this.children.length < 1) {\r\n                throw new Error(\"a selector node must have at least a single child\");\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Selector(\r\n                this.attributes,\r\n                this.children.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\r\n            );\r\n        }\r\n    }),\r\n    SEQUENCE: () => ({\r\n        type: \"sequence\",\r\n        attributes: [],\r\n        children: [],\r\n        validate: function (depth) {\r\n            // A sequence node must have at least a single node.\r\n            if (this.children.length < 1) {\r\n                throw new Error(\"a sequence node must have at least a single child\");\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Sequence(\r\n                this.attributes,\r\n                this.children.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\r\n            );\r\n        }\r\n    }),\r\n    PARALLEL: () => ({\r\n        type: \"parallel\",\r\n        attributes: [],\r\n        children: [],\r\n        validate: function (depth) {\r\n            // A parallel node must have at least a single node.\r\n            if (this.children.length < 1) {\r\n                throw new Error(\"a parallel node must have at least a single child\");\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Parallel(\r\n                this.attributes,\r\n                this.children.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\r\n            );\r\n        }\r\n    }),\r\n    LOTTO: () => ({\r\n        type: \"lotto\",\r\n        attributes: [],\r\n        children: [],\r\n        tickets: [],\r\n        validate: function (depth) {\r\n            // A lotto node must have at least a single node.\r\n            if (this.children.length < 1) {\r\n                throw new Error(\"a lotto node must have at least a single child\");\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Lotto(\r\n                this.attributes,\r\n                this.tickets,\r\n                this.children.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\r\n            );\r\n        }\r\n    }),\r\n    REPEAT: () => ({\r\n        type: \"repeat\",\r\n        attributes: [],\r\n        iterations: null,\r\n        maximumIterations: null,\r\n        children: [],\r\n        validate: function (depth) {\r\n            // A repeat node must have a single node.\r\n            if (this.children.length !== 1) {\r\n                throw new Error(\"a repeat node must have a single child\");\r\n            }\r\n\r\n            // A repeat node must have a positive number of iterations if defined.\r\n            if (this.iterations !== null && this.iterations < 0) {\r\n                throw new Error(\"a repeat node must have a positive number of iterations if defined\");\r\n            }\r\n\r\n            // There is validation to carry out if a longest duration was defined.\r\n            if (this.maximumIterations !== null) {\r\n                // A repeat node must have a positive maximum iterations count if defined.\r\n                if (this.maximumIterations < 0) {\r\n                    throw new Error(\"a repeat node must have a positive maximum iterations count if defined\");\r\n                }\r\n\r\n                // A repeat node must not have an iteration count that exceeds the maximum iteration count.\r\n                if (this.iterations > this.maximumIterations) {\r\n                    throw new Error(\r\n                        \"a repeat node must not have an iteration count that exceeds the maximum iteration count\"\r\n                    );\r\n                }\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Repeat(\r\n                this.attributes,\r\n                this.iterations,\r\n                this.maximumIterations,\r\n                this.children[0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\r\n            );\r\n        }\r\n    }),\r\n    RETRY: () => ({\r\n        type: \"retry\",\r\n        attributes: [],\r\n        iterations: null,\r\n        maximumIterations: null,\r\n        children: [],\r\n        validate: function (depth) {\r\n            // A retry node must have a single node.\r\n            if (this.children.length !== 1) {\r\n                throw new Error(\"a retry node must have a single child\");\r\n            }\r\n\r\n            // A retry node must have a positive number of iterations if defined.\r\n            if (this.iterations !== null && this.iterations < 0) {\r\n                throw new Error(\"a retry node must have a positive number of iterations if defined\");\r\n            }\r\n\r\n            // There is validation to carry out if a longest duration was defined.\r\n            if (this.maximumIterations !== null) {\r\n                // A retry node must have a positive maximum iterations count if defined.\r\n                if (this.maximumIterations < 0) {\r\n                    throw new Error(\"a retry node must have a positive maximum iterations count if defined\");\r\n                }\r\n\r\n                // A retry node must not have an iteration count that exceeds the maximum iteration count.\r\n                if (this.iterations > this.maximumIterations) {\r\n                    throw new Error(\r\n                        \"a retry node must not have an iteration count that exceeds the maximum iteration count\"\r\n                    );\r\n                }\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Retry(\r\n                this.attributes,\r\n                this.iterations,\r\n                this.maximumIterations,\r\n                this.children[0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\r\n            );\r\n        }\r\n    }),\r\n    FLIP: () => ({\r\n        type: \"flip\",\r\n        attributes: [],\r\n        children: [],\r\n        validate: function (depth) {\r\n            // A flip node must have a single node.\r\n            if (this.children.length !== 1) {\r\n                throw new Error(\"a flip node must have a single child\");\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Flip(\r\n                this.attributes,\r\n                this.children[0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\r\n            );\r\n        }\r\n    }),\r\n    SUCCEED: () => ({\r\n        type: \"succeed\",\r\n        attributes: [],\r\n        children: [],\r\n        validate: function (depth) {\r\n            // A succeed node must have a single node.\r\n            if (this.children.length !== 1) {\r\n                throw new Error(\"a succeed node must have a single child\");\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Succeed(\r\n                this.attributes,\r\n                this.children[0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\r\n            );\r\n        }\r\n    }),\r\n    FAIL: () => ({\r\n        type: \"fail\",\r\n        attributes: [],\r\n        children: [],\r\n        validate: function (depth) {\r\n            // A fail node must have a single node.\r\n            if (this.children.length !== 1) {\r\n                throw new Error(\"a fail node must have a single child\");\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Fail(\r\n                this.attributes,\r\n                this.children[0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\r\n            );\r\n        }\r\n    }),\r\n    WAIT: () => ({\r\n        type: \"wait\",\r\n        attributes: [],\r\n        duration: null,\r\n        longestDuration: null,\r\n        validate: function (depth) {\r\n            // A wait node must have a positive duration.\r\n            if (this.duration < 0) {\r\n                throw new Error(\"a wait node must have a positive duration\");\r\n            }\r\n\r\n            // There is validation to carry out if a longest duration was defined.\r\n            if (this.longestDuration) {\r\n                // A wait node must have a positive longest duration.\r\n                if (this.longestDuration < 0) {\r\n                    throw new Error(\"a wait node must have a positive longest duration if one is defined\");\r\n                }\r\n\r\n                // A wait node must not have a duration that exceeds the longest duration.\r\n                if (this.duration > this.longestDuration) {\r\n                    throw new Error(\"a wait node must not have a shortest duration that exceeds the longest duration\");\r\n                }\r\n            }\r\n        },\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Wait(this.attributes, this.duration, this.longestDuration);\r\n        }\r\n    }),\r\n    ACTION: () => ({\r\n        type: \"action\",\r\n        attributes: [],\r\n        actionName: \"\",\r\n        actionArguments: [],\r\n        validate: function (depth) {},\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Action(this.attributes, this.actionName, this.actionArguments);\r\n        }\r\n    }),\r\n    CONDITION: () => ({\r\n        type: \"condition\",\r\n        attributes: [],\r\n        conditionName: \"\",\r\n        conditionArguments: [],\r\n        validate: function (depth) {},\r\n        createNodeInstance: function (namedRootNodeProvider, visitedBranches) {\r\n            return new Condition(this.attributes, this.conditionName, this.conditionArguments);\r\n        }\r\n    })\r\n};\r\n\r\n/**\r\n * Create an array of root AST nodes based on the given definition.\r\n * @param definition The definition to parse the AST nodes from.\r\n * @returns The base definition AST nodes.\r\n */\r\nexport default function parseRootNodes(definition) {\r\n    // Swap out any node/decorator argument string literals with a placeholder and get a mapping of placeholders to original values as well as the processed definition.\r\n    const { placeholders, processedDefinition } = substituteStringLiterals(definition);\r\n\r\n    // Convert the processed definition (with substituted string literals) into an array of raw tokens.\r\n    const tokens = parseTokensFromDefinition(processedDefinition);\r\n\r\n    // There must be at least 3 tokens for the tree definition to be valid. 'ROOT', '{' and '}'.\r\n    if (tokens.length < 3) {\r\n        throw new Error(\"invalid token count\");\r\n    }\r\n\r\n    // We should have a matching number of '{' and '}' tokens. If not, then there are scopes that have not been properly closed.\r\n    if (tokens.filter((token) => token === \"{\").length !== tokens.filter((token) => token === \"}\").length) {\r\n        throw new Error(\"scope character mismatch\");\r\n    }\r\n\r\n    // Create a stack of node children arrays, starting with a definition scope.\r\n    const stack = [[]];\r\n\r\n    // We should keep processing the raw tokens until we run out of them.\r\n    while (tokens.length) {\r\n        // Grab the next token.\r\n        const token = tokens.shift();\r\n\r\n        let node;\r\n\r\n        // How we create the next AST token depends on the current raw token value.\r\n        switch (token.toUpperCase()) {\r\n            case \"ROOT\":\r\n                // Create a ROOT AST node.\r\n                node = ASTNodeFactories.ROOT();\r\n\r\n                // Push the ROOT node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // We may have a root node name defined as an argument.\r\n                if (tokens[0] === \"[\") {\r\n                    const rootArguments = getArguments(tokens, placeholders);\r\n\r\n                    // We should have only a single argument that is not an empty string for a root node, which is the root name identifier.\r\n                    if (rootArguments.length === 1 && rootArguments[0].type === \"identifier\") {\r\n                        // The root name will be the first and only node argument.\r\n                        node.name = rootArguments[0].value;\r\n                    } else {\r\n                        throw new Error(\"expected single root name argument\");\r\n                    }\r\n                }\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new ROOT nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"BRANCH\":\r\n                // Create a BRANCH AST node.\r\n                node = ASTNodeFactories.BRANCH();\r\n\r\n                // Push the BRANCH node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // We must have arguments defined, as we require a branch name argument.\r\n                if (tokens[0] !== \"[\") {\r\n                    throw new Error(\"expected single branch name argument\");\r\n                }\r\n\r\n                // The branch name will be defined as a node argument.\r\n                const branchArguments = getArguments(tokens, placeholders);\r\n\r\n                // We should have only a single identifer argument for a branch node, which is the branch name.\r\n                if (branchArguments.length === 1 && branchArguments[0].type === \"identifier\") {\r\n                    // The branch name will be the first and only node argument.\r\n                    node.branchName = branchArguments[0].value;\r\n                } else {\r\n                    throw new Error(\"expected single branch name argument\");\r\n                }\r\n                break;\r\n\r\n            case \"SELECTOR\":\r\n                // Create a SELECTOR AST node.\r\n                node = ASTNodeFactories.SELECTOR();\r\n\r\n                // Push the SELECTOR node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new SELECTOR nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"SEQUENCE\":\r\n                // Create a SEQUENCE AST node.\r\n                node = ASTNodeFactories.SEQUENCE();\r\n\r\n                // Push the SEQUENCE node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new SEQUENCE nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"PARALLEL\":\r\n                // Create a PARALLEL AST node.\r\n                node = ASTNodeFactories.PARALLEL();\r\n\r\n                // Push the PARALLEL node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new PARALLEL nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"LOTTO\":\r\n                // Create a LOTTO AST node.\r\n                node = ASTNodeFactories.LOTTO();\r\n\r\n                // Push the LOTTO node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // If the next token is a '[' character then some ticket counts have been defined as arguments.\r\n                if (tokens[0] === \"[\") {\r\n                    // Get the ticket count arguments, each argument must be a number.\r\n                    node.tickets = getArguments(\r\n                        tokens,\r\n                        placeholders,\r\n                        (arg) => arg.type === \"number\" && arg.isInteger,\r\n                        \"lotto node ticket counts must be integer values\"\r\n                    ).map((argument) => argument.value);\r\n                }\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new LOTTO nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"CONDITION\":\r\n                // Create a CONDITION AST node.\r\n                node = ASTNodeFactories.CONDITION();\r\n\r\n                // Push the CONDITION node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // We must have arguments defined, as we require a condition function name argument.\r\n                if (tokens[0] !== \"[\") {\r\n                    throw new Error(\"expected condition name identifier argument\");\r\n                }\r\n\r\n                // Grab the condition node arguments.\r\n                const conditionArguments = getArguments(tokens, placeholders);\r\n\r\n                // We should have at least a single identifier argument for a condition node, which is the condition function name.\r\n                if (conditionArguments.length && conditionArguments[0].type === \"identifier\") {\r\n                    // The condition function name will be the first node argument.\r\n                    node.conditionName = conditionArguments.shift().value;\r\n                } else {\r\n                    throw new Error(\"expected condition name identifier argument\");\r\n                }\r\n\r\n                // Only the first argument should have been an identifier, all following arguments must be string, number, boolean or null.\r\n                conditionArguments\r\n                    .filter((arg) => arg.type === \"identifier\")\r\n                    .forEach((arg) => {\r\n                        throw new Error(\r\n                            \"invalid condition node argument value '\" +\r\n                                arg.value +\r\n                                \"', must be string, number, boolean or null\"\r\n                        );\r\n                    });\r\n\r\n                // Any node arguments that follow the condition name identifier will be treated as condition function arguments.\r\n                node.conditionArguments = conditionArguments;\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n                break;\r\n\r\n            case \"FLIP\":\r\n                // Create a FLIP AST node.\r\n                node = ASTNodeFactories.FLIP();\r\n\r\n                // Push the Flip node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new FLIP nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"SUCCEED\":\r\n                // Create a SUCCEED AST node.\r\n                node = ASTNodeFactories.SUCCEED();\r\n\r\n                // Push the Succeed node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new Succeed nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"FAIL\":\r\n                // Create a FAIL AST node.\r\n                node = ASTNodeFactories.FAIL();\r\n\r\n                // Push the Fail node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new Fail nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"WAIT\":\r\n                // Create a WAIT AST node.\r\n                node = ASTNodeFactories.WAIT();\r\n\r\n                // Push the WAIT node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // Get the duration and potential longest duration of the wait.\r\n                const durations = getArguments(\r\n                    tokens,\r\n                    placeholders,\r\n                    (arg) => arg.type === \"number\" && arg.isInteger,\r\n                    \"wait node durations must be integer values\"\r\n                ).map((argument) => argument.value);\r\n\r\n                // We should have got one or two durations.\r\n                if (durations.length === 1) {\r\n                    // A static duration was defined.\r\n                    node.duration = durations[0];\r\n                } else if (durations.length === 2) {\r\n                    // A shortest and longest duration was defined.\r\n                    node.duration = durations[0];\r\n                    node.longestDuration = durations[1];\r\n                } else {\r\n                    // An incorrect number of durations was defined.\r\n                    throw new Error(\"invalid number of wait node duration arguments defined\");\r\n                }\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n                break;\r\n\r\n            case \"REPEAT\":\r\n                // Create a REPEAT AST node.\r\n                node = ASTNodeFactories.REPEAT();\r\n\r\n                // Push the REPEAT node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // Check for iteration counts ([])\r\n                if (tokens[0] === \"[\") {\r\n                    // An iteration count has been defined. Get the iteration and potential maximum iteration of the wait.\r\n                    const iterationArguments = getArguments(\r\n                        tokens,\r\n                        placeholders,\r\n                        (arg) => arg.type === \"number\" && arg.isInteger,\r\n                        \"repeat node iteration counts must be integer values\"\r\n                    ).map((argument) => argument.value);\r\n\r\n                    // We should have got one or two iteration counts.\r\n                    if (iterationArguments.length === 1) {\r\n                        // A static iteration count was defined.\r\n                        node.iterations = iterationArguments[0];\r\n                    } else if (iterationArguments.length === 2) {\r\n                        // A minimum and maximum iteration count was defined.\r\n                        node.iterations = iterationArguments[0];\r\n                        node.maximumIterations = iterationArguments[1];\r\n                    } else {\r\n                        // An incorrect number of iteration counts was defined.\r\n                        throw new Error(\"invalid number of repeat node iteration count arguments defined\");\r\n                    }\r\n                }\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new REPEAT nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"RETRY\":\r\n                // Create a RETRY AST node.\r\n                node = ASTNodeFactories.RETRY();\r\n\r\n                // Push the RETRY node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // Check for iteration counts ([])\r\n                if (tokens[0] === \"[\") {\r\n                    // An iteration count has been defined. Get the iteration and potential maximum iteration of the wait.\r\n                    const iterationArguments = getArguments(\r\n                        tokens,\r\n                        placeholders,\r\n                        (arg) => arg.type === \"number\" && arg.isInteger,\r\n                        \"retry node iteration counts must be integer values\"\r\n                    ).map((argument) => argument.value);\r\n\r\n                    // We should have got one or two iteration counts.\r\n                    if (iterationArguments.length === 1) {\r\n                        // A static iteration count was defined.\r\n                        node.iterations = iterationArguments[0];\r\n                    } else if (iterationArguments.length === 2) {\r\n                        // A minimum and maximum iteration count was defined.\r\n                        node.iterations = iterationArguments[0];\r\n                        node.maximumIterations = iterationArguments[1];\r\n                    } else {\r\n                        // An incorrect number of iteration counts was defined.\r\n                        throw new Error(\"invalid number of retry node iteration count arguments defined\");\r\n                    }\r\n                }\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n\r\n                popAndCheck(tokens, \"{\");\r\n\r\n                // The new scope is that of the new RETRY nodes children.\r\n                stack.push(node.children);\r\n                break;\r\n\r\n            case \"ACTION\":\r\n                // Create a ACTION AST node.\r\n                node = ASTNodeFactories.ACTION();\r\n\r\n                // Push the ACTION node into the current scope.\r\n                stack[stack.length - 1].push(node);\r\n\r\n                // We must have arguments defined, as we require an action name argument.\r\n                if (tokens[0] !== \"[\") {\r\n                    throw new Error(\"expected action name identifier argument\");\r\n                }\r\n\r\n                // The action name will be defined as a node argument.\r\n                const actionArguments = getArguments(tokens, placeholders);\r\n\r\n                // We should have at least one identifer argument for an action node, which is the action name.\r\n                if (actionArguments.length && actionArguments[0].type === \"identifier\") {\r\n                    // The action name will be the first and only node argument.\r\n                    node.actionName = actionArguments.shift().value;\r\n                } else {\r\n                    throw new Error(\"expected action name identifier argument\");\r\n                }\r\n\r\n                // Only the first argument should have been an identifier, all following arguments must be string, number, boolean or null.\r\n                actionArguments\r\n                    .filter((arg) => arg.type === \"identifier\")\r\n                    .forEach((arg) => {\r\n                        throw new Error(\r\n                            \"invalid action node argument value '\" +\r\n                                arg.value +\r\n                                \"', must be string, number, boolean or null\"\r\n                        );\r\n                    });\r\n\r\n                // Any node arguments that follow the action name identifier will be treated as action function arguments.\r\n                node.actionArguments = actionArguments;\r\n\r\n                // Try to pick any attributes off of the token stack.\r\n                node.attributes = AttributeBuilder.parseFromTokens(tokens, placeholders);\r\n                break;\r\n\r\n            case \"}\":\r\n                // The '}' character closes the current scope.\r\n                stack.pop();\r\n                break;\r\n\r\n            default:\r\n                throw new Error(\"unexpected token: \" + token);\r\n        }\r\n    }\r\n\r\n    // A function to recursively validate each of the nodes in the AST.\r\n    const validateASTNode = (node, depth) => {\r\n        // Validate the node.\r\n        node.validate(depth);\r\n\r\n        // Validate each child of the node.\r\n        (node.children || []).forEach((child) => validateASTNode(child, depth + 1));\r\n    };\r\n\r\n    // Start node validation from the definition root.\r\n    validateASTNode(\r\n        {\r\n            children: stack[0],\r\n            validate: function (depth) {\r\n                // We must have at least one node defined as the definition scope, which should be a root node.\r\n                if (this.children.length === 0) {\r\n                    throw new Error(\"expected root node to have been defined\");\r\n                }\r\n\r\n                // Each node at the base of the definition scope MUST be a root node.\r\n                for (const definitionLevelNode of this.children) {\r\n                    if (definitionLevelNode.type !== \"root\") {\r\n                        throw new Error(\"expected root node at base of definition\");\r\n                    }\r\n                }\r\n\r\n                // Exactly one root node must not have a name defined. This will be the main root, others will have to be referenced via branch nodes.\r\n                if (\r\n                    this.children.filter(function (definitionLevelNode) {\r\n                        return definitionLevelNode.name === null;\r\n                    }).length !== 1\r\n                ) {\r\n                    throw new Error(\"expected single unnamed root node at base of definition to act as main root\");\r\n                }\r\n\r\n                // No two named root nodes can have matching names.\r\n                const rootNodeNames = [];\r\n                for (const definitionLevelNode of this.children) {\r\n                    if (rootNodeNames.indexOf(definitionLevelNode.name) !== -1) {\r\n                        throw new Error(`multiple root nodes found with duplicate name '${definitionLevelNode.name}'`);\r\n                    } else {\r\n                        rootNodeNames.push(definitionLevelNode.name);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        0\r\n    );\r\n\r\n    // Return the root AST nodes.\r\n    return stack[0];\r\n}\r\n\r\n/**\r\n * Pop the next raw token off of the stack and throw an error if it wasn't the expected one.\r\n * @param tokens The array of remaining tokens.\r\n * @param expected An optional string or array or items, one of which must match the next popped token.\r\n * @returns The popped token.\r\n */\r\nfunction popAndCheck(tokens, expected) {\r\n    // Get and remove the next token.\r\n    const popped = tokens.shift();\r\n\r\n    // We were expecting another token.\r\n    if (popped === undefined) {\r\n        throw new Error(\"unexpected end of definition\");\r\n    }\r\n\r\n    // Do we have an expected token/tokens array?\r\n    if (expected !== undefined) {\r\n        // Check whether the popped token matches at least one of our expected items.\r\n        var tokenMatchesExpectation = [].concat(expected).some((item) => popped.toUpperCase() === item.toUpperCase());\r\n\r\n        // Throw an error if the popped token didn't match any of our expected items.\r\n        if (!tokenMatchesExpectation) {\r\n            const expectationString = []\r\n                .concat(expected)\r\n                .map((item) => \"'\" + item + \"'\")\r\n                .join(\" or \");\r\n            throw new Error(\"unexpected token found. Expected \" + expected + \" but got '\" + popped + \"'\");\r\n        }\r\n    }\r\n\r\n    // Return the popped token.\r\n    return popped;\r\n}\r\n\r\n/**\r\n * Pull an argument definition list off of the token stack.\r\n * @param tokens The array of remaining tokens.\r\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\r\n * @param argumentValidator The argument validator function.\r\n * @param validationFailedMessage  The exception message to throw if argument validation fails.\r\n * @returns The argument definition list.\r\n */\r\nfunction getArguments(tokens, stringArgumentPlaceholders, argumentValidator, validationFailedMessage) {\r\n    // Any lists of arguments will always be wrapped in '[]' for node arguments or '()' for decorator arguments.\r\n    // We are looking for a '[' or '(' opener that wraps the argument tokens and the relevant closer.\r\n    const closer = popAndCheck(tokens, [\"[\", \"(\"]) === \"[\" ? \"]\" : \")\";\r\n\r\n    const argumentListTokens = [];\r\n    const argumentList = [];\r\n\r\n    // Grab all tokens between the '[' and ']' or '(' and ')'.\r\n    while (tokens.length && tokens[0] !== closer) {\r\n        // The next token is part of our arguments list.\r\n        argumentListTokens.push(tokens.shift());\r\n    }\r\n\r\n    // Validate the order of the argument tokens. Each token must either be a ',' or a single argument that satisfies the validator.\r\n    argumentListTokens.forEach((token, index) => {\r\n        // Get whether this token should be an actual argument.\r\n        const shouldBeArgumentToken = !(index & 1);\r\n\r\n        // If the current token should be an actual argument then validate it,otherwise it should be a ',' token.\r\n        if (shouldBeArgumentToken) {\r\n            // Get the argument definition.\r\n            const argumentDefinition = getArgumentDefinition(token, stringArgumentPlaceholders);\r\n\r\n            // Try to validate the argument.\r\n            if (argumentValidator && !argumentValidator(argumentDefinition)) {\r\n                throw new Error(validationFailedMessage);\r\n            }\r\n\r\n            // This is a valid argument!\r\n            argumentList.push(argumentDefinition);\r\n        } else {\r\n            // The current token should be a ',' token.\r\n            if (token !== \",\") {\r\n                throw new Error(`invalid argument list, expected ',' or ']' but got '${token}'`);\r\n            }\r\n        }\r\n    });\r\n\r\n    // The arguments list should terminate with a ']' or ')' token, depending on the opener.\r\n    popAndCheck(tokens, closer);\r\n\r\n    // Return the argument list.\r\n    return argumentList;\r\n}\r\n\r\n/**\r\n * Gets an argument value definition.\r\n * @param token The argument token.\r\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\r\n * @returns An argument value definition.\r\n */\r\nfunction getArgumentDefinition(token, stringArgumentPlaceholders) {\r\n    // Check whether the token represents a null value.\r\n    if (token === \"null\") {\r\n        return {\r\n            value: null,\r\n            type: \"null\",\r\n            toString: function () {\r\n                return this.value;\r\n            }\r\n        };\r\n    }\r\n\r\n    // Check whether the token represents a boolean value.\r\n    if (token === \"true\" || token === \"false\") {\r\n        return {\r\n            value: token === \"true\",\r\n            type: \"boolean\",\r\n            toString: function () {\r\n                return this.value;\r\n            }\r\n        };\r\n    }\r\n\r\n    // Check whether the token represents a number value.\r\n    if (!isNaN(token)) {\r\n        return {\r\n            value: parseFloat(token, 10),\r\n            isInteger: parseFloat(token, 10) === parseInt(token, 10),\r\n            type: \"number\",\r\n            toString: function () {\r\n                return this.value;\r\n            }\r\n        };\r\n    }\r\n\r\n    // Check whether the token is a placeholder (e.g. @@0@@) representing a string literal.\r\n    if (token.match(/^@@\\d+@@$/g)) {\r\n        return {\r\n            value: stringArgumentPlaceholders[token].replace('\\\\\"', '\"'),\r\n            type: \"string\",\r\n            toString: function () {\r\n                return '\"' + this.value + '\"';\r\n            }\r\n        };\r\n    }\r\n\r\n    // The only remaining option is that the argument value is an identifier.\r\n    return {\r\n        value: token,\r\n        type: \"identifier\",\r\n        toString: function () {\r\n            return this.value;\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Swaps out any node/decorator argument string literals with placeholders.\r\n * @param definition The definition.\r\n * @returns An object containing a mapping of placeholders to original string values as well as the processed definition string.\r\n */\r\nfunction substituteStringLiterals(definition) {\r\n    // Create an object to hold the mapping of placeholders to original string values.\r\n    const placeholders = {};\r\n\r\n    // Replace any string literals wrapped with double quotes in our definition with placeholders to be processed later.\r\n    const processedDefinition = definition.replace(/\\\"(\\\\.|[^\"\\\\])*\\\"/g, (match) => {\r\n        var strippedMatch = match.substring(1, match.length - 1);\r\n        var placeholder = Object.keys(placeholders).find((key) => placeholders[key] === strippedMatch);\r\n\r\n        // If we have no existing string literal match then create a new placeholder.\r\n        if (!placeholder) {\r\n            placeholder = `@@${Object.keys(placeholders).length}@@`;\r\n            placeholders[placeholder] = strippedMatch;\r\n        }\r\n\r\n        return placeholder;\r\n    });\r\n\r\n    return { placeholders, processedDefinition };\r\n}\r\n\r\n/**\r\n * Parse the tree definition into an array of raw tokens.\r\n * @param definition The definition.\r\n * @returns An array of tokens parsed from the definition.\r\n */\r\nfunction parseTokensFromDefinition(definition) {\r\n    // Add some space around various important characters so that they can be plucked out easier as individual tokens.\r\n    definition = definition.replace(/\\(/g, \" ( \");\r\n    definition = definition.replace(/\\)/g, \" ) \");\r\n    definition = definition.replace(/\\{/g, \" { \");\r\n    definition = definition.replace(/\\}/g, \" } \");\r\n    definition = definition.replace(/\\]/g, \" ] \");\r\n    definition = definition.replace(/\\[/g, \" [ \");\r\n    definition = definition.replace(/\\,/g, \" , \");\r\n\r\n    // Split the definition into raw token form and return it.\r\n    return definition.replace(/\\s+/g, \" \").trim().split(\" \");\r\n}\r\n", "import GuardPath from \"./attributes/guards/guardPath\";\r\nimport parseRootNodes from \"./NodeBuilder\";\r\nimport State from \"./State\";\r\nimport Lookup from \"./Lookup\";\r\n\r\n/**\r\n * The behaviour tree.\r\n */\r\nexport default class BehaviourTree {\r\n    /**\r\n     * The agent instance that this behaviour tree is modelling behaviour for.\r\n     */\r\n    #agent;\r\n    /**\r\n     * The main root tree node.\r\n     */\r\n    #rootNode;\r\n    /**\r\n     * The behaviour tree options object.\r\n     */\r\n    #options;\r\n\r\n    /**\r\n     * Constructor for the BehaviourTree class.\r\n     * @param definition The behaviour tree definition.\r\n     * @param agent The agent instance that this behaviour tree is modelling behaviour for.\r\n     * @param options The behaviour tree options object.\r\n     */\r\n    constructor(definition, agent, options = {}) {\r\n        this.#agent = agent;\r\n        this.#options = options;\r\n\r\n        // The tree definition must be defined and a valid string.\r\n        if (typeof definition !== \"string\") {\r\n            throw new Error(\"the tree definition must be a string\");\r\n        }\r\n\r\n        // The agent must be defined and not null.\r\n        if (typeof agent !== \"object\" || agent === null) {\r\n            throw new Error(\"the agent must be defined and not null\");\r\n        }\r\n\r\n        // Parse the behaviour tree definition, create the populated tree of behaviour tree nodes, and get the root.\r\n        this.#rootNode = BehaviourTree.#createRootNode(definition);\r\n    }\r\n\r\n    /**\r\n     * Gets the main root tree node.\r\n     * @returns The main root tree node.\r\n     */\r\n    get rootNode() {\r\n        return this.#rootNode;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the tree is in the running state.\r\n     * @returns Whether the tree is in the running state.\r\n     */\r\n    isRunning() {\r\n        return this.#rootNode.getState() === State.RUNNING;\r\n    }\r\n\r\n    /**\r\n     * Gets the current tree state of SUCCEEDED, FAILED, READY or RUNNING.\r\n     * @returns The current tree state.\r\n     */\r\n    getState() {\r\n        return this.#rootNode.getState();\r\n    }\r\n\r\n    /**\r\n     * Step the tree.\r\n     * This carries out a node update that traverses the tree from the root node outwards to any child nodes, skipping those that are already in a resolved state of SUCCEEDED or FAILED.\r\n     * Calling this method when the tree is already in a resolved state of SUCCEEDED or FAILED will cause it to be reset before tree traversal begins.\r\n     */\r\n    step() {\r\n        // If the root node has already been stepped to completion then we need to reset it.\r\n        if (this.#rootNode.getState() === State.SUCCEEDED || this.#rootNode.getState() === State.FAILED) {\r\n            this.#rootNode.reset();\r\n        }\r\n\r\n        try {\r\n            this.#rootNode.update(this.#agent, this.#options);\r\n        } catch (exception) {\r\n            throw new Error(`error stepping tree: ${exception.message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the tree from the root node outwards to each nested node, giving each a state of READY.\r\n     */\r\n    reset() {\r\n        this.#rootNode.reset();\r\n    }\r\n\r\n    /**\r\n     * Gets the tree as a flattened array of tree node details.\r\n     * @returns The tree as a flattened array of tree node details.\r\n     */\r\n    getFlattenedNodeDetails() {\r\n        // Create an empty flattened array of tree nodes.\r\n        const flattenedTreeNodes = [];\r\n\r\n        /**\r\n         * Helper function to process a node instance and push details into the flattened tree nodes array.\r\n         * @param node The current node.\r\n         * @param parentUid The UID of the node parent, or null if the node is the main root node.\r\n         */\r\n        const processNode = (node, parentUid) => {\r\n            // Push the current node into the flattened nodes array.\r\n            flattenedTreeNodes.push({\r\n                id: node.getUid(),\r\n                type: node.getType(),\r\n                caption: node.getName(),\r\n                state: node.getState(),\r\n                callbacks: node.getCallbackAttributes().map((callback) => callback.getDetails()),\r\n                guards: node.getGuardAttributes().map((guard) => guard.getDetails()),\r\n                arguments: node.getArguments(),\r\n                parentId: parentUid\r\n            });\r\n\r\n            // Process each of the nodes children if it is not a leaf node.\r\n            if (!node.isLeafNode()) {\r\n                node.getChildren().forEach((child) => processNode(child, node.getUid()));\r\n            }\r\n        };\r\n\r\n        // Convert the nested node structure into a flattened array of node details.\r\n        processNode(this.#rootNode, null);\r\n\r\n        return flattenedTreeNodes;\r\n    }\r\n\r\n    /**\r\n     * Registers the action/condition/guard/callback function or subtree with the given name.\r\n     * @param name The name of the function or subtree to register.\r\n     * @param value The function or subtree definition to register.\r\n     */\r\n    static register(name, value) {\r\n        if (typeof value === \"function\") {\r\n            // We are going to register a action/condition/guard/callback function.\r\n            Lookup.setFunc(name, value);\r\n        } else if (typeof value === \"string\") {\r\n            // We are going to register a subtree.\r\n            let rootASTNodes;\r\n\r\n            try {\r\n                // Try to create the behaviour tree AST based on the definition provided, this could fail if the definition is invalid.\r\n                rootASTNodes = parseRootNodes(value);\r\n            } catch (exception) {\r\n                // There was an issue in trying to parse and build the tree definition.\r\n                throw new Error(`error registering definition: ${exception.message}`);\r\n            }\r\n\r\n            // This function should only ever be called with a definition containing a single unnamed root node.\r\n            if (rootASTNodes.length != 1 || rootASTNodes[0].name !== null) {\r\n                throw new Error(\"error registering definition: expected a single unnamed root node\");\r\n            }\r\n\r\n            Lookup.setSubtree(name, rootASTNodes[0]);\r\n        } else {\r\n            throw new Error(\"unexpected value, expected string definition or function\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unregisters the action/condition/guard/callback function or subtree with the given name.\r\n     * @param name The name of the action/condition/guard/callback function or subtree to unregister.\r\n     */\r\n    static unregister(name) {\r\n        Lookup.remove(name);\r\n    }\r\n\r\n    /**\r\n     * Unregister all registered action/condition/guard/callback functions and subtrees.\r\n     */\r\n    static unregisterAll() {\r\n        Lookup.empty();\r\n    }\r\n\r\n    /**\r\n     * Parses a behaviour tree definition and creates a tree of behaviour tree nodes.\r\n     * @param {string} definition The behaviour tree definition.\r\n     * @returns The root behaviour tree node.\r\n     */\r\n    static #createRootNode(definition) {\r\n        try {\r\n            // Try to create the behaviour tree AST based on the definition provided, this could fail if the definition is invalid.\r\n            const rootNodes = parseRootNodes(definition);\r\n\r\n            // Create a symbol to use as the main root key in our root node mapping.\r\n            const mainRootNodeKey = Symbol(\"__root__\");\r\n\r\n            // Create a mapping of root node names to root AST tokens. The main root node will have a key of Symbol(\"__root__\").\r\n            const rootNodeMap = {};\r\n            for (const rootNode of rootNodes) {\r\n                rootNodeMap[rootNode.name === null ? mainRootNodeKey : rootNode.name] = rootNode;\r\n            }\r\n\r\n            // Create a provider for named root nodes that are part of our definition or have been registered. Prioritising the former.\r\n            const namedRootNodeProvider = function (name) {\r\n                return rootNodeMap[name] ? rootNodeMap[name] : Lookup.getSubtree(name);\r\n            };\r\n\r\n            // Convert the AST to our actual tree and get the root node.\r\n            const rootNode = rootNodeMap[mainRootNodeKey].createNodeInstance(namedRootNodeProvider, []);\r\n\r\n            // Set a guard path on every leaf of the tree to evaluate as part of its update.\r\n            BehaviourTree.#applyLeafNodeGuardPaths(rootNode);\r\n\r\n            // Return the root node.\r\n            return rootNode;\r\n        } catch (exception) {\r\n            // There was an issue in trying to parse and build the tree definition.\r\n            throw new Error(`error parsing tree: ${exception.message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a guard path to every leaf of the tree to evaluate as part of each update.\r\n     * @param {*} rootNode The main root tree node.\r\n     */\r\n    static #applyLeafNodeGuardPaths(rootNode) {\r\n        const nodePaths = [];\r\n\r\n        const findLeafNodes = (path, node) => {\r\n            // Add the current node to the path.\r\n            path = path.concat(node);\r\n\r\n            // Check whether the current node is a leaf node.\r\n            if (node.isLeafNode()) {\r\n                nodePaths.push(path);\r\n            } else {\r\n                node.getChildren().forEach((child) => findLeafNodes(path, child));\r\n            }\r\n        };\r\n\r\n        // Find all leaf node paths, starting from the root.\r\n        findLeafNodes([], rootNode);\r\n\r\n        nodePaths.forEach((path) => {\r\n            // Each node in the current path will have to be assigned a guard path, working from the root outwards.\r\n            for (let depth = 0; depth < path.length; depth++) {\r\n                // Get the node in the path at the current depth.\r\n                const currentNode = path[depth];\r\n\r\n                // The node may already have been assigned a guard path, if so just skip it.\r\n                if (currentNode.hasGuardPath()) {\r\n                    continue;\r\n                }\r\n\r\n                // Create the guard path for the current node.\r\n                const guardPath = new GuardPath(\r\n                    path\r\n                        .slice(0, depth + 1)\r\n                        .map((node) => ({\r\n                            node,\r\n                            guards: node.getAttributes().filter((attribute) => attribute.isGuard())\r\n                        }))\r\n                        .filter((details) => details.guards.length > 0)\r\n                );\r\n\r\n                // Assign the guard path to the current node.\r\n                currentNode.setGuardPath(guardPath);\r\n            }\r\n        });\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["type", "tickets", "getArguments", "rootNode"]
}
