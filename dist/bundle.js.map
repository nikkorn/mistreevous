{
  "version": 3,
  "sources": ["../node_modules/lotto-draw/dist/Participant.js", "../node_modules/lotto-draw/dist/Utilities.js", "../node_modules/lotto-draw/dist/Lotto.js", "../node_modules/lotto-draw/dist/createLotto.js", "../node_modules/lotto-draw/dist/index.js", "../src/index.ts", "../src/State.ts", "../src/BehaviourTreeDefinitionUtilities.ts", "../src/mdsl/MDSLUtilities.ts", "../src/mdsl/MDSLNodeArgumentParser.ts", "../src/mdsl/MDSLNodeAttributeParser.ts", "../src/mdsl/MDSLDefinitionParser.ts", "../src/BehaviourTreeDefinitionValidator.ts", "../src/attributes/guards/GuardUnsatisifedException.ts", "../src/attributes/guards/GuardPath.ts", "../src/nodes/Node.ts", "../src/nodes/leaf/Leaf.ts", "../src/Lookup.ts", "../src/nodes/leaf/Action.ts", "../src/nodes/leaf/Condition.ts", "../src/nodes/leaf/Wait.ts", "../src/nodes/decorator/Decorator.ts", "../src/nodes/decorator/Root.ts", "../src/nodes/decorator/Repeat.ts", "../src/nodes/decorator/Retry.ts", "../src/nodes/decorator/Flip.ts", "../src/nodes/decorator/Succeed.ts", "../src/nodes/decorator/Fail.ts", "../src/nodes/composite/Lotto.ts", "../src/nodes/composite/Composite.ts", "../src/nodes/composite/Selector.ts", "../src/nodes/composite/Sequence.ts", "../src/nodes/composite/Parallel.ts", "../src/attributes/Attribute.ts", "../src/attributes/guards/Guard.ts", "../src/attributes/guards/While.ts", "../src/attributes/guards/Until.ts", "../src/attributes/callbacks/Callback.ts", "../src/attributes/callbacks/Entry.ts", "../src/attributes/callbacks/Exit.ts", "../src/attributes/callbacks/Step.ts", "../src/RootAstNodesBuilder.ts", "../src/BehaviourTree.ts"],
  "sourcesContent": ["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Participant = void 0;\r\n/**\r\n * A participant that holds a number of tickets.\r\n */\r\nvar Participant = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of the Participant class.\r\n     * @param participant The actual participant.\r\n     * @param tickets The number of tickets held by the participant.\r\n     */\r\n    function Participant(participant, tickets) {\r\n        if (tickets === void 0) { tickets = 1; }\r\n        this._participant = participant;\r\n        this._tickets = tickets;\r\n    }\r\n    Object.defineProperty(Participant.prototype, \"participant\", {\r\n        /** Gets the actual participant. */\r\n        get: function () {\r\n            return this._participant;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Participant.prototype, \"tickets\", {\r\n        /** Gets or sets the number of tickets held by the participant. */\r\n        get: function () {\r\n            return this._tickets;\r\n        },\r\n        set: function (value) {\r\n            this._tickets = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return Participant;\r\n}());\r\nexports.Participant = Participant;\r\n", "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isNaturalNumber = exports.isNullOrUndefined = void 0;\r\n/**\r\n * Gets whether the value provided is null or undefined.\r\n * @param value The value to check.\r\n * @returns Whether the value provided is null or undefined.\r\n */\r\nfunction isNullOrUndefined(value) {\r\n    return value === null || value === undefined;\r\n}\r\nexports.isNullOrUndefined = isNullOrUndefined;\r\n/**\r\n * Gets whether the value provided is a natural number.\r\n * @param value The value to check.\r\n * @returns Whether the value provided is a natural number.\r\n */\r\nfunction isNaturalNumber(value) {\r\n    return typeof value === \"number\" && value >= 1 && Math.floor(value) === value;\r\n}\r\nexports.isNaturalNumber = isNaturalNumber;\r\n", "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Lotto = void 0;\r\nvar Participant_1 = require(\"./Participant\");\r\nvar Utilities_1 = require(\"./Utilities\");\r\n/**\r\n * Represents a lotto consisting of a number of pickable ticket-holding participants.\r\n */\r\nvar Lotto = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of Lotto.\r\n     * @param customRandom The custom RNG to use in place of Math.random().\r\n     */\r\n    function Lotto(customRandom) {\r\n        /** The array of participants that are holding tickets in the lotto. */\r\n        this._participants = [];\r\n        this._customRandom = customRandom;\r\n    }\r\n    /**\r\n     * Adds a participant with the specified number of tickets, or adds to the participant ticket count if the participant already holds tickets.\r\n     * @param participant The participant to add or to increase the ticket count for if they already hold tickets.\r\n     * @param tickets The number of tickets, defaults to 1.\r\n     * @returns The Lotto instance.\r\n     */\r\n    Lotto.prototype.add = function (participant, tickets) {\r\n        if (tickets === void 0) { tickets = 1; }\r\n        // Check that we have a valid ticket count.\r\n        if (!(0, Utilities_1.isNaturalNumber)(tickets)) {\r\n            throw new Error(\"tickets value must be a natural number\");\r\n        }\r\n        // Check whether this participant has already been added.\r\n        var existingParticipant = this._participants.find(function (part) { return part.participant === participant; });\r\n        if (existingParticipant) {\r\n            // The participant has already been added to the lotto so just add to their ticket count.\r\n            existingParticipant.tickets += tickets;\r\n        }\r\n        else {\r\n            // The participant is not part of the lotto so we should add them.\r\n            this._participants.push(new Participant_1.Participant(participant, tickets));\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the specified number of tickets for the given participant from the draw, or all tickets if a ticket number is not defined.\r\n     * @param participant The participant to remove tickets for.\r\n     * @param tickets The number of tickets to remove, or undefined if all tickets are to be removed.\r\n     * @returns The Lotto instance.\r\n     */\r\n    Lotto.prototype.remove = function (participant, tickets) {\r\n        // Attempt to get the existing participant.\r\n        var existingParticipant = this._participants.find(function (part) { return part.participant === participant; });\r\n        // There is nothing to do if the specified participant isn't even part of the lotto.\r\n        if (!existingParticipant) {\r\n            return this;\r\n        }\r\n        // Check whether a tickets value was given.\r\n        if (tickets !== undefined) {\r\n            // Check that we have a valid ticket count.\r\n            if (!(0, Utilities_1.isNaturalNumber)(tickets)) {\r\n                throw new Error(\"tickets value must be a natural number\");\r\n            }\r\n            existingParticipant.tickets -= tickets;\r\n            // If the participant no longer holds any tickets then they should be removed.\r\n            if (existingParticipant.tickets < 1) {\r\n                this._participants = this._participants.filter(function (part) { return part !== existingParticipant; });\r\n            }\r\n        }\r\n        else {\r\n            // We are removing all tickets for the participant so just remove them from the lotto.\r\n            this._participants = this._participants.filter(function (part) { return part !== existingParticipant; });\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Draw a winning ticket and return the participant that holds the ticket.\r\n     * @param options The draw options.\r\n     * @returns The participant that holds the winning ticket.\r\n     */\r\n    Lotto.prototype.draw = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        // If we have no participants then just return null.\r\n        if (this._participants.length === 0) {\r\n            return null;\r\n        }\r\n        var redrawable = (0, Utilities_1.isNullOrUndefined)(options.redrawable) ? true : options.redrawable;\r\n        var pickable = [];\r\n        this._participants.forEach(function (_a) {\r\n            var participant = _a.participant, tickets = _a.tickets;\r\n            for (var ticketCount = 0; ticketCount < tickets; ticketCount++) {\r\n                pickable.push(participant);\r\n            }\r\n        });\r\n        var random;\r\n        // We need a random floating-point number between 0 (inclusive) and 1 to scale up to pick our winner.\r\n        // If a custom random function exists then we should use that or fall back to Math.random().\r\n        if (this._customRandom) {\r\n            // Call our custom random function to get a random floating-point number.\r\n            random = this._customRandom();\r\n            // Verify that the result of calling our custom random function is a number between 0 (inclusive) and 1.\r\n            if (typeof random !== \"number\" || random < 0 || random >= 1) {\r\n                throw new Error(\"the 'random' function provided did not return a number between 0 (inclusive) and 1\");\r\n            }\r\n        }\r\n        else {\r\n            // No custom random function was defined so just use good ol' Math.random().\r\n            random = Math.random();\r\n        }\r\n        // Pick a winning participant.\r\n        var winner = pickable[Math.floor(random * pickable.length)];\r\n        // If the ticket isn't redrawable then we should remove a ticket from the winning participants ticket count.\r\n        if (!redrawable) {\r\n            this.remove(winner, 1);\r\n        }\r\n        // Return the winning participant.\r\n        return winner;\r\n    };\r\n    /**\r\n     * Draws multiple winning tickets and return an array of the participants that hold the winning tickets.\r\n     * @param tickets The number of winning tickets to draw.\r\n     * @param options The draw multiple options.\r\n     * @returns An array of the participants that hold the winning tickets.\r\n     */\r\n    Lotto.prototype.drawMultiple = function (tickets, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var uniqueResults = (0, Utilities_1.isNullOrUndefined)(options.unique) ? false : options.unique;\r\n        // Handle cases where the user has asked for zero tickets (no idea why they would do this be we should trust them).\r\n        if (tickets === 0) {\r\n            return [];\r\n        }\r\n        // Now that we know out tickets value is not zero we should check that it is a valid natural number.\r\n        if (!(0, Utilities_1.isNaturalNumber)(tickets)) {\r\n            throw new Error(\"tickets value must be a natural number\");\r\n        }\r\n        var result = [];\r\n        // Keep drawing tickets until we either reach the number of required tickets or we simply run out of tickets to draw.\r\n        // We can run out of tickets to draw if 'options.redrawable' is explicity 'false' or we just had no participants when 'drawMultiple' was called.\r\n        while (result.length < tickets && this._participants.length > 0) {\r\n            result.push(this.draw(options));\r\n        }\r\n        // If the 'unique' draw option is set then we need to remove duplicates from the result list.\r\n        if (uniqueResults) {\r\n            // Create an array to store our unique results.\r\n            var unique = [];\r\n            // Iterate over all of our participants (with potential duplicates) and populate our array of unique values.\r\n            for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\r\n                var participant = result_1[_i];\r\n                if (unique.indexOf(participant) === -1) {\r\n                    unique.push(participant);\r\n                }\r\n            }\r\n            result = unique;\r\n        }\r\n        return result;\r\n    };\r\n    return Lotto;\r\n}());\r\nexports.Lotto = Lotto;\r\n", "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createLotto = void 0;\r\nvar Lotto_1 = require(\"./Lotto\");\r\n/**\r\n * A function that creates and returns a Lotto instance.\r\n * @param participantsOrOptions An array of initial participants or options relating to the creation of a Lotto instance.\r\n * @returns A new Lotto instance.\r\n */\r\nfunction createLotto(participantsOrOptions) {\r\n    // If no initial participants or lotto options were provided as an argument then we can just return a new lotto instance now.\r\n    if (!participantsOrOptions) {\r\n        return new Lotto_1.Lotto();\r\n    }\r\n    // Check whether we were provided with an array of initial participants or a lotto options object.\r\n    if (Array.isArray(participantsOrOptions)) {\r\n        // We are dealing with a pre-defined array of participants.\r\n        var participants = participantsOrOptions;\r\n        var lotto_1 = new Lotto_1.Lotto();\r\n        // If the lotto participants have been defined upfront then we will need to add them all to our lotto instance now.\r\n        participants.forEach(function (_a) {\r\n            var participant = _a[0], tokens = _a[1];\r\n            return lotto_1.add(participant, tokens);\r\n        });\r\n        // Return the Lotto instance.\r\n        return lotto_1;\r\n    }\r\n    else {\r\n        // We are dealing with some lotto options.\r\n        var random = participantsOrOptions.random, participants = participantsOrOptions.participants;\r\n        // Create a Lotto instance passing the custom RNG function to use in place of Math.random() (which could be undefined).\r\n        var lotto_2 = new Lotto_1.Lotto(random);\r\n        // If the lotto participants have been defined upfront as part of the options then we will need to add them all to our lotto instance now.\r\n        if (participants) {\r\n            participants.forEach(function (_a) {\r\n                var participant = _a[0], tokens = _a[1];\r\n                return lotto_2.add(participant, tokens);\r\n            });\r\n        }\r\n        // Return the Lotto instance.\r\n        return lotto_2;\r\n    }\r\n}\r\nexports.createLotto = createLotto;\r\n", "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar createLotto_1 = require(\"./createLotto\");\r\nexports.default = createLotto_1.createLotto;\r\n", "import State from \"./State\";\nimport { validateDefinition } from \"./BehaviourTreeDefinitionValidator\";\nimport { convertMDSLToJSON } from \"./mdsl/MDSLDefinitionParser\";\nimport { BehaviourTree, FlattenedTreeNode } from \"./BehaviourTree\";\n\nexport { BehaviourTree, State, convertMDSLToJSON, validateDefinition };\nexport type { FlattenedTreeNode };\n", "/**\n * Enumeration of node state types.\n */\nexport enum State {\n    READY = \"mistreevous.ready\",\n    RUNNING = \"mistreevous.running\",\n    SUCCEEDED = \"mistreevous.succeeded\",\n    FAILED = \"mistreevous.failed\"\n}\n\nexport { State as default };\n\nexport type CompleteState = State.SUCCEEDED | State.FAILED;\nexport type AnyState = State.READY | State.RUNNING | CompleteState;\n", "import {\n    NodeDefinition,\n    RootNodeDefinition,\n    DecoratorNodeDefinition,\n    CompositeNodeDefinition,\n    AnyNode,\n    BranchNodeDefinition\n} from \"./BehaviourTreeDefinition\";\n\n/**\n * A type guard function that returns true if the specified node satisfies the RootNodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the RootNodeDefinition type.\n */\nexport function isRootNode(node: NodeDefinition): node is RootNodeDefinition {\n    return node.type === \"root\";\n}\n\n/**\n * A type guard function that returns true if the specified node satisfies the BranchNodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the BranchNodeDefinition type.\n */\nexport function isBranchNode(node: NodeDefinition): node is BranchNodeDefinition {\n    return node.type === \"branch\";\n}\n\n/**\n * A type guard function that returns true if the specified node satisfies the NodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the NodeDefinition type.\n */\nexport function isLeafNode(node: NodeDefinition): node is NodeDefinition {\n    return [\"branch\", \"action\", \"condition\", \"wait\"].includes(node.type);\n}\n\n/**\n * A type guard function that returns true if the specified node satisfies the DecoratorNodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the DecoratorNodeDefinition type.\n */\nexport function isDecoratorNode(node: NodeDefinition): node is DecoratorNodeDefinition {\n    return [\"root\", \"repeat\", \"retry\", \"flip\", \"succeed\", \"fail\"].includes(node.type);\n}\n\n/**\n * A type guard function that returns true if the specified node satisfies the CompositeNodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the CompositeNodeDefinition type.\n */\nexport function isCompositeNode(node: NodeDefinition): node is CompositeNodeDefinition {\n    return [\"sequence\", \"selector\", \"lotto\", \"parallel\"].includes(node.type);\n}\n\n/**\n * Flatten a node definition into an array of all of its nested node definitions.\n * @param nodeDefinition The node definition to flatten.\n * @returns An array of all of nested node definitions.\n */\nexport function flattenDefinition(nodeDefinition: AnyNode): AnyNode[] {\n    const nodes: AnyNode[] = [];\n\n    const processNode = (currentNodeDefinition: AnyNode) => {\n        nodes.push(currentNodeDefinition);\n\n        if (isCompositeNode(currentNodeDefinition)) {\n            currentNodeDefinition.children.forEach(processNode);\n        } else if (isDecoratorNode(currentNodeDefinition)) {\n            processNode(currentNodeDefinition.child);\n        }\n    };\n\n    processNode(nodeDefinition);\n\n    return nodes;\n}\n\n/**\n * Determines whether the passed value is an integer.\n * @param value The value to check.\n * @returns Whether the passed value is an integer.\n */\nexport function isInteger(value: unknown): boolean {\n    return typeof value === \"number\" && Math.floor(value) === value;\n}\n", "/**\n * A type defining an object that holds a reference to substitued string literals parsed from the definition.\n */\nexport type StringLiteralPlaceholders = { [key: string]: string };\n\n/**\n * Pop the next raw token from the specified array of tokens and throw an error if it wasn't the expected one.\n * @param tokens The array of tokens.\n * @param expected An optional string or array or items, one of which must match the next popped token.\n * @returns The popped token.\n */\nexport function popAndCheck(tokens: string[], expected?: string | string[]): string {\n    // Get and remove the next token.\n    const popped = tokens.shift();\n\n    // We were expecting another token but there aren't any.\n    if (popped === undefined) {\n        throw new Error(\"unexpected end of definition\");\n    }\n\n    // Do we have an expected token/tokens array?\n    if (expected != undefined) {\n        // Get an array of expected values, if the popped token matches any then we are all good.\n        const expectedValues = typeof expected === \"string\" ? [expected] : expected;\n\n        // Check whether the popped token matches at least one of our expected items.\n        var tokenMatchesExpectation = expectedValues.some((item) => popped.toUpperCase() === item.toUpperCase());\n\n        // Throw an error if the popped token didn't match any of our expected items.\n        if (!tokenMatchesExpectation) {\n            const expectationString = expectedValues.map((item) => \"'\" + item + \"'\").join(\" or \");\n            throw new Error(\"unexpected token found. Expected \" + expectationString + \" but got '\" + popped + \"'\");\n        }\n    }\n\n    // Return the popped token.\n    return popped;\n}\n\n/**\n * Swaps out any node/attribute argument string literals with placeholders.\n * @param definition The definition.\n * @returns An object containing a mapping of placeholders to original string values as well as the processed definition string.\n */\nexport function substituteStringLiterals(definition: string): {\n    placeholders: StringLiteralPlaceholders;\n    processedDefinition: string;\n} {\n    // Create an object to hold the mapping of placeholders to original string values.\n    const placeholders: StringLiteralPlaceholders = {};\n\n    // Replace any string literals wrapped with double quotes in our definition with placeholders to be processed later.\n    const processedDefinition = definition.replace(/\\\"(\\\\.|[^\"\\\\])*\\\"/g, (match) => {\n        var strippedMatch = match.substring(1, match.length - 1);\n        var placeholder = Object.keys(placeholders).find((key) => placeholders[key] === strippedMatch);\n\n        // If we have no existing string literal match then create a new placeholder.\n        if (!placeholder) {\n            placeholder = `@@${Object.keys(placeholders).length}@@`;\n            placeholders[placeholder] = strippedMatch;\n        }\n\n        return placeholder;\n    });\n\n    return { placeholders, processedDefinition };\n}\n\n/**\n * Parse the tree definition into an array of raw tokens.\n * @param definition The definition.\n * @returns An array of tokens parsed from the definition.\n */\nexport function parseTokensFromDefinition(definition: string): string[] {\n    // Add some space around various important characters so that they can be plucked out easier as individual tokens.\n    definition = definition.replace(/\\(/g, \" ( \");\n    definition = definition.replace(/\\)/g, \" ) \");\n    definition = definition.replace(/\\{/g, \" { \");\n    definition = definition.replace(/\\}/g, \" } \");\n    definition = definition.replace(/\\]/g, \" ] \");\n    definition = definition.replace(/\\[/g, \" [ \");\n    definition = definition.replace(/\\,/g, \" , \");\n\n    // Split the definition into raw token form and return it.\n    return definition.replace(/\\s+/g, \" \").trim().split(\" \");\n}\n", "import { StringLiteralPlaceholders, popAndCheck } from \"./MDSLUtilities\";\n\nexport type Argument<T> = {\n    /** The argument value. */\n    value: T;\n    /** The argument type, used for validation. */\n    type: string;\n};\n\nexport type NullArgument = Argument<null> & {\n    type: \"null\";\n};\n\nexport type BooleanArgument = Argument<boolean> & {\n    type: \"boolean\";\n};\n\nexport type NumberArgument = Argument<number> & {\n    type: \"number\";\n    isInteger: boolean; // Used for validation.\n};\n\nexport type StringPlaceholderArgument = Argument<string> & {\n    type: \"string\";\n};\n\nexport type IdentifierArgument = Argument<string> & {\n    type: \"identifier\";\n};\n\nexport type AnyArgument =\n    | NullArgument\n    | BooleanArgument\n    | NumberArgument\n    | StringPlaceholderArgument\n    | IdentifierArgument;\n\n/**\n * Parse an array of argument definitions from the specified tokens array.\n * @param tokens The array tokens to parse the argument definitions from.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @param argumentValidator The argument validator function.\n * @param validationFailedMessage  The exception message to throw if argument validation fails.\n * @returns An array of argument definitions parsed from the specified tokens array.\n */\nexport function parseArgumentTokens(\n    tokens: string[],\n    stringArgumentPlaceholders: StringLiteralPlaceholders\n): AnyArgument[] {\n    const argumentList: AnyArgument[] = [];\n\n    // If the next token is not a '[' or '(' then we have no arguments to parse.\n    if (![\"[\", \"(\"].includes(tokens[0])) {\n        return argumentList;\n    }\n\n    // Any lists of arguments will always be wrapped in '[]' for node arguments or '()' for attribute arguments.\n    // We are looking for a '[' or '(' opener that wraps the argument tokens and the relevant closer.\n    const closingToken = popAndCheck(tokens, [\"[\", \"(\"]) === \"[\" ? \"]\" : \")\";\n\n    const argumentListTokens: string[] = [];\n\n    // Grab all tokens between the '[' and ']' or '(' and ')'.\n    while (tokens.length && tokens[0] !== closingToken) {\n        // The next token is part of our arguments list.\n        argumentListTokens.push(tokens.shift()!);\n    }\n\n    // Validate the order of the argument tokens. Each token must either be a ',' or a single argument that satisfies the validator.\n    argumentListTokens.forEach((token, index) => {\n        // Get whether this token should be an actual argument.\n        const shouldBeArgumentToken = !(index & 1);\n\n        // If the current token should be an actual argument then validate it, otherwise it should be a ',' token.\n        if (shouldBeArgumentToken) {\n            // Get the argument definition.\n            const argumentDefinition = getArgumentDefinition(token, stringArgumentPlaceholders);\n\n            // This is a valid argument!\n            argumentList.push(argumentDefinition);\n        } else {\n            // The current token should be a ',' token.\n            if (token !== \",\") {\n                throw new Error(`invalid argument list, expected ',' or ']' but got '${token}'`);\n            }\n        }\n    });\n\n    // The arguments list should terminate with a ']' or ')' token, depending on the opener.\n    popAndCheck(tokens, closingToken);\n\n    // Return the arguments.\n    return argumentList;\n}\n\n/**\n * Gets an argument value definition.\n * @param token The argument token.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @returns An argument value definition.\n */\nfunction getArgumentDefinition(token: string, stringArgumentPlaceholders: StringLiteralPlaceholders): AnyArgument {\n    // Check whether the token represents a null value.\n    if (token === \"null\") {\n        return {\n            value: null,\n            type: \"null\"\n        } as NullArgument;\n    }\n\n    // Check whether the token represents a boolean value.\n    if (token === \"true\" || token === \"false\") {\n        return {\n            value: token === \"true\",\n            type: \"boolean\"\n        } as BooleanArgument;\n    }\n\n    // Check whether the token represents a number value.\n    // TODO: Relies on broken isNaN - see MDN.\n    // if (!Number.isNaN(token)) {\n    if (!isNaN(token as any)) {\n        return {\n            value: parseFloat(token),\n            isInteger: parseFloat(token) === parseInt(token, 10),\n            type: \"number\"\n        } as NumberArgument;\n    }\n\n    // Check whether the token is a placeholder (e.g. @@0@@) representing a string literal.\n    if (token.match(/^@@\\d+@@$/g)) {\n        return {\n            value: stringArgumentPlaceholders[token].replace('\\\\\"', '\"'),\n            type: \"string\"\n        } as StringPlaceholderArgument;\n    }\n\n    // The only remaining option is that the argument value is an identifier.\n    return {\n        value: token,\n        type: \"identifier\"\n    } as IdentifierArgument;\n}\n", "import { NodeAttributeDefinition } from \"../BehaviourTreeDefinition\";\nimport { parseArgumentTokens } from \"./MDSLNodeArgumentParser\";\nimport { StringLiteralPlaceholders } from \"./MDSLUtilities\";\n\n/**\n * A type defining the attribute definitions of a node.\n */\ntype NodeAttributes = {\n    while?: NodeAttributeDefinition;\n    until?: NodeAttributeDefinition;\n    entry?: NodeAttributeDefinition;\n    exit?: NodeAttributeDefinition;\n    step?: NodeAttributeDefinition;\n};\n\n/**\n * Parse any node attribute definitions from the specified tokens array.\n * @param tokens The array of remaining tokens.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @returns An object of attribute definitions defined by any directly following tokens.\n */\nexport function parseAttributeTokens(\n    tokens: string[],\n    stringArgumentPlaceholders: StringLiteralPlaceholders\n): NodeAttributes {\n    const nodeAttributeNames: (keyof NodeAttributes)[] = [\"while\", \"until\", \"entry\", \"exit\", \"step\"];\n\n    // Create an object to hold any attributes found.\n    const attributes: NodeAttributes = {};\n\n    // Try to get the name of the attribute for the next token.\n    let nextAttributeName = tokens[0]?.toLowerCase() as keyof NodeAttributes;\n\n    // Pull attribute tokens as well as their arguments off of the tokens stack until we have no more.\n    while (nodeAttributeNames.includes(nextAttributeName)) {\n        // Check to make sure that we have not already created an attribute definition of this type.\n        if (attributes[nextAttributeName]) {\n            throw new Error(`duplicate attribute '${tokens[0].toUpperCase()}' found for node`);\n        }\n\n        // Remove the attribute name token from the array of tokens.\n        tokens.shift();\n\n        // Grab the attribute arguments, assuming the first to be an identifier.\n        const [attributeCallIdentifier, ...attributeArguments] = parseArgumentTokens(\n            tokens,\n            stringArgumentPlaceholders\n        );\n\n        // The first attribute argument has to be an identifer, this will reference an agent function.\n        if (attributeCallIdentifier?.type !== \"identifier\") {\n            throw new Error(\"expected agent function name identifier argument for attribute\");\n        }\n\n        // Any attribute arguments (other than the expected call identifier) must have a type of string, number, boolean or null.\n        attributeArguments\n            .filter((arg) => arg.type === \"identifier\")\n            .forEach((arg) => {\n                throw new Error(\n                    `invalid attribute argument value '${arg.value}', must be string, number, boolean or null`\n                );\n            });\n\n        // Create the attribute definition and add it to the object of attribute definitions found.\n        attributes[nextAttributeName] = {\n            call: attributeCallIdentifier.value,\n            args: attributeArguments.map(({ value }) => value)\n        };\n\n        // Try to get the next attribute name token, as there could be multiple.\n        nextAttributeName = tokens[0]?.toLowerCase() as keyof NodeAttributes;\n    }\n\n    return attributes;\n}\n", "import {\n    ActionNodeDefinition,\n    AnyChildNode,\n    AnyNode,\n    BranchNodeDefinition,\n    ConditionNodeDefinition,\n    FailNodeDefinition,\n    FlipNodeDefinition,\n    LottoNodeDefinition,\n    ParallelNodeDefinition,\n    RepeatNodeDefinition,\n    RetryNodeDefinition,\n    RootNodeDefinition,\n    SelectorNodeDefinition,\n    SequenceNodeDefinition,\n    SucceedNodeDefinition,\n    WaitNodeDefinition\n} from \"../BehaviourTreeDefinition\";\nimport { isCompositeNode, isDecoratorNode, isLeafNode, isRootNode } from \"../BehaviourTreeDefinitionUtilities\";\nimport { parseArgumentTokens } from \"./MDSLNodeArgumentParser\";\nimport { parseAttributeTokens } from \"./MDSLNodeAttributeParser\";\nimport {\n    StringLiteralPlaceholders,\n    parseTokensFromDefinition,\n    popAndCheck,\n    substituteStringLiterals\n} from \"./MDSLUtilities\";\n\n/**\n * Convert the MDSL tree definition string into an equivalent JSON definition.\n * @param definition The tree definition string as MDSL.\n * @returns The root node JSON definitions.\n */\nexport function convertMDSLToJSON(definition: string): RootNodeDefinition[] {\n    // Swap out any node/attribute argument string literals with a placeholder and get a mapping of placeholders to original values as well as the processed definition.\n    const { placeholders, processedDefinition } = substituteStringLiterals(definition);\n\n    // Parse our definition definition string into an array of raw tokens.\n    const tokens = parseTokensFromDefinition(processedDefinition);\n\n    return convertTokensToJSONDefinition(tokens, placeholders);\n}\n\n/**\n * Converts the specified tree definition tokens into a JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The root node JSON definitions.\n */\nfunction convertTokensToJSONDefinition(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): RootNodeDefinition[] {\n    // There must be at least 3 tokens for the tree definition to be valid. 'ROOT', '{' and '}'.\n    if (tokens.length < 3) {\n        throw new Error(\"invalid token count\");\n    }\n\n    // We should have a matching number of '{' and '}' tokens. If not, then there are scopes that have not been properly closed.\n    if (tokens.filter((token) => token === \"{\").length !== tokens.filter((token) => token === \"}\").length) {\n        throw new Error(\"scope character mismatch\");\n    }\n\n    // Create an array of tree stack arrays where root nodes will always be at the botton and the current composite/decorator node at the top.\n    // There should be an element in this array for every root node defined and every element should be an array with a root note as the first element.\n    // E.g. A definition with two root nodes defined:\n    // [\n    //    [root, lotto, sequence],\n    //    [root, selector]\n    // ]\n    const treeStacks: [Partial<RootNodeDefinition>, ...Partial<AnyChildNode>[]][] = [];\n\n    // Create an array of all root node definitions that we create.\n    const rootNodes: Partial<RootNodeDefinition>[] = [];\n\n    // A helper function used to push node definitions onto the tree stack.\n    const pushNode = (node: AnyNode) => {\n        // If the node is a root node then we need to create a new tree stack array with the root node at the root.\n        if (isRootNode(node)) {\n            // Add the root node definition to our array of all parsed root node definitions.\n            rootNodes.push(node);\n\n            // Add the root node definition to the root of a new tree stack.\n            treeStacks.push([node]);\n\n            return;\n        }\n\n        // All non-root nodes should be pushed after their root nodes so handle cases\n        // where we may not have any tree stacks or our top-most tree stack is empty.\n        if (!treeStacks.length || !treeStacks[treeStacks.length - 1].length) {\n            throw new Error(\"expected root node at base of definition\");\n        }\n\n        // Get the current tree stack that we are populating.\n        const topTreeStack = treeStacks[treeStacks.length - 1];\n\n        // Get the top-most node in the current tree stack, this will be a composite/decorator node\n        // for which we will populate its children array if composite or setting its child if a decorator.\n        const topTreeStackTopNode = topTreeStack[topTreeStack.length - 1] as AnyNode;\n\n        // If the top-most node in the current root stack is a composite or decorator\n        // node then the current node should be added as a child of the top-most node.\n        if (isCompositeNode(topTreeStackTopNode)) {\n            topTreeStackTopNode.children = topTreeStackTopNode.children || [];\n            topTreeStackTopNode.children.push(node);\n        } else if (isDecoratorNode(topTreeStackTopNode)) {\n            // If the top node already has a child node set then throw an error as a decorator should only have a single child.\n            if (topTreeStackTopNode.child) {\n                throw new Error(\"a decorator node must only have a single child node\");\n            }\n\n            topTreeStackTopNode.child = node;\n        }\n\n        // If the node we are adding is also a composite or decorator node, then we should push it\n        // onto the current tree stack, as subsequent nodes will be added as its child/children.\n        if (!isLeafNode(node)) {\n            topTreeStack.push(node);\n        }\n    };\n\n    // A helper function used to pop node definitions off of the stack.\n    const popNode = () => {\n        // Get the current tree stack that we are populating.\n        const topTreeStack = treeStacks[treeStacks.length - 1];\n\n        // Pop the top-most node in the current tree stack if there is one.\n        if (topTreeStack.length) {\n            topTreeStack.pop();\n        }\n\n        // We don't want any empty tree stacks in our stack of tree stacks.\n        if (!topTreeStack.length) {\n            treeStacks.pop();\n        }\n    };\n\n    // We should keep processing the raw tokens until we run out of them.\n    while (tokens.length) {\n        // Grab the next token.\n        const token = tokens.shift()!;\n\n        // How we create the next node depends on the current raw token value.\n        switch (token.toUpperCase()) {\n            case \"ROOT\": {\n                pushNode(createRootNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"SUCCEED\": {\n                pushNode(createSucceedNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"FAIL\": {\n                pushNode(createFailNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"FLIP\": {\n                pushNode(createFlipNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"REPEAT\": {\n                pushNode(createRepeatNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"RETRY\": {\n                pushNode(createRetryNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"SEQUENCE\": {\n                pushNode(createSequenceNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"SELECTOR\": {\n                pushNode(createSelectorNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"PARALLEL\": {\n                pushNode(createParallelNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"LOTTO\": {\n                pushNode(createLottoNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"ACTION\": {\n                pushNode(createActionNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"CONDITION\": {\n                pushNode(createConditionNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"WAIT\": {\n                pushNode(createWaitNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"BRANCH\": {\n                pushNode(createBranchNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"}\": {\n                // The '}' character closes the current scope and means that we have to pop a node off of the current stack.\n                popNode();\n                break;\n            }\n\n            default: {\n                throw new Error(`unexpected token: ${token}`);\n            }\n        }\n    }\n\n    return rootNodes as RootNodeDefinition[];\n}\n\n/**\n * Creates a root node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The root node JSON definition.\n */\nfunction createRootNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): RootNodeDefinition {\n    // Create the root node definition.\n    let node = {\n        type: \"root\",\n        id: undefined\n    } as RootNodeDefinition;\n\n    // Parse any node arguments, we should only have one if any which will be an identifier argument for the root identifier.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // Check whether any node arguments were defined.\n    if (nodeArguments.length) {\n        // We should only have one argument, if any, which will be an identifier argument for the root identifier.\n        if (nodeArguments.length === 1 && nodeArguments[0].type === \"identifier\") {\n            // The root node identifier will be the first and only node argument value.\n            node.id = nodeArguments[0].value as string;\n        } else {\n            throw new Error(\"expected single root name argument\");\n        }\n    }\n\n    // Grab any node attribute definitions and spread them into the node definition.\n    node = { ...node, ...parseAttributeTokens(tokens, stringLiteralPlaceholders) };\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the root node definition.\n    return node;\n}\n\n/**\n * Creates a succeed node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The succeed node JSON definition.\n */\nfunction createSucceedNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): SucceedNodeDefinition {\n    const node = {\n        type: \"succeed\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as SucceedNodeDefinition;\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the succeed node definition.\n    return node;\n}\n\n/**\n * Creates a fail node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The fail node JSON definition.\n */\nfunction createFailNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): FailNodeDefinition {\n    const node = {\n        type: \"fail\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as FailNodeDefinition;\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the fail node definition.\n    return node;\n}\n\n/**\n * Creates a flip node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The flip node JSON definition.\n */\nfunction createFlipNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): FlipNodeDefinition {\n    const node = {\n        type: \"flip\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as FlipNodeDefinition;\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the flip node definition.\n    return node;\n}\n\n/**\n * Creates a repeat node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The repeat node JSON definition.\n */\nfunction createRepeatNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): RepeatNodeDefinition {\n    let node = { type: \"repeat\" } as RepeatNodeDefinition;\n\n    // Get the node arguments.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // The arguments of a repeat node are optional. We may have:\n    // - No node arguments, in which case the repeat note will iterate indefinitely.\n    // - One node argument which will be the explicit number of iterations to make.\n    // - Two node arguments which define the min and max iteration bounds from which a random iteration count will be picked.\n    if (nodeArguments.length) {\n        // All repeat node arguments MUST be of type number and must be integer.\n        nodeArguments\n            .filter((arg) => arg.type !== \"number\" || !arg.isInteger)\n            .forEach(() => {\n                throw new Error(`repeat node iteration counts must be integer values`);\n            });\n\n        // We should have got one or two iteration counts.\n        if (nodeArguments.length === 1) {\n            // A static iteration count was defined.\n            node.iterations = nodeArguments[0].value as number;\n        } else if (nodeArguments.length === 2) {\n            // A minimum and maximum iteration count was defined.\n            node.iterations = [nodeArguments[0].value as number, nodeArguments[1].value as number];\n        } else {\n            // An incorrect number of iteration counts was defined.\n            throw new Error(\"invalid number of repeat node iteration count arguments defined\");\n        }\n    }\n\n    // Grab any node attribute definitions and spread them into the node definition.\n    node = { ...node, ...parseAttributeTokens(tokens, stringLiteralPlaceholders) };\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the repeat node definition.\n    return node;\n}\n\n/**\n * Creates a retry node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The retry node JSON definition.\n */\nfunction createRetryNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): RetryNodeDefinition {\n    let node = { type: \"retry\" } as RetryNodeDefinition;\n\n    // Get the node arguments.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // The arguments of a retry node are optional. We may have:\n    // - No node arguments, in which case the retry note will attempt indefinitely.\n    // - One node argument which will be the explicit number of attempts to make.\n    // - Two node arguments which define the min and max attempt bounds from which a random attempt count will be picked.\n    if (nodeArguments.length) {\n        // All retry node arguments MUST be of type number and must be integer.\n        nodeArguments\n            .filter((arg) => arg.type !== \"number\" || !arg.isInteger)\n            .forEach(() => {\n                throw new Error(`retry node attempt counts must be integer values`);\n            });\n\n        // We should have got one or two attempt counts.\n        if (nodeArguments.length === 1) {\n            // A static attempt count was defined.\n            node.attempts = nodeArguments[0].value as number;\n        } else if (nodeArguments.length === 2) {\n            // A minimum and maximum attempt count was defined.\n            node.attempts = [nodeArguments[0].value as number, nodeArguments[1].value as number];\n        } else {\n            // An incorrect number of attempt counts was defined.\n            throw new Error(\"invalid number of retry node attempt count arguments defined\");\n        }\n    }\n\n    // Grab any node attribute definitions and spread them into the node definition.\n    node = { ...node, ...parseAttributeTokens(tokens, stringLiteralPlaceholders) };\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the retry node definition.\n    return node;\n}\n\n/**\n * Creates a sequence node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The sequence node JSON definition.\n */\nfunction createSequenceNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): SequenceNodeDefinition {\n    const node = {\n        type: \"sequence\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as SequenceNodeDefinition;\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the sequence node definition.\n    return node;\n}\n\n/**\n * Creates a selector node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The selector node JSON definition.\n */\nfunction createSelectorNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): SelectorNodeDefinition {\n    const node = {\n        type: \"selector\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as SelectorNodeDefinition;\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the selector node definition.\n    return node;\n}\n\n/**\n * Creates a parallel node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The parallel node JSON definition.\n */\nfunction createParallelNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): ParallelNodeDefinition {\n    const node = {\n        type: \"parallel\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as ParallelNodeDefinition;\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the parallel node definition.\n    return node;\n}\n\n/**\n * Creates a lotto node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The lotto node JSON definition.\n */\nfunction createLottoNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): LottoNodeDefinition {\n    // If any node arguments have been defined then they must be our weights.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // All lotto node arguments MUST be of type number and must be integer.\n    nodeArguments\n        .filter((arg) => arg.type !== \"number\" || !arg.isInteger)\n        .forEach(() => {\n            throw new Error(`lotto node weight arguments must be integer values`);\n        });\n\n    const node = {\n        type: \"lotto\",\n        weights: nodeArguments.map(({ value }) => value),\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as LottoNodeDefinition;\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the lotto node definition.\n    return node;\n}\n\n/**\n * Creates an action node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The action node JSON definition.\n */\nfunction createActionNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): ActionNodeDefinition {\n    // Parse any node arguments, we should have at least one which will be an identifier argument for the action name\n    // and agent function to invoke for the action, all other arguments are to be passed as arguments to that function.\n    const [actionNameIdentifier, ...agentFunctionArgs] = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // Our first argument MUST be defined and be an identifier as we require an action name argument.\n    if (actionNameIdentifier?.type !== \"identifier\") {\n        throw new Error(\"expected action name identifier argument\");\n    }\n\n    // Only the first argument should have been an identifier, all agent function arguments must be string, number, boolean or null.\n    agentFunctionArgs\n        .filter((arg) => arg.type === \"identifier\")\n        .forEach((arg) => {\n            throw new Error(\n                `invalid action node argument value '${arg.value}', must be string, number, boolean or null`\n            );\n        });\n\n    // Return the action node definition.\n    return {\n        type: \"action\",\n        call: actionNameIdentifier.value,\n        args: agentFunctionArgs.map(({ value }) => value),\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    };\n}\n\n/**\n * Creates a condition node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The condition node JSON definition.\n */\nfunction createConditionNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): ConditionNodeDefinition {\n    // Parse any node arguments, we should have at least one which will be an identifier argument for the condition name\n    // and agent function to invoke for the condition, all other arguments are to be passed as arguments to that function.\n    const [conditionNameIdentifier, ...agentFunctionArgs] = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // Our first argument MUST be defined and be an identifier as we require a condition name argument.\n    if (conditionNameIdentifier?.type !== \"identifier\") {\n        throw new Error(\"expected condition name identifier argument\");\n    }\n\n    // Only the first argument should have been an identifier, all agent function arguments must be string, number, boolean or null.\n    agentFunctionArgs\n        .filter((arg) => arg.type === \"identifier\")\n        .forEach((arg) => {\n            throw new Error(\n                `invalid condition node argument value '${arg.value}', must be string, number, boolean or null`\n            );\n        });\n\n    // Return the condition node definition.\n    return {\n        type: \"condition\",\n        call: conditionNameIdentifier.value,\n        args: agentFunctionArgs.map(({ value }) => value),\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    };\n}\n\n/**\n * Creates a wait node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The wait node JSON definition.\n */\nfunction createWaitNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): WaitNodeDefinition {\n    let node = { type: \"wait\" } as WaitNodeDefinition;\n\n    // Get the node arguments.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // The arguments of a wait node are optional. We may have:\n    // - No node arguments, in which case the wait will be indefinite until it is aborted.\n    // - One node argument which will be the explicit duration of the wait.\n    // - Two node arguments which define the min and max duration bounds from which a random duration will be picked.\n    if (nodeArguments.length) {\n        // All wait node arguments MUST be of type number and must be integer.\n        nodeArguments\n            .filter((arg) => arg.type !== \"number\" || !arg.isInteger)\n            .forEach(() => {\n                throw new Error(`wait node duration arguments must be integer values`);\n            });\n\n        // We may have:\n        // - One node argument which will be the explicit duration of the wait.\n        // - Two node arguments which define the min and max duration bounds from which a random duration will be picked.\n        // - Too many arguments, which is not valid.\n        if (nodeArguments.length === 1) {\n            // An explicit duration was defined.\n            node.duration = nodeArguments[0].value as number;\n        } else if (nodeArguments.length === 2) {\n            // Min and max duration bounds were defined from which a random duration will be picked.\n            node.duration = [nodeArguments[0].value as number, nodeArguments[1].value as number];\n        } else if (nodeArguments.length > 2) {\n            // An incorrect number of duration arguments were defined.\n            throw new Error(\"invalid number of wait node duration arguments defined\");\n        }\n    }\n\n    // Return the wait node definition.\n    return { ...node, ...parseAttributeTokens(tokens, stringLiteralPlaceholders) };\n}\n\n/**\n * Creates a branch node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The branch node JSON definition.\n */\nfunction createBranchNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): BranchNodeDefinition {\n    // Parse any node arguments, we should have one which will be an identifier argument for the root ref.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // We should have only a single identifer argument for a branch node, which is the root ref.\n    if (nodeArguments.length !== 1 || nodeArguments[0].type !== \"identifier\") {\n        throw new Error(\"expected single branch name argument\");\n    }\n\n    // Return the branch node definition.\n    return { type: \"branch\", ref: nodeArguments[0].value };\n}\n", "import { RootNodeDefinition } from \"./BehaviourTreeDefinition\";\nimport { flattenDefinition, isBranchNode, isInteger } from \"./BehaviourTreeDefinitionUtilities\";\nimport { convertMDSLToJSON } from \"./mdsl/MDSLDefinitionParser\";\n\n/**\n * An object representing the result of validating a tree definition.\n */\nexport type DefinitionValidationResult = {\n    /**\n     * A flag defining whether validation succeeded.\n     */\n    succeeded: boolean;\n    /**\n     * A string containing the error message if validation did not succeed.\n     */\n    errorMessage?: string;\n};\n\n/**\n * Validates the specified behaviour tree definition in the form of JSON or MDSL.\n * @param definition The behaviour tree definition in the form of JSON or MDSL.\n * @returns An object representing the result of validating the given tree definition.\n */\nexport function validateDefinition(definition: any): DefinitionValidationResult {\n    // A helper function to create a failure validation result with the given error message.\n    const createFailureResult = (errorMessage: string) => ({ succeeded: false, errorMessage });\n\n    // The definition must be defined.\n    if (definition === null || typeof definition === \"undefined\") {\n        return createFailureResult(\"definition is null or undefined\");\n    }\n\n    let rootNodeDefinitions: any[];\n\n    // We are expecting a definition in one of three different forms:\n    // - A string which we will assume is mdsl and we will parse this to JSON before validation.\n    // - An array which we will assume is an array of root node definitions with at least one being the primary root node (no 'id' property)\n    // - An object which we will assume is the primary root node and should not have an 'id' property.\n    if (typeof definition === \"string\") {\n        try {\n            // The definition is a string which we can assume is mdsl, so attempt to parse it to a JSON definition in the form of an array of root node definitions.\n            rootNodeDefinitions = convertMDSLToJSON(definition);\n        } catch (error) {\n            // We failed to parse the JSON from the mdsl, this is likely to be the result of it not being a valid mdsl string.\n            return createFailureResult(`invalid mdsl: ${definition}`);\n        }\n    } else if (typeof definition === \"object\") {\n        // The definition will either be an array (of root node definitions) or an object (the single primary root node definition).\n        rootNodeDefinitions = Array.isArray(definition) ? definition : [definition];\n    } else {\n        return createFailureResult(`unexpected definition type of '${typeof definition}'`);\n    }\n\n    // Iterate over our array of root nodes and call validateNode for each, passing an initial depth of 0, wrapped in a try catch to handle validation failures.\n    try {\n        rootNodeDefinitions.forEach((rootNodeDefinition) => validateNode(rootNodeDefinition, 0));\n    } catch (error) {\n        // Handle cases where we have caught a thrown Error and return a failure result with the error message.\n        if (error instanceof Error) {\n            return createFailureResult(error.message);\n        }\n\n        // No idea what happened here!\n        return createFailureResult(`unexpected error: ${error}`);\n    }\n\n    // Unpack all of the root node definitions into arrays of main ('id' defined) and sub ('id' not defined) root node definitions.\n    const mainRootNodeDefinitions = rootNodeDefinitions.filter(({ id }) => typeof id === \"undefined\");\n    const subRootNodeDefinitions = rootNodeDefinitions.filter(({ id }) => typeof id === \"string\" && id.length > 0);\n\n    // We should ALWAYS have exactly one root node definition without an 'id' property defined, which is out main root node definition.\n    if (mainRootNodeDefinitions.length !== 1) {\n        return createFailureResult(\"expected single root node without 'id' property defined to act as main root\");\n    }\n\n    // We should never have duplicate 'id' properties across our sub root node definitions.\n    const subRootNodeIdenitifers: string[] = [];\n    for (const { id } of subRootNodeDefinitions) {\n        // Have we already come across this 'id' property value?\n        if (subRootNodeIdenitifers.includes(id)) {\n            return createFailureResult(`multiple root nodes found with duplicate 'id' property value of '${id}'`);\n        }\n\n        subRootNodeIdenitifers.push(id);\n    }\n\n    // Check for any branch node circular depedencies. This will not include any globally registered subtrees.\n    const circularDependencyPath = findBranchCircularDependencyPath(rootNodeDefinitions);\n\n    // If we found a circular dependency in our root node and branch node definitions then the definition is definitely not valid.\n    if (circularDependencyPath) {\n        return createFailureResult(`circular dependency found in branch node references: ${circularDependencyPath}`);\n    }\n\n    // Our definition was valid!\n    return { succeeded: true };\n}\n\n/**\n * Find the first circular depdendency path present in the array of root node definitions, or null if one doesn't exist.\n * This will not consider branch nodes that reference any globally registered subtrees.\n * @param rootNodeDefinitions The array of root node definitions.\n * @returns The first circular depdendency path present in the array of root node definitions as string, or null if one doesn't exist.\n */\nfunction findBranchCircularDependencyPath(rootNodeDefinitions: RootNodeDefinition[]): string | null {\n    // Create a mapping of root node identifiers to other root nodes that they reference via branch nodes.\n    // Below is an example of a mapping that includes a circular dependency (root => a => b => c => a)\n    // [{ refs: [\"a\", \"b\"] }, { id: \"a\", refs: [\"b\"] }, { id: \"b\", refs: [\"c\"] }, { id: \"c\", refs: [\"a\"] }]\n    const rootNodeMappings: { id: string | undefined; refs: string[] }[] = rootNodeDefinitions.map(\n        (rootNodeDefinition) => ({\n            id: rootNodeDefinition.id,\n            refs: flattenDefinition(rootNodeDefinition)\n                .filter(isBranchNode)\n                .map(({ ref }) => ref)\n        })\n    );\n\n    let badPathFormatted: string | null = null;\n\n    // A recursive function to walk through the mappings, keeping track of which root nodes we have visited in the form of a path of root node identifiers.\n    const followRefs = (mapping: { id: string | undefined; refs: string[] }, path: (string | undefined)[] = []) => {\n        // Have we found a circular dependency?\n        if (path.includes(mapping.id)) {\n            // We found a circular dependency! Get the bad path of root node identifiers.\n            const badPath = [...path, mapping.id];\n\n            // Set the formatted path value. [undefined, \"a\", \"b\", \"c\", \"a\"] would be formatted as \"a -> b -> c -> a\".\n            badPathFormatted = badPath.filter((element) => !!element).join(\" => \");\n\n            // No need to continue, we found a circular dependency.\n            return;\n        }\n\n        for (const ref of mapping.refs) {\n            // Find the mapping for the root node with an identifer matching the current ref.\n            const subMapping = rootNodeMappings.find(({ id }) => id === ref);\n\n            // We may not have a mapping for this ref, which will happen if this ref is for a globally registered subtree.\n            if (subMapping) {\n                followRefs(subMapping, [...path, mapping.id]);\n            }\n        }\n    };\n\n    // Start looking for circular dependencies from the root.\n    followRefs(rootNodeMappings.find((mapping) => typeof mapping.id === \"undefined\")!);\n\n    return badPathFormatted;\n}\n\n/**\n * Validate an object that we expect to be a node definition.\n * @param definition An object that we expect to be a node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateNode(definition: any, depth: number): void {\n    // Every node must be valid object and have a non-empty 'type' string property.\n    if (typeof definition !== \"object\" || typeof definition.type !== \"string\" || definition.type.length === 0) {\n        throw new Error(\n            `node definition is not an object or 'type' property is not a non-empty string at depth '${depth}'`\n        );\n    }\n\n    // How we validate this node definition will depend on its type.\n    switch (definition.type) {\n        case \"action\":\n            validateActionNode(definition, depth);\n            break;\n\n        case \"condition\":\n            validateConditionNode(definition, depth);\n            break;\n\n        case \"wait\":\n            validateWaitNode(definition, depth);\n            break;\n\n        case \"branch\":\n            validateBranchNode(definition, depth);\n            break;\n\n        case \"root\":\n            validateRootNode(definition, depth);\n            break;\n\n        case \"success\":\n            validateSuccessNode(definition, depth);\n            break;\n\n        case \"fail\":\n            validateFailNode(definition, depth);\n            break;\n\n        case \"flip\":\n            validateFlipNode(definition, depth);\n            break;\n\n        case \"repeat\":\n            validateRepeatNode(definition, depth);\n            break;\n\n        case \"retry\":\n            validateRetryNode(definition, depth);\n            break;\n\n        case \"sequence\":\n            validateSequenceNode(definition, depth);\n            break;\n\n        case \"selector\":\n            validateSelectorNode(definition, depth);\n            break;\n\n        case \"parallel\":\n            validateParallelNode(definition, depth);\n            break;\n\n        default:\n            throw new Error(`unexpected node type of '${definition.type}' at depth '${depth}'`);\n    }\n}\n\n/**\n * Validate any attributes for a given node definition.\n * @param definition The node definition.\n * @param depth The depth of the node in the behaviour tree definition.\n */\nfunction validateNodeAttributes(definition: any, depth: number): void {\n    // Validate each of the attribute types for this node.\n    [\"while\", \"until\", \"entry\", \"exit\", \"step\"].forEach((attributeName) => {\n        // Attempt to grab the definition for the current attribute from the node definition.\n        const attributeDefinition = definition[attributeName];\n\n        // All node attributes are optional, so there is nothing to do if the current attribute is not defined.\n        if (typeof attributeDefinition === \"undefined\") {\n            return;\n        }\n\n        // The attribute definition must be an object.\n        if (typeof attributeDefinition !== \"object\") {\n            throw new Error(\n                `expected attribute '${attributeName}' to be an object for '${definition.type}' node at depth '${depth}'`\n            );\n        }\n\n        // The 'call' property must be defined for any attribute definition.\n        if (typeof attributeDefinition.call !== \"string\" || attributeDefinition.call.length === 0) {\n            throw new Error(\n                `expected 'call' property for attribute '${attributeName}' to be a non-empty string for '${definition.type}' node at depth '${depth}'`\n            );\n        }\n\n        // If any node attribute arguments have been defined then they must have been defined in an array.\n        if (typeof attributeDefinition.args !== \"undefined\" && !Array.isArray(attributeDefinition.args)) {\n            throw new Error(\n                `expected 'args' property for attribute '${attributeName}' to be an array for '${definition.type}' node at depth '${depth}'`\n            );\n        }\n    });\n}\n\n/**\n * Validate an object that we expect to be a root node definition.\n * @param definition An object that we expect to be a root node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateRootNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"root\") {\n        throw new Error(\"expected node type of 'root' for root node\");\n    }\n\n    // A root node cannot be the child of another node.\n    if (depth > 0) {\n        throw new Error(\"a root node cannot be the child of another node\");\n    }\n\n    // Check that, if the root node 'id' property is defined, it is a non-empty string.\n    if (typeof definition.id !== \"undefined\" && (typeof definition.id !== \"string\" || definition.id.length === 0)) {\n        throw new Error(\"expected non-empty string for 'id' property if defined for root node\");\n    }\n\n    // A root node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(\"expected property 'child' to be defined for root node\");\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a success node definition.\n * @param definition An object that we expect to be a success node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateSuccessNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"success\") {\n        throw new Error(`expected node type of 'success' for success node at depth '${depth}'`);\n    }\n\n    // A success node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for success node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a fail node definition.\n * @param definition An object that we expect to be a fail node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateFailNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"fail\") {\n        throw new Error(`expected node type of 'fail' for fail node at depth '${depth}'`);\n    }\n\n    // A fail node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for fail node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a flip node definition.\n * @param definition An object that we expect to be a flip node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateFlipNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"flip\") {\n        throw new Error(`expected node type of 'flip' for flip node at depth '${depth}'`);\n    }\n\n    // A flip node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for flip node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a repeat node definition.\n * @param definition An object that we expect to be a repeat node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateRepeatNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"repeat\") {\n        throw new Error(`expected node type of 'repeat' for repeat node at depth '${depth}'`);\n    }\n\n    // A repeat node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for repeat node at depth '${depth}'`);\n    }\n\n    // Check whether an 'iterations' property has been defined, it may not have been if this node is to repeat indefinitely.\n    if (typeof definition.iterations !== \"undefined\") {\n        if (Array.isArray(definition.iterations)) {\n            // Check whether any elements of the array are not integer values.\n            const containsNonInteger = !!definition.iterations.find((value: unknown) => !isInteger(value));\n\n            // If the 'iterations' property is an array then it MUST contain two integer values.\n            if (definition.iterations.length !== 2 || containsNonInteger) {\n                throw new Error(\n                    `expected array containing two integer values for 'iterations' property if defined for repeat node at depth '${depth}'`\n                );\n            }\n        } else if (!isInteger(definition.iterations)) {\n            throw new Error(\n                `expected integer value or array containing two integer values for 'iterations' property if defined for repeat node at depth '${depth}'`\n            );\n        }\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a retry node definition.\n * @param definition An object that we expect to be a retry node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateRetryNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"retry\") {\n        throw new Error(`expected node type of 'retry' for retry node at depth '${depth}'`);\n    }\n\n    // A retry node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for retry node at depth '${depth}'`);\n    }\n\n    // Check whether an 'attempts' property has been defined, it may not have been if this node is to retry indefinitely.\n    if (typeof definition.attempts !== \"undefined\") {\n        if (Array.isArray(definition.attempts)) {\n            // Check whether any elements of the array are not integer values.\n            const containsNonInteger = !!definition.attempts.find((value: unknown) => !isInteger(value));\n\n            // If the 'attempts' property is an array then it MUST contain two integer values.\n            if (definition.attempts.length !== 2 || containsNonInteger) {\n                throw new Error(\n                    `expected array containing two integer values for 'attempts' property if defined for retry node at depth '${depth}'`\n                );\n            }\n        } else if (!isInteger(definition.attempts)) {\n            throw new Error(\n                `expected integer value or array containing two integer values for 'attempts' property if defined for retry node at depth '${depth}'`\n            );\n        }\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a branch node definition.\n * @param definition An object that we expect to be a branch node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateBranchNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"branch\") {\n        throw new Error(`expected node type of 'branch' for branch node at depth '${depth}'`);\n    }\n\n    // Check that the branch node 'ref' property is defined and is a non-empty string.\n    if (typeof definition.ref !== \"string\" || definition.ref.length === 0) {\n        throw new Error(`expected non-empty string for 'ref' property for branch node at depth '${depth}'`);\n    }\n\n    // It is invalid to define guard attributes for a branch node as they should be defined on the referenced root node.\n    [\"while\", \"until\"].forEach((attributeName) => {\n        if (typeof definition[attributeName] !== \"undefined\") {\n            throw new Error(\n                `guards should not be defined for branch nodes but guard '${attributeName}' was defined for branch node at depth '${depth}'`\n            );\n        }\n    });\n\n    // It is invalid to define callback attributes for a branch node as they should be defined on the referenced root node.\n    [\"entry\", \"exit\", \"step\"].forEach((attributeName) => {\n        if (typeof definition[attributeName] !== \"undefined\") {\n            throw new Error(\n                `callbacks should not be defined for branch nodes but callback '${attributeName}' was defined for branch node at depth '${depth}'`\n            );\n        }\n    });\n}\n\n/**\n * Validate an object that we expect to be a action node definition.\n * @param definition An object that we expect to be a action node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateActionNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"action\") {\n        throw new Error(`expected node type of 'action' for action node at depth '${depth}'`);\n    }\n\n    // The 'call' property must be defined for a action node definition.\n    if (typeof definition.call !== \"string\" || definition.call.length === 0) {\n        throw new Error(`expected non-empty string for 'call' property of action node at depth '${depth}'`);\n    }\n\n    // If any action function arguments have been defined then they must have been defined in an array.\n    if (typeof definition.args !== \"undefined\" && !Array.isArray(definition.args)) {\n        throw new Error(`expected array for 'args' property if defined for action node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n}\n\n/**\n * Validate an object that we expect to be a condition node definition.\n * @param definition An object that we expect to be a condition node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateConditionNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"condition\") {\n        throw new Error(`expected node type of 'condition' for condition node at depth '${depth}'`);\n    }\n\n    // The 'call' property must be defined for a condition node definition.\n    if (typeof definition.call !== \"string\" || definition.call.length === 0) {\n        throw new Error(`expected non-empty string for 'call' property of condition node at depth '${depth}'`);\n    }\n\n    // If any condition function arguments have been defined then they must have been defined in an array.\n    if (typeof definition.args !== \"undefined\" && !Array.isArray(definition.args)) {\n        throw new Error(`expected array for 'args' property if defined for condition node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n}\n\n/**\n * Validate an object that we expect to be a wait node definition.\n * @param definition An object that we expect to be a wait node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateWaitNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"wait\") {\n        throw new Error(`expected node type of 'wait' for wait node at depth '${depth}'`);\n    }\n\n    // Check whether a 'duration' property has been defined, it may not have been if this node is to wait indefinitely.\n    if (typeof definition.duration !== \"undefined\") {\n        if (Array.isArray(definition.duration)) {\n            // Check whether any elements of the array are not integer values.\n            const containsNonInteger = !!definition.duration.find((value: unknown) => !isInteger(value));\n\n            // If the 'duration' property is an array then it MUST contain two integer values.\n            if (definition.duration.length !== 2 || containsNonInteger) {\n                throw new Error(\n                    `expected array containing two integer values for 'duration' property if defined for wait node at depth '${depth}'`\n                );\n            }\n        } else if (!isInteger(definition.duration)) {\n            throw new Error(\n                `expected integer value or array containing two integer values for 'duration' property if defined for wait node at depth '${depth}'`\n            );\n        }\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n}\n\n/**\n * Validate an object that we expect to be a sequence node definition.\n * @param definition An object that we expect to be a sequence node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateSequenceNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"sequence\") {\n        throw new Error(`expected node type of 'sequence' for sequence node at depth '${depth}'`);\n    }\n\n    // A sequence node is a composite node, so must have a children nodes array defined.\n    if (!Array.isArray(definition.children) || definition.children.length === 0) {\n        throw new Error(`expected non-empty 'children' array to be defined for sequence node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child nodes of this composite node.\n    definition.children.forEach((child: any) => validateNode(child, depth + 1));\n}\n\n/**\n * Validate an object that we expect to be a selector node definition.\n * @param definition An object that we expect to be a selector node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateSelectorNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"selector\") {\n        throw new Error(`expected node type of 'selector' for selector node at depth '${depth}'`);\n    }\n\n    // A selector node is a composite node, so must have a children nodes array defined.\n    if (!Array.isArray(definition.children) || definition.children.length === 0) {\n        throw new Error(`expected non-empty 'children' array to be defined for selector node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child nodes of this composite node.\n    definition.children.forEach((child: any) => validateNode(child, depth + 1));\n}\n\n/**\n * Validate an object that we expect to be a parallel node definition.\n * @param definition An object that we expect to be a parallel node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateParallelNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"parallel\") {\n        throw new Error(`expected node type of 'parallel' for parallel node at depth '${depth}'`);\n    }\n\n    // A parallel node is a composite node, so must have a children nodes array defined.\n    if (!Array.isArray(definition.children) || definition.children.length === 0) {\n        throw new Error(`expected non-empty 'children' array to be defined for parallel node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child nodes of this composite node.\n    definition.children.forEach((child: any) => validateNode(child, depth + 1));\n}\n", "import Node from \"../../nodes/Node\";\n\n/**\n * An exception thrown when evaluating node guard path conditions and a conditions fails.\n */\nexport default class GuardUnsatisifedException extends Error {\n    /**\n     * @param source The node at which a guard condition failed.\n     */\n    constructor(private source: Node) {\n        super(\"A guard path condition has failed\");\n    }\n\n    /**\n     * Gets whether the specified node is the node at which a guard condition failed.\n     * @param node The node to check against the source node.\n     * @returns Whether the specified node is the node at which a guard condition failed.\n     */\n    isSourceNode = (node: Node) => node === this.source;\n}\n", "import { Agent } from \"../../Agent\";\nimport Guard from \"./Guard\";\nimport Node from \"../../nodes/Node\";\nimport GuardUnsatisifedException from \"./GuardUnsatisifedException\";\n\nexport type GuardPathPart = {\n    node: Node;\n    guards: Guard[];\n};\n\n/**\n * Represents a path of node guards along a root-to-leaf tree path.\n */\nexport default class GuardPath {\n    /**\n     * @param nodes An array of objects defining a node instance -> guard link, ordered by node depth.\n     */\n    constructor(private nodes: GuardPathPart[]) {}\n\n    /**\n     * Evaluate guard conditions for all guards in the tree path, moving outwards from the root.\n     * @param agent The agent, required for guard evaluation.\n     * @returns An evaluation results object.\n     */\n    evaluate = (agent: Agent) => {\n        // We need to evaluate guard conditions for nodes up the tree, moving outwards from the root.\n        for (const details of this.nodes) {\n            // There can be multiple guards per node.\n            for (const guard of details.guards) {\n                // Check whether the guard condition passes, and throw an exception if not.\n                if (!guard.isSatisfied(agent)) {\n                    throw new GuardUnsatisifedException(details.node);\n                }\n            }\n        }\n    };\n}\n", "import { Agent } from \"../Agent\";\nimport Attribute from \"../attributes/Attribute\";\nimport Entry from \"../attributes/callbacks/Entry\";\nimport Exit from \"../attributes/callbacks/Exit\";\nimport Step from \"../attributes/callbacks/Step\";\nimport Guard from \"../attributes/guards/Guard\";\nimport GuardPath from \"../attributes/guards/GuardPath\";\nimport GuardUnsatisifedException from \"../attributes/guards/GuardUnsatisifedException\";\nimport { BehaviourTreeOptions } from \"../BehaviourTreeOptions\";\nimport { AnyArgument } from \"../RootAstNodesBuilder\";\nimport State, { AnyState } from \"../State\";\nimport Leaf from \"./leaf/Leaf\";\n\n/**\n * A base node.\n */\nexport default abstract class Node {\n    /**\n     * The node uid.\n     */\n    private readonly uid: string = createNodeUid();\n    /**\n     * The node state.\n     */\n    private state: AnyState = State.READY;\n    /**\n     * The guard path to evaluate as part of a node update.\n     */\n    private guardPath: GuardPath | undefined;\n\n    /**\n     * @param type The node type.\n     * @param attributes The node attributes.\n     * @param args The node argument definitions.\n     */\n    constructor(private type: string, private attributes: Attribute[], private args: AnyArgument[]) {}\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected abstract onUpdate(agent: Agent, options: BehaviourTreeOptions): void;\n\n    /**\n     * Gets the name of the node.\n     */\n    public abstract getName(): string;\n\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    public abstract isLeafNode: () => this is Leaf;\n\n    /**\n     * Gets/Sets the state of the node.\n     */\n    getState = (): AnyState => this.state;\n    setState = (value: AnyState): void => {\n        this.state = value;\n    };\n\n    /**\n     * Gets the unique id of the node.\n     */\n    getUid = () => this.uid;\n\n    /**\n     * Gets the type of the node.\n     */\n    getType = () => this.type;\n\n    /**\n     * Gets the node attributes.\n     */\n    getAttributes = () => this.attributes;\n\n    /**\n     * Gets the node arguments.\n     */\n    getArguments = () => this.args;\n\n    /**\n     * Gets the node attribute with the specified type, or null if it does not exist.\n     */\n    getAttribute(type: \"entry\" | \"ENTRY\"): Entry;\n    getAttribute(type: \"exit\" | \"EXIT\"): Exit;\n    getAttribute(type: \"step\" | \"STEP\"): Step;\n    getAttribute(type: string): Attribute {\n        return (\n            this.getAttributes().filter((decorator) => decorator.getType().toUpperCase() === type.toUpperCase())[0] ||\n            null\n        );\n    }\n\n    /**\n     * Gets the node attributes.\n     */\n    getGuardAttributes = (): Guard[] => this.getAttributes().filter((decorator) => decorator.isGuard()) as Guard[];\n\n    /**\n     * Sets the guard path to evaluate as part of a node update.\n     */\n    setGuardPath = (value: GuardPath) => (this.guardPath = value);\n\n    /**\n     * Gets whether a guard path is assigned to this node.\n     */\n    hasGuardPath = () => !!this.guardPath;\n\n    /**\n     * Gets whether this node is in the specified state.\n     * @param value The value to compare to the node state.\n     */\n    public is(value: AnyState): boolean {\n        return this.state === value;\n    }\n\n    /**\n     * Reset the state of the node.\n     */\n    public reset(): void {\n        this.setState(State.READY);\n    }\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    public abort(agent: Agent): void {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Reset the state of this node.\n        this.reset();\n\n        this.getAttribute(\"exit\")?.callAgentFunction(agent, false, true);\n    }\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     * @returns The result of the update.\n     */\n    public update(agent: Agent, options: BehaviourTreeOptions): void {\n        // If this node is already in a 'SUCCEEDED' or 'FAILED' state then there is nothing to do.\n        if (this.is(State.SUCCEEDED) || this.is(State.FAILED)) {\n            return;\n        }\n\n        try {\n            // Evaluate all of the guard path conditions for the current tree path.\n            this.guardPath!.evaluate(agent);\n\n            // If this node is in the READY state then call the ENTRY for this node if it exists.\n            if (this.is(State.READY)) {\n                this.getAttribute(\"entry\")?.callAgentFunction(agent);\n            }\n\n            this.getAttribute(\"step\")?.callAgentFunction(agent);\n\n            // Do the actual update.\n            this.onUpdate(agent, options);\n\n            // If this node is now in a 'SUCCEEDED' or 'FAILED' state then call the EXIT for this node if it exists.\n            if (this.is(State.SUCCEEDED) || this.is(State.FAILED)) {\n                this.getAttribute(\"exit\")?.callAgentFunction(agent, this.is(State.SUCCEEDED), false);\n            }\n        } catch (error) {\n            // If the error is a GuardUnsatisfiedException then we need to determine if this node is the source.\n            if (error instanceof GuardUnsatisifedException && error.isSourceNode(this)) {\n                // Abort the current node.\n                this.abort(agent);\n\n                // Any node that is the source of an abort will be a failed node.\n                this.setState(State.FAILED);\n            } else {\n                throw error;\n            }\n        }\n    }\n}\n\n/**\n * Create a randomly generated node uid.\n * @returns A randomly generated node uid.\n */\nfunction createNodeUid(): string {\n    var S4 = function () {\n        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n    };\n    return S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4();\n}\n", "import Node from \"../Node\";\n\n/**\n * A leaf node.\n */\nexport default abstract class Leaf extends Node {\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    isLeafNode = () => true;\n}\n", "import { ActionResult, Agent, ExitFunctionArg, FunctionArg, GlobalFunction } from \"./Agent\";\nimport { AnyArgument, RootAstNode } from \"./RootAstNodesBuilder\";\n\n// Exit callbacks receive their own special type of argument.\n// There's probably stricter ways to represent this but it feels overly complex right now.\ntype ExitResultArg = { value: ExitFunctionArg };\nexport type AnyExitArgument = AnyArgument | ExitResultArg;\n\nexport type InvokerFunction = (args: AnyExitArgument[]) => ActionResult;\n\n/**\n * A singleton used to store and lookup registered functions and subtrees.\n */\nexport default class Lookup {\n    /**\n     * The object holding any registered functions keyed on function name.\n     */\n    private static functionTable: { [key: string]: GlobalFunction } = {};\n    /**\n     * The object holding any registered sub-trees keyed on tree name.\n     */\n    private static subtreeTable: { [key: string]: RootAstNode } = {};\n\n    /**\n     * Gets the function with the specified name.\n     * @param name The name of the function.\n     * @returns The function with the specified name.\n     */\n    public static getFunc(name: string): GlobalFunction {\n        return this.functionTable[name];\n    }\n\n    /**\n     * Sets the function with the specified name for later lookup.\n     * @param name The name of the function.\n     * @param func The function.\n     */\n    public static setFunc(name: string, func: GlobalFunction): void {\n        this.functionTable[name] = func;\n    }\n\n    /**\n     * Gets the function invoker for the specified agent and function name.\n     * If a function with the specified name exists on the agent object then it will\n     * be returned, otherwise we will then check the registered functions for a match.\n     * @param agent The agent instance that this behaviour tree is modelling behaviour for.\n     * @param name The function name.\n     * @returns The function invoker for the specified agent and function name.\n     */\n    static getFuncInvoker(agent: Agent, name: string): InvokerFunction | null {\n        // Check whether the agent contains the specified function.\n        const foundOnAgent = agent[name];\n        if (foundOnAgent && typeof foundOnAgent === \"function\") {\n            return (args: AnyExitArgument[]): boolean | ActionResult =>\n                foundOnAgent.apply(\n                    agent,\n                    args.map((arg) => arg.value)\n                );\n        }\n\n        // The agent does not contain the specified function but it may have been registered at some point.\n        if (this.functionTable[name] && typeof this.functionTable[name] === \"function\") {\n            return (args: AnyExitArgument[]) => this.functionTable[name](agent, ...args.map((arg) => arg.value));\n        }\n\n        // We have no function to invoke.\n        return null;\n    }\n\n    /**\n     * Gets the subtree with the specified name.\n     * @param name The name of the subtree.\n     * @returns The subtree with the specified name.\n     */\n    static getSubtree(name: string): RootAstNode {\n        return this.subtreeTable[name];\n    }\n\n    /**\n     * Sets the subtree with the specified name for later lookup.\n     * @param name The name of the subtree.\n     * @param subtree The subtree.\n     */\n    static setSubtree(name: string, subtree: RootAstNode) {\n        this.subtreeTable[name] = subtree;\n    }\n\n    /**\n     * Removes the registered function or subtree with the specified name.\n     * @param name The name of the registered function or subtree.\n     */\n    static remove(name: string) {\n        delete this.functionTable[name];\n        delete this.subtreeTable[name];\n    }\n\n    /**\n     * Remove all registered functions and subtrees.\n     */\n    static empty() {\n        this.functionTable = {};\n        this.subtreeTable = {};\n    }\n}\n", "import Leaf from \"./Leaf\";\nimport State, { CompleteState } from \"../../State\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { AnyArgument } from \"../../RootAstNodesBuilder\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * An Action leaf node.\n * This represents an immediate or ongoing state of behaviour.\n */\nexport default class Action extends Leaf {\n    /**\n     * @param attributes The node attributes.\n     * @param actionName The action name.\n     * @param actionArguments The array of action argument definitions.\n     */\n    constructor(attributes: Attribute[], private actionName: string, private actionArguments: AnyArgument[]) {\n        super(\"action\", attributes, actionArguments);\n    }\n\n    /**\n     * Whether there is a pending update promise.\n     */\n    private isUsingUpdatePromise = false;\n\n    /**\n     * The finished state result of an update promise.\n     */\n    private updatePromiseStateResult: CompleteState | null = null;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // If the result of this action depends on an update promise then there is nothing to do until\n        // it resolves, unless there has been a value set as a result of the update promise resolving.\n        if (this.isUsingUpdatePromise) {\n            // Check whether the update promise has resolved with a state value.\n            if (this.updatePromiseStateResult) {\n                // Set the state of this node to match the state returned by the promise.\n                this.setState(this.updatePromiseStateResult);\n            }\n\n            return;\n        }\n\n        // Attempt to get the invoker for the action function.\n        const actionFuncInvoker = Lookup.getFuncInvoker(agent, this.actionName);\n\n        // The action function should be defined.\n        if (actionFuncInvoker === null) {\n            throw new Error(\n                `cannot update action node as the action '${this.actionName}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the action function, the result of which may be:\n        // - The finished state of this action node.\n        // - A promise to return a finished node state.\n        // - Undefined if the node should remain in the running state.\n        const updateResult = actionFuncInvoker(this.actionArguments) as CompleteState | Promise<CompleteState>;\n\n        if (updateResult instanceof Promise) {\n            updateResult.then(\n                (result) => {\n                    // If 'isUpdatePromisePending' is null then the promise was cleared as it was resolving, probably via an abort of reset.\n                    if (!this.isUsingUpdatePromise) {\n                        return;\n                    }\n\n                    // Check to make sure the result is a valid finished state.\n                    if (result !== State.SUCCEEDED && result !== State.FAILED) {\n                        throw new Error(\n                            \"action node promise resolved with an invalid value, expected a State.SUCCEEDED or State.FAILED value to be returned\"\n                        );\n                    }\n\n                    // Set pending update promise state result to be processed on next update.\n                    this.updatePromiseStateResult = result;\n                },\n                (reason) => {\n                    // If 'isUpdatePromisePending' is null then the promise was cleared as it was resolving, probably via an abort of reset.\n                    if (!this.isUsingUpdatePromise) {\n                        return;\n                    }\n\n                    // Just throw whatever was returned as the rejection argument.\n                    throw new Error(reason);\n                }\n            );\n\n            // This node will be in the 'RUNNING' state until the update promise resolves.\n            this.setState(State.RUNNING);\n\n            // We are now waiting for the promise returned by the use to resolve before we know what state this node is in.\n            this.isUsingUpdatePromise = true;\n        } else {\n            // Validate the returned value.\n            this.validateUpdateResult(updateResult);\n\n            // Set the state of this node, this may be undefined, which just means that the node is still in the 'RUNNING' state.\n            this.setState(updateResult || State.RUNNING);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => this.actionName;\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // There is no longer an update promise that we care about.\n        this.isUsingUpdatePromise = false;\n        this.updatePromiseStateResult = null;\n    };\n\n    /**\n     * Validate the result of an update function call.\n     * @param result The result of an update function call.\n     */\n    private validateUpdateResult = (result: CompleteState | boolean) => {\n        switch (result) {\n            case State.SUCCEEDED:\n            case State.FAILED:\n            case undefined:\n                return;\n            default:\n                throw new Error(\n                    `action '${this.actionName}' 'onUpdate' returned an invalid response, expected an optional State.SUCCEEDED or State.FAILED value to be returned`\n                );\n        }\n    };\n}\n", "import Leaf from \"./Leaf\";\nimport State from \"../../State\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { AnyArgument } from \"../../RootAstNodesBuilder\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A Condition leaf node.\n * This will succeed or fail immediately based on an agent predicate, without moving to the 'RUNNING' state.\n */\nexport default class Condition extends Leaf {\n    /**\n     * @param attributes The node attributes.\n     * @param conditionName The name of the condition function.\n     * @param conditionArguments The array of condition argument definitions.\n     */\n    constructor(attributes: Attribute[], private conditionName: string, private conditionArguments: AnyArgument[]) {\n        super(\"condition\", attributes, conditionArguments);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // Attempt to get the invoker for the condition function.\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.conditionName);\n\n        // The condition function should be defined.\n        if (conditionFuncInvoker === null) {\n            throw new Error(\n                `cannot update condition node as the condition '${this.conditionName}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the condition function to determine the state of this node.\n        this.setState(!!conditionFuncInvoker(this.conditionArguments) ? State.SUCCEEDED : State.FAILED);\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => this.conditionName;\n}\n", "import Leaf from \"./Leaf\";\nimport State from \"../../State\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { Agent } from \"../../Agent\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A WAIT node.\n * The state of this node will change to SUCCEEDED after a duration of time\n */\nexport default class Wait extends Leaf {\n    /**\n     * @param attributes The node attributes.\n     * @param duration The duration that this node will wait to succeed in milliseconds.\n     * @param durationMin The minimum possible duration in milliseconds that this node will wait to succeed.\n     * @param durationMax The maximum possible duration in milliseconds that this node will wait to succeed.\n     */\n    constructor(\n        attributes: Attribute[],\n        private duration: number | null,\n        private durationMin: number | null,\n        private durationMax: number | null\n    ) {\n        super(\"wait\", attributes, []);\n    }\n\n    /**\n     * The time in milliseconds at which this node was first updated.\n     */\n    private initialUpdateTime: number = 0;\n\n    /**\n     * The total duration in milliseconds that this node will be waiting for.\n     */\n    private totalDuration: number | null = null;\n\n    /**\n     * The duration in milliseconds that this node has been waiting for.\n     */\n    private waitedDuration: number = 0;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // If this node is in the READY state then we need to set the initial update time.\n        if (this.is(State.READY)) {\n            // Set the initial update time.\n            this.initialUpdateTime = new Date().getTime();\n\n            // Set the initial waited duration.\n            this.waitedDuration = 0;\n\n            // Are we dealing with an explicit duration or will we be randomly picking a duration between the min and max duration.\n            if (this.duration !== null) {\n                this.totalDuration = this.duration;\n            } else if (this.durationMin !== null && this.durationMax !== null) {\n                // We will be picking a random duration between a min and max duration, if the optional 'random' behaviour tree\n                // function option is defined then we will be using that, otherwise we will fall back to using Math.random.\n                const random = typeof options.random === \"function\" ? options.random : Math.random;\n\n                // Pick a random duration between a min and max duration.\n                this.totalDuration = Math.floor(\n                    random() * (this.durationMax - this.durationMin + 1) + this.durationMin\n                );\n            } else {\n                this.totalDuration = null;\n            }\n\n            // The node is now running until we finish waiting.\n            this.setState(State.RUNNING);\n        }\n\n        // If we have no total duration then this wait node will wait indefinitely until it is aborted.\n        if (this.totalDuration === null) {\n            return;\n        }\n\n        // If we have a 'getDeltaTime' function defined as part of our options then we will use it to figure out how long we have waited for.\n        if (typeof options.getDeltaTime === \"function\") {\n            // Get the delta time.\n            const deltaTime = options.getDeltaTime();\n\n            // Our delta time must be a valid number and cannot be NaN.\n            if (typeof deltaTime !== \"number\" || isNaN(deltaTime)) {\n                throw new Error(\"The delta time must be a valid number and not NaN.\");\n            }\n\n            // Update the amount of time that this node has been waiting for based on the delta time.\n            this.waitedDuration += deltaTime * 1000;\n        } else {\n            // We are not using a delta time, so we will just work out hom much time has passed since the first update.\n            this.waitedDuration = new Date().getTime() - this.initialUpdateTime;\n        }\n\n        // Have we waited long enough?\n        if (this.waitedDuration >= this.totalDuration) {\n            // We have finished waiting!\n            this.setState(State.SUCCEEDED);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => {\n        if (this.duration !== null) {\n            return `WAIT ${this.duration}ms`;\n        } else if (this.durationMin !== null && this.durationMax !== null) {\n            return `WAIT ${this.durationMin}ms-${this.durationMax}ms`;\n        } else {\n            return \"WAIT\";\n        }\n    };\n}\n", "import Node from \"../Node\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\n\n/**\n * A decorator node that wraps a single child node.\n */\nexport default abstract class Decorator extends Node {\n    /**\n     * @param type The node type.\n     * @param attributes The node attributes.\n     * @param child The child node.\n     */\n    constructor(type: string, attributes: Attribute[], protected child: Node) {\n        super(type, attributes, []);\n    }\n\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    isLeafNode = () => false;\n\n    /**\n     * Gets the children of this node.\n     */\n    getChildren = () => [this.child];\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the state of the child node.\n        this.child.reset();\n    };\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    abort = (agent: Agent) => {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Abort the child node.\n        this.child.abort(agent);\n\n        // Reset the state of this node.\n        this.reset();\n\n        this.getAttribute(\"exit\")?.callAgentFunction(agent, false, true);\n    };\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A Root node.\n * The root node will have a single child.\n */\nexport default class Root extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param child The child node.\n     */\n    constructor(attributes: Attribute[], child: Node) {\n        super(\"root\", attributes, child);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            // Update the child of this node.\n            this.child.update(agent, options);\n        }\n\n        // The state of the root node is the state of its child.\n        this.setState(this.child.getState());\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"ROOT\";\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A REPEAT node.\n * The node has a single child which can have:\n * -- A number of iterations for which to repeat the child node.\n * -- An infinite repeat loop if neither an iteration count or a condition function is defined.\n * The REPEAT node will stop and have a 'FAILED' state if its child is ever in a 'FAILED' state after an update.\n * The REPEAT node will attempt to move on to the next iteration if its child is ever in a 'SUCCEEDED' state.\n */\nexport default class Repeat extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param iterations The number of iterations to repeat the child node.\n     * @param iterationsMin The minimum possible number of iterations to repeat the child node.\n     * @param iterationsMax The maximum possible number of iterations to repeat the child node.\n     * @param child The child node.\n     */\n    constructor(\n        attributes: Attribute[],\n        private iterations: number | null,\n        private iterationsMin: number | null,\n        private iterationsMax: number | null,\n        child: Node\n    ) {\n        super(\"repeat\", attributes, child);\n    }\n\n    /**\n     * The number of target iterations to make.\n     */\n    private targetIterationCount: number | null = null;\n\n    /**\n     * The current iteration count.\n     */\n    private currentIterationCount: number = 0;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // If this node is in the READY state then we need to reset the child and the target iteration count.\n        if (this.is(State.READY)) {\n            // Reset the child node.\n            this.child.reset();\n\n            // Reset the current iteration count.\n            this.currentIterationCount = 0;\n\n            // Set the target iteration count.\n            this.setTargetIterationCount(options);\n        }\n\n        // Do a check to see if we can iterate. If we can then this node will move into the 'RUNNING' state.\n        // If we cannot iterate then we have hit our target iteration count, which means that the node has succeeded.\n        if (this.canIterate()) {\n            // This node is in the running state and can do its initial iteration.\n            this.setState(State.RUNNING);\n\n            // We may have already completed an iteration, meaning that the child node will be in the SUCCEEDED state.\n            // If this is the case then we will have to reset the child node now.\n            if (this.child.getState() === State.SUCCEEDED) {\n                this.child.reset();\n            }\n\n            // Update the child of this node.\n            this.child.update(agent, options);\n\n            // If the child moved into the FAILED state when we updated it then there is nothing left to do and this node has also failed.\n            // If it has moved into the SUCCEEDED state then we have completed the current iteration.\n            if (this.child.getState() === State.FAILED) {\n                // The child has failed, meaning that this node has failed.\n                this.setState(State.FAILED);\n\n                return;\n            } else if (this.child.getState() === State.SUCCEEDED) {\n                // We have completed an iteration.\n                this.currentIterationCount += 1;\n            }\n        } else {\n            // This node is in the 'SUCCEEDED' state as we cannot iterate any more.\n            this.setState(State.SUCCEEDED);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => {\n        if (this.iterations !== null) {\n            return `REPEAT ${this.iterations}x`;\n        } else if (this.iterationsMin !== null && this.iterationsMax !== null) {\n            return `REPEAT ${this.iterationsMin}x-${this.iterationsMax}x`;\n        } else {\n            return \"REPEAT\";\n        }\n    };\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the current iteration count.\n        this.currentIterationCount = 0;\n\n        // Reset the child node.\n        this.child.reset();\n    };\n\n    /**\n     * Gets whether an iteration can be made.\n     * @returns Whether an iteration can be made.\n     */\n    private canIterate = () => {\n        if (this.targetIterationCount !== null) {\n            // We can iterate as long as we have not reached our target iteration count.\n            return this.currentIterationCount < this.targetIterationCount;\n        }\n\n        // If neither an iteration count or a condition function were defined then we can iterate indefinitely.\n        return true;\n    };\n\n    /**\n     * Sets the target iteration count.\n     * @param options The behaviour tree options object.\n     */\n    private setTargetIterationCount = (options: BehaviourTreeOptions) => {\n        // Are we dealing with an explicit iteration count or will we be randomly picking a iteration count between the min and max iteration count.\n        if (this.iterations !== null) {\n            this.targetIterationCount = this.iterations;\n        } else if (this.iterationsMin !== null && this.iterationsMax !== null) {\n            // We will be picking a random iteration count between a min and max iteration count, if the optional 'random'\n            // behaviour tree function option is defined then we will be using that, otherwise we will fall back to using Math.random.\n            const random = typeof options.random === \"function\" ? options.random : Math.random;\n\n            // Pick a random iteration count between a min and max iteration count.\n            this.targetIterationCount = Math.floor(\n                random() * (this.iterationsMax - this.iterationsMin + 1) + this.iterationsMin\n            );\n        } else {\n            this.targetIterationCount = null;\n        }\n    };\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A RETRY node.\n * The node has a single child which can have:\n * -- A number of iterations for which to repeat the child node.\n * -- An infinite repeat loop if neither an iteration count or a condition function is defined.\n * The RETRY node will stop and have a 'SUCCEEDED' state if its child is ever in a 'SUCCEEDED' state after an update.\n * The RETRY node will attempt to move on to the next iteration if its child is ever in a 'FAILED' state.\n */\nexport default class Retry extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param attempts The number of attempts to retry the child node.\n     * @param attemptsMin The minimum possible number of attempts to retry the child node.\n     * @param attemptsMax The maximum possible number of attempts to retry the child node.\n     * @param child The child node.\n     */\n    constructor(\n        attributes: Attribute[],\n        private attempts: number | null,\n        private attemptsMin: number | null,\n        private attemptsMax: number | null,\n        child: Node\n    ) {\n        super(\"retry\", attributes, child);\n    }\n\n    /**\n     * The number of target attempts to make.\n     */\n    private targetAttemptCount: number | null = null;\n\n    /**\n     * The current attempt count.\n     */\n    private currentAttemptCount: number = 0;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // If this node is in the READY state then we need to reset the child and the target attempt count.\n        if (this.is(State.READY)) {\n            // Reset the child node.\n            this.child.reset();\n\n            // Reset the current attempt count.\n            this.currentAttemptCount = 0;\n\n            // Set the target attempt count.\n            this.setTargetAttemptCount(options);\n        }\n\n        // Do a check to see if we can attempt. If we can then this node will move into the 'RUNNING' state.\n        // If we cannot attempt then we have hit our target attempt count, which means that the node has succeeded.\n        if (this.canAttempt()) {\n            // This node is in the running state and can do its initial attempt.\n            this.setState(State.RUNNING);\n\n            // We may have already completed an attempt, meaning that the child node will be in the FAILED state.\n            // If this is the case then we will have to reset the child node now.\n            if (this.child.getState() === State.FAILED) {\n                this.child.reset();\n            }\n\n            // Update the child of this node.\n            this.child.update(agent, options);\n\n            // If the child moved into the SUCCEEDED state when we updated it then there is nothing left to do and this node has also succeeded.\n            // If it has moved into the FAILED state then we have completed the current attempt.\n            if (this.child.getState() === State.SUCCEEDED) {\n                // The child has succeeded, meaning that this node has succeeded.\n                this.setState(State.SUCCEEDED);\n\n                return;\n            } else if (this.child.getState() === State.FAILED) {\n                // We have completed an attempt.\n                this.currentAttemptCount += 1;\n            }\n        } else {\n            // This node is in the 'FAILED' state as we cannot iterate any more.\n            this.setState(State.FAILED);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => {\n        if (this.attempts !== null) {\n            return `RETRY ${this.attempts}x`;\n        } else if (this.attemptsMin !== null && this.attemptsMax !== null) {\n            return `RETRY ${this.attemptsMin}x-${this.attemptsMax}x`;\n        } else {\n            return \"RETRY\";\n        }\n    };\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the current attempt count.\n        this.currentAttemptCount = 0;\n\n        // Reset the child node.\n        this.child.reset();\n    };\n\n    /**\n     * Gets whether an attempt can be made.\n     * @returns Whether an attempt can be made.\n     */\n    canAttempt = () => {\n        if (this.targetAttemptCount !== null) {\n            // We can attempt as long as we have not reached our target attempt count.\n            return this.currentAttemptCount < this.targetAttemptCount;\n        }\n\n        // If neither an attempt count or a condition function were defined then we can attempt indefinitely.\n        return true;\n    };\n\n    /**\n     * Sets the target attempt count.\n     * @param options The behaviour tree options object.\n     */\n    setTargetAttemptCount = (options: BehaviourTreeOptions) => {\n        // Are we dealing with an explicit attempt count or will we be randomly picking an attempt count between the min and max attempt count.\n        if (this.attempts !== null) {\n            this.targetAttemptCount = this.attempts;\n        } else if (this.attemptsMin !== null && this.attemptsMax !== null) {\n            // We will be picking a random attempt count between a min and max attempt count, if the optional 'random'\n            // behaviour tree function option is defined then we will be using that, otherwise we will fall back to using Math.random.\n            const random = typeof options.random === \"function\" ? options.random : Math.random;\n\n            // Pick a random attempt count between a min and max attempt count.\n            this.targetAttemptCount = Math.floor(\n                random() * (this.attemptsMax - this.attemptsMin + 1) + this.attemptsMin\n            );\n        } else {\n            this.targetAttemptCount = null;\n        }\n    };\n}\n", "import Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport Node from \"../Node\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A Flip node.\n * This node wraps a single child and will flip the state of the child state.\n */\nexport default class Flip extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param child The child node.\n     */\n    constructor(attributes: Attribute[], child: Node) {\n        super(\"flip\", attributes, child);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            this.child.update(agent, options);\n        }\n\n        // The state of this node will depend in the state of its child.\n        switch (this.child.getState()) {\n            case State.RUNNING:\n                this.setState(State.RUNNING);\n                break;\n\n            case State.SUCCEEDED:\n                this.setState(State.FAILED);\n                break;\n\n            case State.FAILED:\n                this.setState(State.SUCCEEDED);\n                break;\n\n            default:\n                this.setState(State.READY);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"FLIP\";\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A Succeed node.\n * This node wraps a single child and will always move to the 'SUCCEEDED' state when the child moves to a 'SUCCEEDED' or 'FAILED' state.\n */\nexport default class Succeed extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param child The child node.\n     */\n    constructor(attributes: Attribute[], child: Node) {\n        super(\"succeed\", attributes, child);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            this.child.update(agent, options);\n        }\n\n        // The state of this node will depend in the state of its child.\n        switch (this.child.getState()) {\n            case State.RUNNING:\n                this.setState(State.RUNNING);\n                break;\n\n            case State.SUCCEEDED:\n            case State.FAILED:\n                this.setState(State.SUCCEEDED);\n                break;\n\n            default:\n                this.setState(State.READY);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"SUCCEED\";\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A Fail node.\n * This node wraps a single child and will always move to the 'FAILED' state when the child moves to a 'SUCCEEDED' or 'FAILED' state.\n */\nexport default class Fail extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param child The child node.\n     */\n    constructor(attributes: Attribute[], child: Node) {\n        super(\"fail\", attributes, child);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            this.child.update(agent, options);\n        }\n\n        // The state of this node will depend in the state of its child.\n        switch (this.child.getState()) {\n            case State.RUNNING:\n                this.setState(State.RUNNING);\n                break;\n\n            case State.SUCCEEDED:\n            case State.FAILED:\n                this.setState(State.FAILED);\n                break;\n\n            default:\n                this.setState(State.READY);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"FAIL\";\n}\n", "import createLotto from \"lotto-draw\";\n\nimport Node from \"../Node\";\nimport Composite from \"./Composite\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A LOTTO node.\n * A winning child is picked on the initial update of this node, based on ticket weighting.\n * The state of this node will match the state of the winning child.\n */\nexport default class Lotto extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param tickets The child node tickets.\n     * @param children The child nodes.\n     */\n    constructor(attributes: Attribute[], private tickets: number[], children: Node[]) {\n        super(\"lotto\", attributes, children);\n    }\n\n    /**\n     * The child node selected to be the active one.\n     */\n    private selectedChild: Node | undefined;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // If this node is in the READY state then we need to pick a winning child node.\n        if (this.is(State.READY)) {\n            // Create a lotto draw with which to randomly pick a child node to become the active one.\n            const lottoDraw = createLotto<Node>({\n                // Hook up the optional 'random' behaviour tree function option to the one used by 'lotto-draw'.\n                random: options.random,\n                // Pass in each child node as a participant in the lotto draw with their respective ticket count.\n                participants: this.children.map((child, index) => [child, this.tickets[index] || 1])\n            });\n\n            // Randomly pick a child based on ticket weighting, this will become the active child for this composite node.\n            this.selectedChild = lottoDraw.draw() || undefined;\n        }\n\n        // If something went wrong and we don't have an active child then we should throw an error.\n        if (!this.selectedChild) {\n            throw new Error(\"failed to update lotto node as it has no active child\");\n        }\n\n        // If the selected child has never been updated or is running then we will need to update it now.\n        if (this.selectedChild.getState() === State.READY || this.selectedChild.getState() === State.RUNNING) {\n            this.selectedChild.update(agent, options);\n        }\n\n        // The state of the lotto node is the state of its selected child.\n        this.setState(this.selectedChild.getState());\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => (this.tickets.length ? `LOTTO [${this.tickets.join(\",\")}]` : \"LOTTO\");\n}\n", "import Node from \"../Node\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\n\n/**\n * A composite node that wraps child nodes.\n */\nexport default abstract class Composite extends Node {\n    /**\n     * @param type The node type.\n     * @param attributes The node attributes.\n     * @param children The child nodes.\n     */\n    constructor(type: string, attributes: Attribute[], protected children: Node[]) {\n        super(type, attributes, []);\n    }\n\n    /**\n     * Gets whether this node is a leaf node.\n     */\n    isLeafNode = () => false;\n\n    /**\n     * Gets the children of this node.\n     */\n    getChildren = () => this.children;\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the state of any child nodes.\n        this.getChildren().forEach((child) => child.reset());\n    };\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    abort = (agent: Agent) => {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Abort any child nodes.\n        this.getChildren().forEach((child) => child.abort(agent));\n\n        // Reset the state of this node.\n        this.reset();\n\n        this.getAttribute(\"exit\")?.callAgentFunction(agent, false, true);\n    };\n}\n", "import Composite from \"./Composite\";\nimport Node from \"../Node\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A SELECTOR node.\n * The child nodes are executed in sequence until one succeeds or all fail.\n */\nexport default class Selector extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param children The child nodes.\n     */\n    constructor(attributes: Attribute[], protected children: Node[]) {\n        super(\"selector\", attributes, children);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // Iterate over all of the children of this node.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent, options);\n            }\n\n            // If the current child has a state of 'SUCCEEDED' then this node is also a 'SUCCEEDED' node.\n            if (child.getState() === State.SUCCEEDED) {\n                // This node is a 'SUCCEEDED' node.\n                this.setState(State.SUCCEEDED);\n\n                // There is no need to check the rest of the selector nodes.\n                return;\n            }\n\n            // If the current child has a state of 'FAILED' then we should move on to the next child.\n            if (child.getState() === State.FAILED) {\n                // Find out if the current child is the last one in the selector.\n                // If it is then this sequence node has also failed.\n                if (this.children.indexOf(child) === this.children.length - 1) {\n                    // This node is a 'FAILED' node.\n                    this.setState(State.FAILED);\n\n                    // There is no need to check the rest of the selector as we have completed it.\n                    return;\n                } else {\n                    // The child node failed, try the next one.\n                    continue;\n                }\n            }\n\n            // The node should be in the 'RUNNING' state.\n            if (child.getState() === State.RUNNING) {\n                // This node is a 'RUNNING' node.\n                this.setState(State.RUNNING);\n\n                // There is no need to check the rest of the selector as the current child is still running.\n                return;\n            }\n\n            // The child node was not in an expected state.\n            throw new Error(\"child node was not in an expected state.\");\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"SELECTOR\";\n}\n", "import Composite from \"./Composite\";\nimport Node from \"../Node\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A SEQUENCE node.\n * The child nodes are executed in sequence until one fails or all succeed.\n */\nexport default class Sequence extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param children The child nodes.\n     */\n    constructor(attributes: Attribute[], protected children: Node[]) {\n        super(\"sequence\", attributes, children);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // Iterate over all of the children of this node.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent, options);\n            }\n\n            // If the current child has a state of 'SUCCEEDED' then we should move on to the next child.\n            if (child.getState() === State.SUCCEEDED) {\n                // Find out if the current child is the last one in the sequence.\n                // If it is then this sequence node has also succeeded.\n                if (this.children.indexOf(child) === this.children.length - 1) {\n                    // This node is a 'SUCCEEDED' node.\n                    this.setState(State.SUCCEEDED);\n\n                    // There is no need to check the rest of the sequence as we have completed it.\n                    return;\n                } else {\n                    // The child node succeeded, but we have not finished the sequence yet.\n                    continue;\n                }\n            }\n\n            // If the current child has a state of 'FAILED' then this node is also a 'FAILED' node.\n            if (child.getState() === State.FAILED) {\n                // This node is a 'FAILED' node.\n                this.setState(State.FAILED);\n\n                // There is no need to check the rest of the sequence.\n                return;\n            }\n\n            // The node should be in the 'RUNNING' state.\n            if (child.getState() === State.RUNNING) {\n                // This node is a 'RUNNING' node.\n                this.setState(State.RUNNING);\n\n                // There is no need to check the rest of the sequence as the current child is still running.\n                return;\n            }\n\n            // The child node was not in an expected state.\n            throw new Error(\"child node was not in an expected state.\");\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"SEQUENCE\";\n}\n", "import Composite from \"./Composite\";\nimport State from \"../../State\";\nimport Node from \"../Node\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A PARALLEL node.\n * The child nodes are executed concurrently until one fails or all succeed.\n */\nexport default class Parallel extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param children The child nodes.\n     */\n    constructor(attributes: Attribute[], children: Node[]) {\n        super(\"parallel\", attributes, children);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     * @param options The behaviour tree options object.\n     */\n    protected onUpdate(agent: Agent, options: BehaviourTreeOptions): void {\n        // Keep a count of the number of succeeded child nodes.\n        let succeededCount = 0;\n\n        let hasChildFailed = false;\n\n        // Iterate over all of the children of this node.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent, options);\n            }\n\n            // If the current child has a state of 'SUCCEEDED' then we should move on to the next child.\n            if (child.getState() === State.SUCCEEDED) {\n                // The child node has succeeded, keep track of this to determine if all children have.\n                succeededCount++;\n\n                // The child node succeeded, but we have not finished checking every child node yet.\n                continue;\n            }\n\n            // If the current child has a state of 'FAILED' then this node is also a 'FAILED' node.\n            if (child.getState() === State.FAILED) {\n                hasChildFailed = true;\n\n                // There is no need to check the rest of the children.\n                break;\n            }\n\n            // The node should be in the 'RUNNING' state.\n            if (child.getState() !== State.RUNNING) {\n                // The child node was not in an expected state.\n                throw new Error(\"child node was not in an expected state.\");\n            }\n        }\n\n        if (hasChildFailed) {\n            // This node is a 'FAILED' node.\n            this.setState(State.FAILED);\n\n            // Abort every running child.\n            for (const child of this.children) {\n                if (child.getState() === State.RUNNING) {\n                    child.abort(agent);\n                }\n            }\n        } else {\n            // If all children have succeeded then this node has also succeeded, otherwise it is still running.\n            this.setState(succeededCount === this.children.length ? State.SUCCEEDED : State.RUNNING);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"PARALLEL\";\n}\n", "import { AnyArgument } from \"../RootAstNodesBuilder\";\nimport Guard from \"./guards/Guard\";\n\nexport type AttributeDetails = {\n    /** The attribute type. */\n    type: string;\n\n    /** The attribute arguments. */\n    args: AnyArgument[];\n};\n\n/**\n * A base node attribute.\n */\nexport default abstract class Attribute<TAttributeDetails extends AttributeDetails = AttributeDetails> {\n    /**\n     * @param type The node attribute type.\n     * @param args The array of attribute argument definitions.\n     */\n    constructor(protected type: string, protected args: AnyArgument[]) {}\n\n    /**\n     * Gets the type of the attribute.\n     */\n    getType = () => this.type;\n\n    /**\n     * Gets the array of attribute argument definitions.\n     */\n    getArguments = () => this.args;\n\n    /**\n     * Gets the attribute details.\n     */\n    abstract getDetails(): TAttributeDetails;\n\n    /**\n     * Gets whether this attribute is a guard.\n     */\n    abstract isGuard: () => this is Guard;\n}\n", "import { Agent } from \"../../Agent\";\nimport { AnyArgument } from \"../../RootAstNodesBuilder\";\nimport Attribute, { AttributeDetails } from \"../Attribute\";\n\nexport type GuardAttributeDetails = {\n    /** The name of the condition function that determines whether the guard is satisfied. */\n    condition: string;\n} & AttributeDetails;\n\n/**\n * A base node guard attribute.\n */\nexport default abstract class Guard extends Attribute<GuardAttributeDetails> {\n    /**\n     * @param type The node attribute type.\n     * @param args The array of decorator argument definitions.\n     * @param condition The name of the condition function that determines whether the guard is satisfied.\n     */\n    constructor(type: string, args: AnyArgument[], private condition: string) {\n        super(type, args);\n    }\n\n    /**\n     * Gets the name of the condition function that determines whether the guard is satisfied.\n     */\n    getCondition = () => this.condition;\n\n    /**\n     * Gets whether this attribute is a guard.\n     */\n    isGuard = () => true;\n\n    /**\n     * Gets the attribute details.\n     */\n    getDetails(): GuardAttributeDetails {\n        return {\n            type: this.getType(),\n            args: this.getArguments(),\n            condition: this.getCondition()\n        };\n    }\n\n    /**\n     * Gets whether the guard is satisfied.\n     * @param agent The agent.\n     * @returns Whether the guard is satisfied.\n     */\n    abstract isSatisfied(agent: Agent): boolean;\n}\n", "import Guard from \"./Guard\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\nimport { AnyArgument } from \"../../RootAstNodesBuilder\";\n\n/**\n * A WHILE guard which is satisfied as long as the given condition remains true.\n */\nexport default class While extends Guard {\n    /**\n     * @param condition The name of the condition function that determines whether the guard is satisfied.\n     * @param args The array of decorator argument definitions.\n     */\n    constructor(condition: string, args: AnyArgument[]) {\n        super(\"while\", args, condition);\n    }\n\n    /**\n     * Gets whether the guard is satisfied.\n     * @param agent The agent.\n     * @returns Whether the guard is satisfied.\n     */\n    isSatisfied = (agent: Agent) => {\n        // Attempt to get the invoker for the condition function.\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.getCondition());\n\n        // The condition function should be defined.\n        if (conditionFuncInvoker === null) {\n            throw new Error(\n                `cannot evaluate node guard as the condition '${this.getCondition()}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the condition function to determine whether this guard is satisfied.\n        return !!conditionFuncInvoker(this.args);\n    };\n}\n", "import Guard from \"./Guard\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\nimport { AnyArgument } from \"../../RootAstNodesBuilder\";\n\n/**\n * An UNTIL guard which is satisfied as long as the given condition remains false.\n */\nexport default class Until extends Guard {\n    /**\n     * @param condition The name of the condition function that determines whether the guard is satisfied.\n     * @param args The array of decorator argument definitions.\n     */\n    constructor(condition: string, args: AnyArgument[]) {\n        super(\"until\", args, condition);\n    }\n\n    /**\n     * Gets whether the guard is satisfied.\n     * @param agent The agent.\n     * @returns Whether the guard is satisfied.\n     */\n    isSatisfied = (agent: Agent) => {\n        // Attempt to get the invoker for the condition function.\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.getCondition());\n\n        // The condition function should be defined.\n        if (conditionFuncInvoker === null) {\n            throw new Error(\n                `cannot evaluate node guard as the condition '${this.getCondition()}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the condition function to determine whether this guard is satisfied.\n        return !!!conditionFuncInvoker(this.args);\n    };\n}\n", "import { Agent } from \"../../Agent\";\nimport { AnyArgument } from \"../../RootAstNodesBuilder\";\nimport Attribute, { AttributeDetails } from \"../Attribute\";\n\nexport type CallbackAttributeDetails = {\n    /** The name of the agent function that is called. */\n    functionName: string;\n} & AttributeDetails;\n\n/**\n * A base node callback attribute.\n */\nexport default abstract class Callback extends Attribute<CallbackAttributeDetails> {\n    /**\n     * @param type The node attribute type.\n     * @param args The array of decorator argument definitions.\n     * @param functionName The name of the agent function to call.\n     */\n    constructor(type: string, args: AnyArgument[], private functionName: string) {\n        super(type, args);\n    }\n\n    /**\n     * Gets the name of the agent function to call.\n     */\n    getFunctionName = () => this.functionName;\n\n    /**\n     * Gets whether this attribute is a guard.\n     */\n    isGuard = () => false;\n\n    /**\n     * Gets the attribute details.\n     */\n    getDetails(): CallbackAttributeDetails {\n        return {\n            type: this.getType(),\n            args: this.getArguments(),\n            functionName: this.getFunctionName()\n        };\n    }\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     */\n    abstract callAgentFunction: (agent: Agent, isSuccess: boolean, isAborted: boolean) => void;\n}\n", "import Callback from \"./Callback\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\nimport { AnyArgument } from \"../../RootAstNodesBuilder\";\n\n/**\n * An ENTRY callback which defines an agent function to call when the associated node is updated and moves out of running state.\n */\nexport default class Entry extends Callback {\n    /**\n     * @param functionName The name of the agent function to call.\n     * @param args The array of callback argument definitions.\n     */\n    constructor(functionName: string, args: AnyArgument[]) {\n        super(\"entry\", args, functionName);\n    }\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     */\n    callAgentFunction = (agent: Agent) => {\n        // Attempt to get the invoker for the callback function.\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.getFunctionName());\n\n        // The callback function should be defined.\n        if (callbackFuncInvoker === null) {\n            throw new Error(\n                `cannot call entry function '${this.getFunctionName()}' as is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the callback function.\n        callbackFuncInvoker(this.args);\n    };\n}\n", "import Callback from \"./Callback\";\nimport Lookup, { AnyExitArgument } from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\nimport { AnyArgument } from \"../../RootAstNodesBuilder\";\n\n/**\n * An EXIT callback which defines an agent function to call when the associated node is updated and moves to a finished state or is aborted.\n */\nexport default class Exit extends Callback {\n    /**\n     * @param functionName The name of the agent function to call.\n     * @param args The array of callback argument definitions.\n     */\n    constructor(functionName: string, args: AnyArgument[]) {\n        super(\"exit\", args, functionName);\n    }\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     * @param isSuccess Whether the decorated node was left with a success state.\n     * @param isAborted Whether the decorated node was aborted.\n     */\n    callAgentFunction = (agent: Agent, isSuccess: boolean, isAborted: boolean) => {\n        // Attempt to get the invoker for the callback function.\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.getFunctionName());\n\n        // The callback function should be defined.\n        if (callbackFuncInvoker === null) {\n            throw new Error(\n                `cannot call exit function '${this.getFunctionName()}' as is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the callback function\n        callbackFuncInvoker([{ value: { succeeded: isSuccess, aborted: isAborted } }, ...this.args]);\n    };\n}\n", "import Callback from \"./Callback\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\nimport { AnyArgument } from \"../../RootAstNodesBuilder\";\n\n/**\n * A STEP callback which defines an agent function to call when the associated node is updated.\n */\nexport default class Step extends Callback {\n    /**\n     * @param functionName The name of the agent function to call.\n     * @param args The array of callback argument definitions.\n     */\n    constructor(functionName: string, args: AnyArgument[]) {\n        super(\"step\", args, functionName);\n    }\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     */\n    callAgentFunction = (agent: Agent) => {\n        // Attempt to get the invoker for the callback function.\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.getFunctionName());\n\n        // The callback function should be defined.\n        if (callbackFuncInvoker === null) {\n            throw new Error(\n                `cannot call step function '${this.getFunctionName()}' as is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the callback function.\n        callbackFuncInvoker(this.args);\n    };\n}\n", "import Action from \"./nodes/leaf/Action\";\nimport Condition from \"./nodes/leaf/Condition\";\nimport Wait from \"./nodes/leaf/Wait\";\nimport Root from \"./nodes/decorator/Root\";\nimport Repeat from \"./nodes/decorator/Repeat\";\nimport Retry from \"./nodes/decorator/Retry\";\nimport Flip from \"./nodes/decorator/Flip\";\nimport Succeed from \"./nodes/decorator/Succeed\";\nimport Fail from \"./nodes/decorator/Fail\";\nimport Lotto from \"./nodes/composite/Lotto\";\nimport Selector from \"./nodes/composite/Selector\";\nimport Sequence from \"./nodes/composite/Sequence\";\nimport Parallel from \"./nodes/composite/Parallel\";\nimport Node from \"./nodes/Node\";\nimport While from \"./attributes/guards/While\";\nimport Until from \"./attributes/guards/Until\";\nimport Entry from \"./attributes/callbacks/Entry\";\nimport Exit from \"./attributes/callbacks/Exit\";\nimport Step from \"./attributes/callbacks/Step\";\nimport Callback from \"./attributes/callbacks/Callback\";\nimport Guard from \"./attributes/guards/Guard\";\nimport Attribute from \"./attributes/Attribute\";\nimport Composite from \"./nodes/composite/Composite\";\nimport Decorator from \"./nodes/decorator/Decorator\";\nimport Leaf from \"./nodes/leaf/Leaf\";\n\nexport type Argument<T> = {\n    value: T;\n    type: string; // Used for validation.\n};\ntype NullArgument = Argument<null> & {\n    type: \"null\";\n};\ntype BooleanArgument = Argument<boolean> & {\n    type: \"boolean\";\n};\ntype NumberArgument = Argument<number> & {\n    type: \"number\";\n    isInteger: boolean; // Used for validation.\n};\ntype StringPlaceholderArgument = Argument<string> & {\n    type: \"string\";\n};\ntype IdentifierArgument = Argument<string> & {\n    type: \"identifier\";\n};\nexport type AnyArgument =\n    | NullArgument\n    | BooleanArgument\n    | NumberArgument\n    | StringPlaceholderArgument\n    | IdentifierArgument;\n\n/**\n * The node attribute factories.\n */\nconst AttributeFactories: {\n    [key: string]: (functionName: string, attributeArguments: AnyArgument[]) => Callback | Guard;\n} = {\n    WHILE: (condition: string, attributeArguments: AnyArgument[]) => new While(condition, attributeArguments),\n    UNTIL: (condition: string, attributeArguments: AnyArgument[]) => new Until(condition, attributeArguments),\n    ENTRY: (functionName: string, attributeArguments: AnyArgument[]) => new Entry(functionName, attributeArguments),\n    EXIT: (functionName: string, attributeArguments: AnyArgument[]) => new Exit(functionName, attributeArguments),\n    STEP: (functionName: string, attributeArguments: AnyArgument[]) => new Step(functionName, attributeArguments)\n};\n\ntype Validatable = {\n    children?: AstNode<Node>[];\n    validate: (depth: number) => void;\n};\n\ntype NodeInstanceCreator<T extends Node> = (\n    namedRootNodeProvider: (name: string) => RootAstNode,\n    visitedBranches: string[]\n) => T;\n\nexport type AstNode<T extends Node> = Validatable & {\n    type: string;\n    createNodeInstance: NodeInstanceCreator<T>;\n};\n\nexport type LeafAstNode<T extends Leaf = Leaf> = AstNode<T> & {\n    type: \"action\" | \"condition\" | \"wait\";\n    attributes: Attribute[];\n};\n\nexport type CompositeAstNode<T extends Composite = Composite> = AstNode<T> & {\n    type: \"lotto\" | \"parallel\" | \"selector\" | \"sequence\";\n    attributes: Attribute[];\n    children: AstNode<Node>[];\n};\n\nexport type DecoratorAstNode<T extends Decorator = Decorator> = AstNode<T> & {\n    type: \"fail\" | \"flip\" | \"repeat\" | \"retry\" | \"root\" | \"succeed\";\n    attributes: Attribute[];\n    children: AstNode<Node>[];\n};\n\nexport type BranchAstNode = AstNode<Node> & {\n    type: \"branch\";\n    branchName: \"\" | string;\n};\n\nexport type LottoAstNode = CompositeAstNode<Lotto> & {\n    type: \"lotto\";\n    tickets: number[];\n};\n\nexport type RootAstNode = DecoratorAstNode<Root> & {\n    type: \"root\";\n    name: null | string;\n};\n\nexport type RepeatAstNode = DecoratorAstNode<Repeat> & {\n    type: \"repeat\";\n    iterations: number | null;\n    iterationsMin: number | null;\n    iterationsMax: number | null;\n};\n\nexport type RetryAstNode = DecoratorAstNode<Retry> & {\n    type: \"retry\";\n    attempts: number | null;\n    attemptsMin: number | null;\n    attemptsMax: number | null;\n};\n\nexport type ActionAstNode = LeafAstNode<Action> & {\n    type: \"action\";\n    actionName: string;\n    actionArguments: AnyArgument[];\n};\n\nexport type ConditionAstNode = LeafAstNode<Condition> & {\n    type: \"condition\";\n    conditionName: string;\n    conditionArguments: AnyArgument[];\n};\n\nexport type WaitAstNode = LeafAstNode<Wait> & {\n    type: \"wait\";\n    duration: number | null;\n    durationMin: number | null;\n    durationMax: number | null;\n};\n\nexport type AnyAstNode =\n    | BranchAstNode\n    | CompositeAstNode\n    | LottoAstNode\n    | DecoratorAstNode\n    | RootAstNode\n    | RepeatAstNode\n    | RetryAstNode\n    | LeafAstNode\n    | ActionAstNode\n    | ConditionAstNode\n    | WaitAstNode;\n\n/**\n * The AST node factories.\n */\nconst ASTNodeFactories = {\n    ROOT: (): RootAstNode => ({\n        type: \"root\",\n        attributes: [],\n        name: null,\n        children: [],\n        validate(depth: number) {\n            // A root node cannot be the child of another node.\n            if (depth > 1) {\n                throw new Error(\"a root node cannot be the child of another node\");\n            }\n\n            // A root node must have a single child node.\n            if (this.children.length !== 1) {\n                throw new Error(\"a root node must have a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Root(\n                this.attributes,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    BRANCH: (): BranchAstNode => ({\n        type: \"branch\",\n        branchName: \"\",\n        validate() {},\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            // Try to find the root node with a matching branch name.\n            const targetRootNode = namedRootNodeProvider(this.branchName);\n\n            // If we have already visited this branch then we have a circular dependency.\n            if (visitedBranches.indexOf(this.branchName) !== -1) {\n                throw new Error(`circular dependency found in branch node references for branch '${this.branchName}'`);\n            }\n\n            // If we have a target root node, then the node instance we want will be the first and only child of the referenced root node.\n            if (targetRootNode) {\n                return targetRootNode\n                    .createNodeInstance(namedRootNodeProvider, visitedBranches.concat(this.branchName))\n                    .getChildren()[0];\n            } else {\n                throw new Error(`branch references root node '${this.branchName}' which has not been defined`);\n            }\n        }\n    }),\n    SELECTOR: (): CompositeAstNode => ({\n        type: \"selector\",\n        attributes: [],\n        children: [],\n        validate() {\n            // A selector node must have at least a single node.\n            if (this.children.length < 1) {\n                throw new Error(\"a selector node must have at least a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Selector(\n                this.attributes,\n                this.children.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\n            );\n        }\n    }),\n    SEQUENCE: (): CompositeAstNode => ({\n        type: \"sequence\",\n        attributes: [],\n        children: [],\n        validate() {\n            // A sequence node must have at least a single node.\n            if (this.children.length < 1) {\n                throw new Error(\"a sequence node must have at least a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Sequence(\n                this.attributes,\n                this.children.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\n            );\n        }\n    }),\n    PARALLEL: (): CompositeAstNode => ({\n        type: \"parallel\",\n        attributes: [],\n        children: [],\n        validate() {\n            // A parallel node must have at least a single node.\n            if (this.children.length < 1) {\n                throw new Error(\"a parallel node must have at least a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Parallel(\n                this.attributes,\n                this.children.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\n            );\n        }\n    }),\n    LOTTO: (): LottoAstNode => ({\n        type: \"lotto\",\n        attributes: [],\n        children: [],\n        tickets: [],\n        validate() {\n            // A lotto node must have at least a single node.\n            if (this.children!.length < 1) {\n                throw new Error(\"a lotto node must have at least a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Lotto(\n                this.attributes,\n                this.tickets!,\n                this.children!.map((child) => child.createNodeInstance(namedRootNodeProvider, visitedBranches.slice()))\n            );\n        }\n    }),\n    REPEAT: (): RepeatAstNode => ({\n        type: \"repeat\",\n        attributes: [],\n        iterations: null,\n        iterationsMin: null,\n        iterationsMax: null,\n        children: [],\n        validate() {\n            // A repeat node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a repeat node must have a single child\");\n            }\n\n            if (this.iterations !== null) {\n                // A repeat node must have a positive number of iterations if defined.\n                if (this.iterations < 0) {\n                    throw new Error(\"a repeat node must have a positive number of iterations if defined\");\n                }\n            } else if (this.iterationsMin !== null && this.iterationsMax !== null) {\n                // A repeat node must have a positive min and max iteration count if they are defined.\n                if (this.iterationsMin < 0 || this.iterationsMax < 0) {\n                    throw new Error(\n                        \"a repeat node must have a positive minimum and maximum iteration count if defined\"\n                    );\n                }\n\n                // A repeat node must not have an minimum iteration count that exceeds the maximum iteration count.\n                if (this.iterationsMin > this.iterationsMax) {\n                    throw new Error(\n                        \"a repeat node must not have a minimum iteration count that exceeds the maximum iteration count\"\n                    );\n                }\n            } else {\n                // If we have no explicit iteration count or a minimum and maximum iteration count set then we are dealing with a repeat node that iterates indefinitely.\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Repeat(\n                this.attributes,\n                this.iterations,\n                this.iterationsMin,\n                this.iterationsMax,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    RETRY: (): RetryAstNode => ({\n        type: \"retry\",\n        attributes: [],\n        attempts: null,\n        attemptsMin: null,\n        attemptsMax: null,\n        children: [],\n        validate() {\n            // A retry node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a retry node must have a single child\");\n            }\n\n            if (this.attempts !== null) {\n                // A retry node must have a positive number of attempts if defined.\n                if (this.attempts < 0) {\n                    throw new Error(\"a retry node must have a positive number of attempts if defined\");\n                }\n            } else if (this.attemptsMin !== null && this.attemptsMax !== null) {\n                // A retry node must have a positive min and max attempts count if they are defined.\n                if (this.attemptsMin < 0 || this.attemptsMax < 0) {\n                    throw new Error(\"a retry node must have a positive minimum and maximum attempt count if defined\");\n                }\n\n                // A retry node must not have a minimum attempt count that exceeds the maximum attempt count.\n                if (this.attemptsMin > this.attemptsMax) {\n                    throw new Error(\n                        \"a retry node must not have a minimum attempt count that exceeds the maximum attempt count\"\n                    );\n                }\n            } else {\n                // If we have no explicit attempt count or a minimum and maximum attempt count set then we are dealing with a retry node that attempts indefinitely.\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Retry(\n                this.attributes,\n                this.attempts,\n                this.attemptsMin,\n                this.attemptsMax,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    FLIP: (): DecoratorAstNode => ({\n        type: \"flip\",\n        attributes: [],\n        children: [],\n        validate() {\n            // A flip node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a flip node must have a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Flip(\n                this.attributes,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    SUCCEED: (): DecoratorAstNode => ({\n        type: \"succeed\",\n        attributes: [],\n        children: [],\n        validate() {\n            // A succeed node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a succeed node must have a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Succeed(\n                this.attributes,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    FAIL: (): DecoratorAstNode => ({\n        type: \"fail\",\n        attributes: [],\n        children: [],\n        validate() {\n            // A fail node must have a single node.\n            if (this.children!.length !== 1) {\n                throw new Error(\"a fail node must have a single child\");\n            }\n        },\n        createNodeInstance(namedRootNodeProvider, visitedBranches) {\n            return new Fail(\n                this.attributes,\n                this.children![0].createNodeInstance(namedRootNodeProvider, visitedBranches.slice())\n            );\n        }\n    }),\n    WAIT: (): WaitAstNode => ({\n        type: \"wait\",\n        attributes: [],\n        duration: null,\n        durationMin: null,\n        durationMax: null,\n        validate() {\n            if (this.duration !== null) {\n                // If an explict duration was defined then it must be a positive number.\n                if (this.duration < 0) {\n                    throw new Error(\"a wait node must have a positive duration\");\n                }\n            } else if (this.durationMin !== null && this.durationMax !== null) {\n                // A wait node must have a positive min and max duration.\n                if (this.durationMin < 0 || this.durationMax < 0) {\n                    throw new Error(\"a wait node must have a positive minimum and maximum duration\");\n                }\n\n                // A wait node must not have a minimum duration that exceeds the maximum duration.\n                if (this.durationMin > this.durationMax) {\n                    throw new Error(\"a wait node must not have a minimum duration that exceeds the maximum duration\");\n                }\n            } else {\n                // If we have no explicit duration or duration bounds set then we are dealing with a wait node that waits indefinitely.\n            }\n        },\n        createNodeInstance() {\n            return new Wait(this.attributes, this.duration, this.durationMin, this.durationMax);\n        }\n    }),\n    ACTION: (): ActionAstNode => ({\n        type: \"action\",\n        attributes: [],\n        actionName: \"\",\n        actionArguments: [],\n        validate() {},\n        createNodeInstance() {\n            return new Action(this.attributes, this.actionName!, this.actionArguments!);\n        }\n    }),\n    CONDITION: (): ConditionAstNode => ({\n        type: \"condition\",\n        attributes: [],\n        conditionName: \"\",\n        conditionArguments: [],\n        validate() {},\n        createNodeInstance() {\n            return new Condition(this.attributes, this.conditionName!, this.conditionArguments!);\n        }\n    })\n};\n\ntype OtherAstNodes = AstNode<Node>[];\n\n/**\n * Create an array of root AST nodes based on the given definition.\n * @param definition The definition to parse the AST nodes from.\n * @returns The base definition AST nodes.\n */\nexport default function buildRootASTNodes(definition: string): RootAstNode[] {\n    // Swap out any node/attribute argument string literals with a placeholder and get a mapping of placeholders to original values as well as the processed definition.\n    const { placeholders, processedDefinition } = substituteStringLiterals(definition);\n\n    // Convert the processed definition (with substituted string literals) into an array of raw tokens.\n    const tokens = parseTokensFromDefinition(processedDefinition);\n\n    // There must be at least 3 tokens for the tree definition to be valid. 'ROOT', '{' and '}'.\n    if (tokens.length < 3) {\n        throw new Error(\"invalid token count\");\n    }\n\n    // We should have a matching number of '{' and '}' tokens. If not, then there are scopes that have not been properly closed.\n    if (tokens.filter((token) => token === \"{\").length !== tokens.filter((token) => token === \"}\").length) {\n        throw new Error(\"scope character mismatch\");\n    }\n\n    // Create a stack of node children arrays, starting with a definition scope.\n    const stack: [RootAstNode[], ...OtherAstNodes[]] = [[]];\n    const rootScope = stack[0];\n\n    // We should keep processing the raw tokens until we run out of them.\n    while (tokens.length) {\n        // Grab the next token.\n        const token = tokens.shift();\n\n        const currentScope = stack[stack.length - 1] as OtherAstNodes;\n\n        // How we create the next AST token depends on the current raw token value.\n        switch (token!.toUpperCase()) {\n            case \"ROOT\": {\n                // Create a ROOT AST node.\n                const node = ASTNodeFactories.ROOT();\n\n                // Push the ROOT node into the current scope.\n                rootScope.push(node);\n\n                // We may have a root node name defined as an argument.\n                if (tokens[0] === \"[\") {\n                    const rootArguments = getArguments(tokens, placeholders);\n\n                    // We should have only a single argument that is not an empty string for a root node, which is the root name identifier.\n                    if (rootArguments.length === 1 && rootArguments[0].type === \"identifier\") {\n                        // The root name will be the first and only node argument.\n                        node.name = rootArguments[0].value as string;\n                    } else {\n                        throw new Error(\"expected single root name argument\");\n                    }\n                }\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new ROOT nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"BRANCH\": {\n                // Create a BRANCH AST node.\n                const node = ASTNodeFactories.BRANCH();\n\n                // Push the BRANCH node into the current scope.\n                currentScope.push(node);\n\n                // We must have arguments defined, as we require a branch name argument.\n                if (tokens[0] !== \"[\") {\n                    throw new Error(\"expected single branch name argument\");\n                }\n\n                // The branch name will be defined as a node argument.\n                const branchArguments = getArguments(tokens, placeholders);\n\n                // We should have only a single identifer argument for a branch node, which is the branch name.\n                if (branchArguments.length === 1 && branchArguments[0].type === \"identifier\") {\n                    // The branch name will be the first and only node argument.\n                    node.branchName = branchArguments[0].value as string;\n                } else {\n                    throw new Error(\"expected single branch name argument\");\n                }\n                break;\n            }\n\n            case \"SELECTOR\": {\n                // Create a SELECTOR AST node.\n                const node = ASTNodeFactories.SELECTOR();\n\n                // Push the SELECTOR node into the current scope.\n                currentScope.push(node);\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new SELECTOR nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"SEQUENCE\": {\n                // Create a SEQUENCE AST node.\n                const node = ASTNodeFactories.SEQUENCE();\n\n                // Push the SEQUENCE node into the current scope.\n                currentScope.push(node);\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new SEQUENCE nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"PARALLEL\": {\n                // Create a PARALLEL AST node.\n                const node = ASTNodeFactories.PARALLEL();\n\n                // Push the PARALLEL node into the current scope.\n                currentScope.push(node);\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new PARALLEL nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"LOTTO\": {\n                // Create a LOTTO AST node.\n                const node = ASTNodeFactories.LOTTO();\n\n                // Push the LOTTO node into the current scope.\n                currentScope.push(node);\n\n                // If the next token is a '[' character then some ticket counts have been defined as arguments.\n                if (tokens[0] === \"[\") {\n                    // Get the ticket count arguments, each argument must be a number.\n                    node.tickets = getArguments(\n                        tokens,\n                        placeholders,\n                        (arg) => arg.type === \"number\" && !!arg.isInteger,\n                        \"lotto node ticket counts must be integer values\"\n                    ).map((argument) => argument.value as number);\n                }\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new LOTTO nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"CONDITION\": {\n                // Create a CONDITION AST node.\n                const node = ASTNodeFactories.CONDITION();\n\n                // Push the CONDITION node into the current scope.\n                currentScope.push(node);\n\n                // We must have arguments defined, as we require a condition function name argument.\n                if (tokens[0] !== \"[\") {\n                    throw new Error(\"expected condition name identifier argument\");\n                }\n\n                // Grab the condition node arguments.\n                const conditionArguments = getArguments(tokens, placeholders);\n\n                // We should have at least a single identifier argument for a condition node, which is the condition function name.\n                if (conditionArguments.length && conditionArguments[0].type === \"identifier\") {\n                    // The condition function name will be the first node argument.\n                    node.conditionName = conditionArguments.shift()!.value as string;\n                } else {\n                    throw new Error(\"expected condition name identifier argument\");\n                }\n\n                // Only the first argument should have been an identifier, all following arguments must be string, number, boolean or null.\n                conditionArguments\n                    .filter((arg) => arg.type === \"identifier\")\n                    .forEach((arg) => {\n                        throw new Error(\n                            \"invalid condition node argument value '\" +\n                                arg.value +\n                                \"', must be string, number, boolean or null\"\n                        );\n                    });\n\n                // Any node arguments that follow the condition name identifier will be treated as condition function arguments.\n                node.conditionArguments = conditionArguments;\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n                break;\n            }\n\n            case \"FLIP\": {\n                // Create a FLIP AST node.\n                const node = ASTNodeFactories.FLIP();\n\n                // Push the Flip node into the current scope.\n                currentScope.push(node);\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new FLIP nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"SUCCEED\": {\n                // Create a SUCCEED AST node.\n                const node = ASTNodeFactories.SUCCEED();\n\n                // Push the Succeed node into the current scope.\n                currentScope.push(node);\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new Succeed nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"FAIL\": {\n                // Create a FAIL AST node.\n                const node = ASTNodeFactories.FAIL();\n\n                // Push the Fail node into the current scope.\n                currentScope.push(node);\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new Fail nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"WAIT\": {\n                // Create a WAIT AST node.\n                const node = ASTNodeFactories.WAIT();\n\n                // Push the WAIT node into the current scope.\n                currentScope.push(node);\n\n                // The arguments of a wait node are optional. We may have:\n                // - No node arguments, in which case the wait will be indefinite until it is aborted.\n                // - One node argument which will be the explicit duration of the wait.\n                // - Two node arguments which define the min and max duration bounds from which a random duration will be picked.\n                if (tokens[0] === \"[\") {\n                    // Get the optional duration and longest duration of the wait.\n                    const nodeArguments = getArguments(\n                        tokens,\n                        placeholders,\n                        (arg) => arg.type === \"number\" && !!arg.isInteger,\n                        \"wait node durations must be integer values\"\n                    ).map((argument) => argument.value);\n\n                    // We may have:\n                    // - One node argument which will be the explicit duration of the wait.\n                    // - Two node arguments which define the min and max duration bounds from which a random duration will be picked.\n                    // - Too many arguments, which is not valid.\n                    if (nodeArguments.length === 1) {\n                        // An explicit duration was defined.\n                        node.duration = nodeArguments[0] as number;\n                    } else if (nodeArguments.length === 2) {\n                        // Min and max duration bounds were defined from which a random duration will be picked.\n                        node.durationMin = nodeArguments[0] as number;\n                        node.durationMax = nodeArguments[1] as number;\n                    } else if (nodeArguments.length > 2) {\n                        // An incorrect number of durations was defined.\n                        throw new Error(\"invalid number of wait node duration arguments defined\");\n                    }\n                }\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n                break;\n            }\n\n            case \"REPEAT\": {\n                // Create a REPEAT AST node.\n                const node = ASTNodeFactories.REPEAT();\n\n                // Push the REPEAT node into the current scope.\n                currentScope.push(node);\n\n                // The arguments of a repeat node are optional. We may have:\n                // - No node arguments, in which case the repeat note will iterate indefinitely.\n                // - One node argument which will be the explicit number of iterations to make.\n                // - Two node arguments which define the min and max iteration bounds from which a random iteration count will be picked.\n                if (tokens[0] === \"[\") {\n                    // An iteration count has been defined. Get the iteration and potential maximum iteration of the wait.\n                    const nodeArguments = getArguments(\n                        tokens,\n                        placeholders,\n                        (arg) => arg.type === \"number\" && !!arg.isInteger,\n                        \"repeat node iteration counts must be integer values\"\n                    ).map((argument) => argument.value);\n\n                    // We should have got one or two iteration counts.\n                    if (nodeArguments.length === 1) {\n                        // A static iteration count was defined.\n                        node.iterations = nodeArguments[0] as number;\n                    } else if (nodeArguments.length === 2) {\n                        // A minimum and maximum iteration count was defined.\n                        node.iterationsMin = nodeArguments[0] as number;\n                        node.iterationsMax = nodeArguments[1] as number;\n                    } else {\n                        // An incorrect number of iteration counts was defined.\n                        throw new Error(\"invalid number of repeat node iteration count arguments defined\");\n                    }\n                }\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new REPEAT nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"RETRY\": {\n                // Create a RETRY AST node.\n                const node = ASTNodeFactories.RETRY();\n\n                // Push the RETRY node into the current scope.\n                currentScope.push(node);\n\n                // The arguments of a retry node are optional. We may have:\n                // - No node arguments, in which case the retry note will attempt indefinitely.\n                // - One node argument which will be the explicit number of attempts to make.\n                // - Two node arguments which define the min and max attempt bounds from which a random attempt count will be picked.\n                if (tokens[0] === \"[\") {\n                    // An attempt count has been defined. Get the attempt count and potential maximum attempt count of the wait.\n                    const nodeArguments = getArguments(\n                        tokens,\n                        placeholders,\n                        (arg) => arg.type === \"number\" && !!arg.isInteger,\n                        \"retry node attempt counts must be integer values\"\n                    ).map((argument) => argument.value);\n\n                    // We should have got one or two attempt counts.\n                    if (nodeArguments.length === 1) {\n                        // A static attempt count was defined.\n                        node.attempts = nodeArguments[0] as number;\n                    } else if (nodeArguments.length === 2) {\n                        // A minimum and maximum attempt count was defined.\n                        node.attemptsMin = nodeArguments[0] as number;\n                        node.attemptsMax = nodeArguments[1] as number;\n                    } else {\n                        // An incorrect number of attempt counts was defined.\n                        throw new Error(\"invalid number of retry node attempt count arguments defined\");\n                    }\n                }\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n\n                popAndCheck(tokens, \"{\");\n\n                // The new scope is that of the new RETRY nodes children.\n                stack.push(node.children!);\n                break;\n            }\n\n            case \"ACTION\": {\n                // Create a ACTION AST node.\n                const node = ASTNodeFactories.ACTION();\n\n                // Push the ACTION node into the current scope.\n                currentScope.push(node);\n\n                // We must have arguments defined, as we require an action name argument.\n                if (tokens[0] !== \"[\") {\n                    throw new Error(\"expected action name identifier argument\");\n                }\n\n                // The action name will be defined as a node argument.\n                const actionArguments = getArguments(tokens, placeholders);\n\n                // We should have at least one identifer argument for an action node, which is the action name.\n                if (actionArguments.length && actionArguments[0].type === \"identifier\") {\n                    // The action name will be the first and only node argument.\n                    node.actionName = actionArguments.shift()!.value as string;\n                } else {\n                    throw new Error(\"expected action name identifier argument\");\n                }\n\n                // Only the first argument should have been an identifier, all following arguments must be string, number, boolean or null.\n                actionArguments\n                    .filter((arg) => arg.type === \"identifier\")\n                    .forEach((arg) => {\n                        throw new Error(\n                            \"invalid action node argument value '\" +\n                                arg.value +\n                                \"', must be string, number, boolean or null\"\n                        );\n                    });\n\n                // Any node arguments that follow the action name identifier will be treated as action function arguments.\n                node.actionArguments = actionArguments;\n\n                // Try to pick any attributes off of the token stack.\n                node.attributes = getAttributes(tokens, placeholders);\n                break;\n            }\n\n            case \"}\": {\n                // The '}' character closes the current scope.\n                stack.pop();\n                break;\n            }\n\n            default: {\n                throw new Error(`unexpected token '${token}'`);\n            }\n        }\n    }\n\n    // A function to recursively validate each of the nodes in the AST.\n    const validateASTNode = (node: Validatable, depth: number): void => {\n        // Validate the node.\n        node.validate(depth);\n\n        // Validate each child of the node.\n        (node.children || []).forEach((child) => validateASTNode(child, depth + 1));\n    };\n\n    // Start node validation from the definition root.\n    validateASTNode(\n        {\n            children: stack[0] as RootAstNode[],\n            validate(this: { children: RootAstNode[] }) {\n                // We must have at least one node defined as the definition scope, which should be a root node.\n                if (this.children.length === 0) {\n                    throw new Error(\"expected root node to have been defined\");\n                }\n\n                // Each node at the base of the definition scope MUST be a root node.\n                for (const definitionLevelNode of this.children) {\n                    if (definitionLevelNode.type !== \"root\") {\n                        throw new Error(\"expected root node at base of definition\");\n                    }\n                }\n\n                // Exactly one root node must not have a name defined. This will be the main root, others will have to be referenced via branch nodes.\n                if (this.children.filter((definitionLevelNode) => definitionLevelNode.name === null).length !== 1) {\n                    throw new Error(\"expected single unnamed root node at base of definition to act as main root\");\n                }\n\n                // No two named root nodes can have matching names.\n                const rootNodeNames: string[] = [];\n                for (const definitionLevelNode of this.children) {\n                    if (rootNodeNames.indexOf(definitionLevelNode.name!) !== -1) {\n                        throw new Error(`multiple root nodes found with duplicate name '${definitionLevelNode.name}'`);\n                    } else {\n                        rootNodeNames.push(definitionLevelNode.name!);\n                    }\n                }\n            }\n        },\n        0\n    );\n\n    // Return the root AST nodes.\n    return stack[0];\n}\n\n/**\n * Pop the next raw token off of the stack and throw an error if it wasn't the expected one.\n * @param tokens The array of remaining tokens.\n * @param expected An optional string or array or items, one of which must match the next popped token.\n * @returns The popped token.\n */\nfunction popAndCheck(tokens: string[], expected: string | string[]) {\n    // Get and remove the next token.\n    const popped = tokens.shift();\n\n    // We were expecting another token.\n    if (popped === undefined) {\n        throw new Error(\"unexpected end of definition\");\n    }\n\n    // Do we have an expected token/tokens array?\n    if (expected !== undefined) {\n        // Check whether the popped token matches at least one of our expected items.\n        var tokenMatchesExpectation = ([] as string[])\n            .concat(expected)\n            .some((item) => popped.toUpperCase() === item.toUpperCase());\n\n        // Throw an error if the popped token didn't match any of our expected items.\n        if (!tokenMatchesExpectation) {\n            const expectationString = ([] as string[])\n                .concat(expected)\n                .map((item) => \"'\" + item + \"'\")\n                .join(\" or \");\n\n            throw new Error(`unexpected token found. Expected '${expectationString}' but got '${popped}'`);\n        }\n    }\n\n    // Return the popped token.\n    return popped;\n}\n\ntype StringPlaceholders = { [key: string]: string };\n\n/**\n * Pull an argument definition list off of the token stack.\n * @param tokens The array of remaining tokens.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @param argumentValidator The argument validator function.\n * @param validationFailedMessage  The exception message to throw if argument validation fails.\n * @returns The argument definition list.\n */\nfunction getArguments(\n    tokens: string[],\n    stringArgumentPlaceholders: StringPlaceholders,\n    argumentValidator?: (arg: AnyArgument) => boolean,\n    validationFailedMessage?: string\n) {\n    // Any lists of arguments will always be wrapped in '[]' for node arguments or '()' for attribute arguments.\n    // We are looking for a '[' or '(' opener that wraps the argument tokens and the relevant closer.\n    const closer = popAndCheck(tokens, [\"[\", \"(\"]) === \"[\" ? \"]\" : \")\";\n\n    const argumentListTokens: string[] = [];\n    const argumentList: AnyArgument[] = [];\n\n    // Grab all tokens between the '[' and ']' or '(' and ')'.\n    while (tokens.length && tokens[0] !== closer) {\n        // The next token is part of our arguments list.\n        argumentListTokens.push(tokens.shift()!);\n    }\n\n    // Validate the order of the argument tokens. Each token must either be a ',' or a single argument that satisfies the validator.\n    argumentListTokens.forEach((token, index) => {\n        // Get whether this token should be an actual argument.\n        const shouldBeArgumentToken = !(index & 1);\n\n        // If the current token should be an actual argument then validate it,otherwise it should be a ',' token.\n        if (shouldBeArgumentToken) {\n            // Get the argument definition.\n            const argumentDefinition = getArgumentDefinition(token!, stringArgumentPlaceholders);\n\n            // Try to validate the argument.\n            if (argumentValidator && !argumentValidator(argumentDefinition)) {\n                throw new Error(validationFailedMessage);\n            }\n\n            // This is a valid argument!\n            argumentList.push(argumentDefinition);\n        } else {\n            // The current token should be a ',' token.\n            if (token !== \",\") {\n                throw new Error(`invalid argument list, expected ',' or ']' but got '${token}'`);\n            }\n        }\n    });\n\n    // The arguments list should terminate with a ']' or ')' token, depending on the opener.\n    popAndCheck(tokens, closer);\n\n    // Return the argument list.\n    return argumentList;\n}\n\n/**\n * Gets an argument value definition.\n * @param token The argument token.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @returns An argument value definition.\n */\nfunction getArgumentDefinition(token: string, stringArgumentPlaceholders: StringPlaceholders): AnyArgument {\n    // Check whether the token represents a null value.\n    if (token === \"null\") {\n        return {\n            value: null,\n            type: \"null\"\n        } as NullArgument;\n    }\n\n    // Check whether the token represents a boolean value.\n    if (token === \"true\" || token === \"false\") {\n        return {\n            value: token === \"true\",\n            type: \"boolean\"\n        } as BooleanArgument;\n    }\n\n    // Check whether the token represents a number value.\n    // TODO: Relies on broken isNaN - see MDN.\n    // if (!Number.isNaN(token)) {\n    if (!isNaN(token as any)) {\n        return {\n            value: parseFloat(token),\n            isInteger: parseFloat(token) === parseInt(token, 10),\n            type: \"number\"\n        } as NumberArgument;\n    }\n\n    // Check whether the token is a placeholder (e.g. @@0@@) representing a string literal.\n    if (token.match(/^@@\\d+@@$/g)) {\n        return {\n            value: stringArgumentPlaceholders[token].replace('\\\\\"', '\"'),\n            type: \"string\"\n        } as StringPlaceholderArgument;\n    }\n\n    // The only remaining option is that the argument value is an identifier.\n    return {\n        value: token,\n        type: \"identifier\"\n    } as IdentifierArgument;\n}\n\n/**\n * Pull any attributes off of the token stack.\n * @param tokens The array of remaining tokens.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @returns An array of attributes defined by any directly following tokens.\n */\nfunction getAttributes(tokens: string[], stringArgumentPlaceholders: StringPlaceholders) {\n    // Create an array to hold any attributes found.\n    const attributes: Attribute[] = [];\n\n    // Keep track of names of attribute that we have found on the token stack, as we cannot have duplicates.\n    const attributesFound: string[] = [];\n\n    // Try to get the attribute factory for the next token.\n    let attributeFactory = AttributeFactories[(tokens[0] || \"\").toUpperCase()];\n\n    // Pull attribute tokens off of the tokens stack until we have no more.\n    while (attributeFactory) {\n        // Check to make sure that we have not already created a attribute of this type for this node.\n        if (attributesFound.indexOf(tokens[0].toUpperCase()) !== -1) {\n            throw new Error(`duplicate attribute '${tokens[0].toUpperCase()}' found for node`);\n        }\n\n        // Add the current attribute type to our array of found attributes.\n        attributesFound.push(tokens.shift()!.toUpperCase());\n\n        // Grab any attribute arguments.\n        const attributeArguments = getArguments(tokens, stringArgumentPlaceholders);\n\n        // The first attribute argument has to be an identifer, this will reference an agent function.\n        if (attributeArguments.length === 0 || attributeArguments[0].type !== \"identifier\") {\n            throw new Error(\"expected agent function name identifier argument for attribute\");\n        }\n\n        // Grab the first attribute which is an identifier that will reference an agent function.\n        const attributeFunctionName = attributeArguments.shift()! as IdentifierArgument;\n\n        // Any remaining attribute arguments must have a type of string, number, boolean or null.\n        attributeArguments\n            .filter((arg) => arg.type === \"identifier\")\n            .forEach((arg) => {\n                throw new Error(\n                    \"invalid attribute argument value '\" + arg.value + \"', must be string, number, boolean or null\"\n                );\n            });\n\n        // Create the attribute and add it to the array of attributes found.\n        attributes.push(attributeFactory(attributeFunctionName.value, attributeArguments));\n\n        // Try to get the next attribute name token, as there could be multiple.\n        attributeFactory = AttributeFactories[(tokens[0] || \"\").toUpperCase()];\n    }\n\n    return attributes;\n}\n\n/**\n * Swaps out any node/attribute argument string literals with placeholders.\n * @param definition The definition.\n * @returns An object containing a mapping of placeholders to original string values as well as the processed definition string.\n */\nfunction substituteStringLiterals(definition: string): {\n    placeholders: { [key: string]: string };\n    processedDefinition: string;\n} {\n    // Create an object to hold the mapping of placeholders to original string values.\n    const placeholders: StringPlaceholders = {};\n\n    // Replace any string literals wrapped with double quotes in our definition with placeholders to be processed later.\n    const processedDefinition = definition.replace(/\\\"(\\\\.|[^\"\\\\])*\\\"/g, (match) => {\n        var strippedMatch = match.substring(1, match.length - 1);\n        var placeholder = Object.keys(placeholders).find((key) => placeholders[key] === strippedMatch);\n\n        // If we have no existing string literal match then create a new placeholder.\n        if (!placeholder) {\n            placeholder = `@@${Object.keys(placeholders).length}@@`;\n            placeholders[placeholder] = strippedMatch;\n        }\n\n        return placeholder;\n    });\n\n    return { placeholders, processedDefinition };\n}\n\n/**\n * Parse the tree definition into an array of raw tokens.\n * @param definition The definition.\n * @returns An array of tokens parsed from the definition.\n */\nfunction parseTokensFromDefinition(definition: string): string[] {\n    // Add some space around various important characters so that they can be plucked out easier as individual tokens.\n    definition = definition.replace(/\\(/g, \" ( \");\n    definition = definition.replace(/\\)/g, \" ) \");\n    definition = definition.replace(/\\{/g, \" { \");\n    definition = definition.replace(/\\}/g, \" } \");\n    definition = definition.replace(/\\]/g, \" ] \");\n    definition = definition.replace(/\\[/g, \" [ \");\n    definition = definition.replace(/\\,/g, \" , \");\n\n    // Split the definition into raw token form and return it.\n    return definition.replace(/\\s+/g, \" \").trim().split(\" \");\n}\n", "import GuardPath, { GuardPathPart } from \"./attributes/guards/GuardPath\";\nimport buildRootASTNodes, { AnyArgument, RootAstNode } from \"./RootAstNodesBuilder\";\nimport State, { AnyState } from \"./State\";\nimport Lookup from \"./Lookup\";\nimport Node from \"./nodes/Node\";\nimport Root from \"./nodes/decorator/Root\";\nimport Composite from \"./nodes/composite/Composite\";\nimport Decorator from \"./nodes/decorator/Decorator\";\nimport { Agent, GlobalFunction } from \"./Agent\";\nimport { CallbackAttributeDetails } from \"./attributes/callbacks/Callback\";\nimport { GuardAttributeDetails } from \"./attributes/guards/Guard\";\nimport { BehaviourTreeOptions } from \"./BehaviourTreeOptions\";\nimport { convertMDSLToJSON } from \"./mdsl/MDSLDefinitionParser\";\n\n// Purely for outside inspection of the tree.\nexport type FlattenedTreeNode = {\n    id: string;\n    type: string;\n    caption: string;\n    state: AnyState;\n    guards: GuardAttributeDetails[];\n    callbacks: CallbackAttributeDetails[];\n    args: AnyArgument[];\n    parentId: string | null;\n};\n\n/**\n * A representation of a behaviour tree.\n */\nexport class BehaviourTree {\n    /**\n     * The main root tree node.\n     */\n    public readonly rootNode: Root;\n\n    /**\n     * Creates a new instance of the BehaviourTree class.\n     * @param definition The behaviour tree definition.\n     * @param agent The agent instance that this behaviour tree is modelling behaviour for.\n     * @param options The behaviour tree options object.\n     */\n    constructor(definition: string, private agent: Agent, private options: BehaviourTreeOptions = {}) {\n        // The tree definition must be defined and a valid string.\n        if (typeof definition !== \"string\") {\n            throw new Error(\"the tree definition must be a string\");\n        }\n\n        // The agent must be defined and not null.\n        if (typeof agent !== \"object\" || agent === null) {\n            throw new Error(\"the agent must be defined and not null\");\n        }\n\n        // Parse the behaviour tree definition, create the populated tree of behaviour tree nodes, and get the root.\n        this.rootNode = BehaviourTree._createRootNode(definition);\n    }\n\n    /**\n     * Gets whether the tree is in the RUNNING state.\n     * @returns true if the tree is in the RUNNING state, otherwise false.\n     */\n    isRunning() {\n        return this.rootNode.getState() === State.RUNNING;\n    }\n\n    /**\n     * Gets the current tree state of SUCCEEDED, FAILED, READY or RUNNING.\n     * @returns The current tree state.\n     */\n    getState() {\n        return this.rootNode.getState();\n    }\n\n    /**\n     * Step the tree.\n     * Carries out a node update that traverses the tree from the root node outwards to any child nodes, skipping those that are already in a resolved state of SUCCEEDED or FAILED.\n     * After being updated, leaf nodes will have a state of SUCCEEDED, FAILED or RUNNING. Leaf nodes that are left in the RUNNING state as part of a tree step will be revisited each\n     * subsequent step until they move into a resolved state of either SUCCEEDED or FAILED, after which execution will move through the tree to the next node with a state of READY.\n     *\n     * Calling this method when the tree is already in a resolved state of SUCCEEDED or FAILED will cause it to be reset before tree traversal begins.\n     */\n    step() {\n        // If the root node has already been stepped to completion then we need to reset it.\n        if (this.rootNode.getState() === State.SUCCEEDED || this.rootNode.getState() === State.FAILED) {\n            this.rootNode.reset();\n        }\n\n        try {\n            this.rootNode.update(this.agent, this.options);\n        } catch (exception) {\n            throw new Error(`error stepping tree: ${(exception as Error).message}`);\n        }\n    }\n\n    /**\n     * Resets the tree from the root node outwards to each nested node, giving each a state of READY.\n     */\n    reset() {\n        this.rootNode.reset();\n    }\n\n    /**\n     * Gets the flattened details of every node in the tree.\n     * @returns The flattened details of every node in the tree.\n     */\n    getFlattenedNodeDetails(): FlattenedTreeNode[] {\n        // Create an empty flattened array of tree nodes.\n        const flattenedTreeNodes: FlattenedTreeNode[] = [];\n\n        /**\n         * Helper function to process a node instance and push details into the flattened tree nodes array.\n         * @param node The current node.\n         * @param parentUid The UID of the node parent, or null if the node is the main root node.\n         */\n        const processNode = (node: Node, parentUid: string | null) => {\n            // Get the guard and callback attribute details for this node.\n            const guards = node\n                .getAttributes()\n                .filter((attribute) => attribute.isGuard())\n                .map((attribute) => attribute.getDetails()) as GuardAttributeDetails[];\n            const callbacks = node\n                .getAttributes()\n                .filter((attribute) => !attribute.isGuard())\n                .map((attribute) => attribute.getDetails()) as CallbackAttributeDetails[];\n\n            // Push the current node into the flattened nodes array.\n            flattenedTreeNodes.push({\n                id: node.getUid(),\n                type: node.getType(),\n                caption: node.getName(),\n                state: node.getState(),\n                guards,\n                callbacks,\n                args: node.getArguments(),\n                parentId: parentUid\n            });\n\n            // Process each of the nodes children if it is not a leaf node.\n            if (!node.isLeafNode()) {\n                (node as Composite | Decorator)\n                    .getChildren()\n                    .forEach((child) => processNode(child, (node as Composite | Decorator).getUid()));\n            }\n        };\n\n        // Convert the nested node structure into a flattened array of node details.\n        processNode(this.rootNode, null);\n\n        return flattenedTreeNodes;\n    }\n\n    /**\n     * Registers the action/condition/guard/callback function or subtree with the given name.\n     * @param name The name of the function or subtree to register.\n     * @param value The function or subtree definition to register.\n     */\n    static register(name: string, value: GlobalFunction | string) {\n        if (typeof value === \"function\") {\n            // We are going to register a action/condition/guard/callback function.\n            Lookup.setFunc(name, value);\n        } else if (typeof value === \"string\") {\n            // We are going to register a subtree.\n            let rootASTNodes: RootAstNode[];\n\n            try {\n                // Try to create the behaviour tree AST based on the definition provided, this could fail if the definition is invalid.\n                rootASTNodes = buildRootASTNodes(value);\n            } catch (exception) {\n                // There was an issue in trying to parse and build the tree definition.\n                throw new Error(`error registering definition: ${(exception as Error).message}`);\n            }\n\n            // This function should only ever be called with a definition containing a single unnamed root node.\n            if (rootASTNodes.length != 1 || rootASTNodes[0].name !== null) {\n                throw new Error(\"error registering definition: expected a single unnamed root node\");\n            }\n\n            Lookup.setSubtree(name, rootASTNodes[0]);\n        } else {\n            throw new Error(\"unexpected value, expected string definition or function\");\n        }\n    }\n\n    /**\n     * Unregisters the registered action/condition/guard/callback function or subtree with the given name.\n     * @param name The name of the registered action/condition/guard/callback function or subtree to unregister.\n     */\n    static unregister(name: string): void {\n        Lookup.remove(name);\n    }\n\n    /**\n     * Unregister all registered action/condition/guard/callback functions and subtrees.\n     */\n    static unregisterAll(): void {\n        Lookup.empty();\n    }\n\n    /**\n     * Parses a behaviour tree definition and creates a tree of behaviour tree nodes.\n     * @param {string} definition The behaviour tree definition.\n     * @returns The root behaviour tree node.\n     */\n    private static _createRootNode(definition: string): Root {\n        // TODO Remove!\n        try {\n            // parseToJSON(definition);\n        } catch (exception) {\n            console.log(exception);\n        }\n\n        try {\n            // Try to create the behaviour tree AST based on the definition provided, this could fail if the definition is invalid.\n            const rootASTNodes = buildRootASTNodes(definition);\n\n            // Create a symbol to use as the main root key in our root node mapping.\n            const mainRootNodeKey = Symbol(\"__root__\");\n\n            // Create a mapping of root node names to root AST tokens. The main root node will have a key of Symbol(\"__root__\").\n            const rootNodeMap: { [key: string | symbol]: RootAstNode } = {};\n            for (const rootASTNode of rootASTNodes) {\n                rootNodeMap[rootASTNode.name === null ? mainRootNodeKey : rootASTNode.name!] = rootASTNode;\n            }\n\n            // Convert the AST to our actual tree and get the root node.\n            const rootNode: Root = rootNodeMap[mainRootNodeKey].createNodeInstance(\n                // Create a provider for named root nodes that are part of our definition or have been registered. Prioritising the former.\n                (name: string): RootAstNode => (rootNodeMap[name] ? rootNodeMap[name] : Lookup.getSubtree(name)),\n                []\n            );\n\n            // Set a guard path on every leaf of the tree to evaluate as part of its update.\n            BehaviourTree._applyLeafNodeGuardPaths(rootNode);\n\n            // Return the root node.\n            return rootNode;\n        } catch (exception) {\n            // There was an issue in trying to parse and build the tree definition.\n            throw new Error(`error parsing tree: ${(exception as Error).message}`);\n        }\n    }\n\n    /**\n     * Applies a guard path to every leaf of the tree to evaluate as part of each update.\n     * @param rootNode The main root tree node.\n     */\n    private static _applyLeafNodeGuardPaths(rootNode: Root) {\n        const nodePaths: Node[][] = [];\n\n        const findLeafNodes = (path: Node[], node: Node) => {\n            // Add the current node to the path.\n            path = path.concat(node);\n\n            // Check whether the current node is a leaf node.\n            if (node.isLeafNode()) {\n                nodePaths.push(path);\n            } else {\n                (node as Composite | Decorator).getChildren().forEach((child) => findLeafNodes(path, child));\n            }\n        };\n\n        // Find all leaf node paths, starting from the root.\n        findLeafNodes([], rootNode);\n\n        nodePaths.forEach((path) => {\n            // Each node in the current path will have to be assigned a guard path, working from the root outwards.\n            for (let depth = 0; depth < path.length; depth++) {\n                // Get the node in the path at the current depth.\n                const currentNode = path[depth];\n\n                // The node may already have been assigned a guard path, if so just skip it.\n                if (currentNode.hasGuardPath()) {\n                    continue;\n                }\n\n                // Create the guard path for the current node.\n                const guardPath = new GuardPath(\n                    path\n                        .slice(0, depth + 1)\n                        .map<GuardPathPart>((node) => ({ node, guards: node.getGuardAttributes() }))\n                        .filter((details) => details.guards.length > 0)\n                );\n\n                // Assign the guard path to the current node.\n                currentNode.setGuardPath(guardPath);\n            }\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["Participant", "Lotto", "createLotto", "State", "createLotto", "substituteStringLiterals", "parseTokensFromDefinition", "popAndCheck", "getArgumentDefinition"]
}
