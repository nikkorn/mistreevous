{
  "version": 3,
  "sources": ["../node_modules/lotto-draw/dist/Participant.js", "../node_modules/lotto-draw/dist/Utilities.js", "../node_modules/lotto-draw/dist/Lotto.js", "../node_modules/lotto-draw/dist/createLotto.js", "../node_modules/lotto-draw/dist/index.js", "../src/index.ts", "../src/State.ts", "../src/Lookup.ts", "../src/BehaviourTreeDefinitionUtilities.ts", "../src/mdsl/MDSLArguments.ts", "../src/mdsl/MDSLUtilities.ts", "../src/mdsl/MDSLNodeArgumentParser.ts", "../src/mdsl/MDSLNodeAttributeParser.ts", "../src/mdsl/MDSLDefinitionParser.ts", "../src/BehaviourTreeDefinitionValidator.ts", "../src/attributes/guards/GuardUnsatisifedException.ts", "../src/attributes/guards/GuardPath.ts", "../src/Utilities.ts", "../src/nodes/Node.ts", "../src/nodes/leaf/Leaf.ts", "../src/nodes/composite/Composite.ts", "../src/nodes/composite/Parallel.ts", "../src/nodes/composite/Race.ts", "../src/nodes/composite/All.ts", "../src/nodes/composite/Selector.ts", "../src/nodes/composite/Sequence.ts", "../src/nodes/composite/Lotto.ts", "../src/nodes/decorator/Decorator.ts", "../src/nodes/decorator/Fail.ts", "../src/nodes/decorator/Flip.ts", "../src/nodes/decorator/Repeat.ts", "../src/nodes/decorator/Retry.ts", "../src/nodes/decorator/Root.ts", "../src/nodes/decorator/Succeed.ts", "../src/nodes/leaf/Action.ts", "../src/nodes/leaf/Condition.ts", "../src/nodes/leaf/Wait.ts", "../src/attributes/Attribute.ts", "../src/attributes/guards/Guard.ts", "../src/attributes/guards/While.ts", "../src/attributes/guards/Until.ts", "../src/attributes/callbacks/Callback.ts", "../src/attributes/callbacks/Entry.ts", "../src/attributes/callbacks/Step.ts", "../src/attributes/callbacks/Exit.ts", "../src/BehaviourTreeBuilder.ts", "../src/BehaviourTree.ts"],
  "sourcesContent": ["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Participant = void 0;\r\n/**\r\n * A participant that holds a number of tickets.\r\n */\r\nvar Participant = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of the Participant class.\r\n     * @param participant The actual participant.\r\n     * @param tickets The number of tickets held by the participant.\r\n     */\r\n    function Participant(participant, tickets) {\r\n        if (tickets === void 0) { tickets = 1; }\r\n        this._participant = participant;\r\n        this._tickets = tickets;\r\n    }\r\n    Object.defineProperty(Participant.prototype, \"participant\", {\r\n        /** Gets the actual participant. */\r\n        get: function () {\r\n            return this._participant;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Participant.prototype, \"tickets\", {\r\n        /** Gets or sets the number of tickets held by the participant. */\r\n        get: function () {\r\n            return this._tickets;\r\n        },\r\n        set: function (value) {\r\n            this._tickets = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return Participant;\r\n}());\r\nexports.Participant = Participant;\r\n", "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isNaturalNumber = exports.isNullOrUndefined = void 0;\r\n/**\r\n * Gets whether the value provided is null or undefined.\r\n * @param value The value to check.\r\n * @returns Whether the value provided is null or undefined.\r\n */\r\nfunction isNullOrUndefined(value) {\r\n    return value === null || value === undefined;\r\n}\r\nexports.isNullOrUndefined = isNullOrUndefined;\r\n/**\r\n * Gets whether the value provided is a natural number.\r\n * @param value The value to check.\r\n * @returns Whether the value provided is a natural number.\r\n */\r\nfunction isNaturalNumber(value) {\r\n    return typeof value === \"number\" && value >= 1 && Math.floor(value) === value;\r\n}\r\nexports.isNaturalNumber = isNaturalNumber;\r\n", "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Lotto = void 0;\r\nvar Participant_1 = require(\"./Participant\");\r\nvar Utilities_1 = require(\"./Utilities\");\r\n/**\r\n * Represents a lotto consisting of a number of pickable ticket-holding participants.\r\n */\r\nvar Lotto = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of Lotto.\r\n     * @param customRandom The custom RNG to use in place of Math.random().\r\n     */\r\n    function Lotto(customRandom) {\r\n        /** The array of participants that are holding tickets in the lotto. */\r\n        this._participants = [];\r\n        this._customRandom = customRandom;\r\n    }\r\n    /**\r\n     * Adds a participant with the specified number of tickets, or adds to the participant ticket count if the participant already holds tickets.\r\n     * @param participant The participant to add or to increase the ticket count for if they already hold tickets.\r\n     * @param tickets The number of tickets, defaults to 1.\r\n     * @returns The Lotto instance.\r\n     */\r\n    Lotto.prototype.add = function (participant, tickets) {\r\n        if (tickets === void 0) { tickets = 1; }\r\n        // Check that we have a valid ticket count.\r\n        if (!(0, Utilities_1.isNaturalNumber)(tickets)) {\r\n            throw new Error(\"tickets value must be a natural number\");\r\n        }\r\n        // Check whether this participant has already been added.\r\n        var existingParticipant = this._participants.find(function (part) { return part.participant === participant; });\r\n        if (existingParticipant) {\r\n            // The participant has already been added to the lotto so just add to their ticket count.\r\n            existingParticipant.tickets += tickets;\r\n        }\r\n        else {\r\n            // The participant is not part of the lotto so we should add them.\r\n            this._participants.push(new Participant_1.Participant(participant, tickets));\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the specified number of tickets for the given participant from the draw, or all tickets if a ticket number is not defined.\r\n     * @param participant The participant to remove tickets for.\r\n     * @param tickets The number of tickets to remove, or undefined if all tickets are to be removed.\r\n     * @returns The Lotto instance.\r\n     */\r\n    Lotto.prototype.remove = function (participant, tickets) {\r\n        // Attempt to get the existing participant.\r\n        var existingParticipant = this._participants.find(function (part) { return part.participant === participant; });\r\n        // There is nothing to do if the specified participant isn't even part of the lotto.\r\n        if (!existingParticipant) {\r\n            return this;\r\n        }\r\n        // Check whether a tickets value was given.\r\n        if (tickets !== undefined) {\r\n            // Check that we have a valid ticket count.\r\n            if (!(0, Utilities_1.isNaturalNumber)(tickets)) {\r\n                throw new Error(\"tickets value must be a natural number\");\r\n            }\r\n            existingParticipant.tickets -= tickets;\r\n            // If the participant no longer holds any tickets then they should be removed.\r\n            if (existingParticipant.tickets < 1) {\r\n                this._participants = this._participants.filter(function (part) { return part !== existingParticipant; });\r\n            }\r\n        }\r\n        else {\r\n            // We are removing all tickets for the participant so just remove them from the lotto.\r\n            this._participants = this._participants.filter(function (part) { return part !== existingParticipant; });\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Draw a winning ticket and return the participant that holds the ticket.\r\n     * @param options The draw options.\r\n     * @returns The participant that holds the winning ticket.\r\n     */\r\n    Lotto.prototype.draw = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        // If we have no participants then just return null.\r\n        if (this._participants.length === 0) {\r\n            return null;\r\n        }\r\n        var redrawable = (0, Utilities_1.isNullOrUndefined)(options.redrawable) ? true : options.redrawable;\r\n        var pickable = [];\r\n        this._participants.forEach(function (_a) {\r\n            var participant = _a.participant, tickets = _a.tickets;\r\n            for (var ticketCount = 0; ticketCount < tickets; ticketCount++) {\r\n                pickable.push(participant);\r\n            }\r\n        });\r\n        var random;\r\n        // We need a random floating-point number between 0 (inclusive) and 1 to scale up to pick our winner.\r\n        // If a custom random function exists then we should use that or fall back to Math.random().\r\n        if (this._customRandom) {\r\n            // Call our custom random function to get a random floating-point number.\r\n            random = this._customRandom();\r\n            // Verify that the result of calling our custom random function is a number between 0 (inclusive) and 1.\r\n            if (typeof random !== \"number\" || random < 0 || random >= 1) {\r\n                throw new Error(\"the 'random' function provided did not return a number between 0 (inclusive) and 1\");\r\n            }\r\n        }\r\n        else {\r\n            // No custom random function was defined so just use good ol' Math.random().\r\n            random = Math.random();\r\n        }\r\n        // Pick a winning participant.\r\n        var winner = pickable[Math.floor(random * pickable.length)];\r\n        // If the ticket isn't redrawable then we should remove a ticket from the winning participants ticket count.\r\n        if (!redrawable) {\r\n            this.remove(winner, 1);\r\n        }\r\n        // Return the winning participant.\r\n        return winner;\r\n    };\r\n    /**\r\n     * Draws multiple winning tickets and return an array of the participants that hold the winning tickets.\r\n     * @param tickets The number of winning tickets to draw.\r\n     * @param options The draw multiple options.\r\n     * @returns An array of the participants that hold the winning tickets.\r\n     */\r\n    Lotto.prototype.drawMultiple = function (tickets, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var uniqueResults = (0, Utilities_1.isNullOrUndefined)(options.unique) ? false : options.unique;\r\n        // Handle cases where the user has asked for zero tickets (no idea why they would do this be we should trust them).\r\n        if (tickets === 0) {\r\n            return [];\r\n        }\r\n        // Now that we know out tickets value is not zero we should check that it is a valid natural number.\r\n        if (!(0, Utilities_1.isNaturalNumber)(tickets)) {\r\n            throw new Error(\"tickets value must be a natural number\");\r\n        }\r\n        var result = [];\r\n        // Keep drawing tickets until we either reach the number of required tickets or we simply run out of tickets to draw.\r\n        // We can run out of tickets to draw if 'options.redrawable' is explicity 'false' or we just had no participants when 'drawMultiple' was called.\r\n        while (result.length < tickets && this._participants.length > 0) {\r\n            result.push(this.draw(options));\r\n        }\r\n        // If the 'unique' draw option is set then we need to remove duplicates from the result list.\r\n        if (uniqueResults) {\r\n            // Create an array to store our unique results.\r\n            var unique = [];\r\n            // Iterate over all of our participants (with potential duplicates) and populate our array of unique values.\r\n            for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\r\n                var participant = result_1[_i];\r\n                if (unique.indexOf(participant) === -1) {\r\n                    unique.push(participant);\r\n                }\r\n            }\r\n            result = unique;\r\n        }\r\n        return result;\r\n    };\r\n    return Lotto;\r\n}());\r\nexports.Lotto = Lotto;\r\n", "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createLotto = void 0;\r\nvar Lotto_1 = require(\"./Lotto\");\r\n/**\r\n * A function that creates and returns a Lotto instance.\r\n * @param participantsOrOptions An array of initial participants or options relating to the creation of a Lotto instance.\r\n * @returns A new Lotto instance.\r\n */\r\nfunction createLotto(participantsOrOptions) {\r\n    // If no initial participants or lotto options were provided as an argument then we can just return a new lotto instance now.\r\n    if (!participantsOrOptions) {\r\n        return new Lotto_1.Lotto();\r\n    }\r\n    // Check whether we were provided with an array of initial participants or a lotto options object.\r\n    if (Array.isArray(participantsOrOptions)) {\r\n        // We are dealing with a pre-defined array of participants.\r\n        var participants = participantsOrOptions;\r\n        var lotto_1 = new Lotto_1.Lotto();\r\n        // If the lotto participants have been defined upfront then we will need to add them all to our lotto instance now.\r\n        participants.forEach(function (_a) {\r\n            var participant = _a[0], tokens = _a[1];\r\n            return lotto_1.add(participant, tokens);\r\n        });\r\n        // Return the Lotto instance.\r\n        return lotto_1;\r\n    }\r\n    else {\r\n        // We are dealing with some lotto options.\r\n        var random = participantsOrOptions.random, participants = participantsOrOptions.participants;\r\n        // Create a Lotto instance passing the custom RNG function to use in place of Math.random() (which could be undefined).\r\n        var lotto_2 = new Lotto_1.Lotto(random);\r\n        // If the lotto participants have been defined upfront as part of the options then we will need to add them all to our lotto instance now.\r\n        if (participants) {\r\n            participants.forEach(function (_a) {\r\n                var participant = _a[0], tokens = _a[1];\r\n                return lotto_2.add(participant, tokens);\r\n            });\r\n        }\r\n        // Return the Lotto instance.\r\n        return lotto_2;\r\n    }\r\n}\r\nexports.createLotto = createLotto;\r\n", "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar createLotto_1 = require(\"./createLotto\");\r\nexports.default = createLotto_1.createLotto;\r\n", "import State from \"./State\";\nimport { BehaviourTree } from \"./BehaviourTree\";\nimport { NodeDetails } from \"./nodes/Node\";\nimport { BehaviourTreeOptions } from \"./BehaviourTreeOptions\";\nimport { validateDefinition } from \"./BehaviourTreeDefinitionValidator\";\nimport { convertMDSLToJSON } from \"./mdsl/MDSLDefinitionParser\";\n\nexport { BehaviourTree, State, convertMDSLToJSON, validateDefinition };\nexport type { NodeDetails, BehaviourTreeOptions };\n", "/**\n * Enumeration of node state types.\n */\nexport enum State {\n    /**\n     * The state that a node will be in when it has not been visited yet in the execution of the tree.\n     */\n    READY = \"mistreevous.ready\",\n    /**\n     * The state that a node will be in when it is still being processed and will usually represent or encompass a long-running action.\n     */\n    RUNNING = \"mistreevous.running\",\n    /**\n     * The state that a node will be in when it is no longer being processed and has succeeded.\n     */\n    SUCCEEDED = \"mistreevous.succeeded\",\n    /**\n     * The state that a node will be in when it is no longer being processed but has failed.\n     */\n    FAILED = \"mistreevous.failed\"\n}\n\nexport { State as default };\n\nexport type CompleteState = State.SUCCEEDED | State.FAILED;\nexport type AnyState = State.READY | State.RUNNING | CompleteState;\n", "import { ActionResult, Agent, GlobalFunction } from \"./Agent\";\nimport { RootNodeDefinition } from \"./BehaviourTreeDefinition\";\n\nexport type InvokerFunction = (args: any[]) => ActionResult | boolean;\n\n/**\n * A singleton used to store and lookup registered functions and subtrees.\n */\nexport default class Lookup {\n    /**\n     * The object holding any registered functions keyed on function name.\n     */\n    private static registeredFunctions: { [key: string]: GlobalFunction } = {};\n    /**\n     * The object holding any registered subtree root node definitions keyed on tree name.\n     */\n    private static registeredSubtrees: { [key: string]: RootNodeDefinition } = {};\n\n    /**\n     * Gets the function with the specified name.\n     * @param name The name of the function.\n     * @returns The function with the specified name.\n     */\n    public static getFunc(name: string): GlobalFunction {\n        return this.registeredFunctions[name];\n    }\n\n    /**\n     * Sets the function with the specified name for later lookup.\n     * @param name The name of the function.\n     * @param func The function.\n     */\n    public static setFunc(name: string, func: GlobalFunction): void {\n        this.registeredFunctions[name] = func;\n    }\n\n    /**\n     * Gets the function invoker for the specified agent and function name.\n     * If a function with the specified name exists on the agent object then it will\n     * be returned, otherwise we will then check the registered functions for a match.\n     * @param agent The agent instance that this behaviour tree is modelling behaviour for.\n     * @param name The function name.\n     * @returns The function invoker for the specified agent and function name.\n     */\n    static getFuncInvoker(agent: Agent, name: string): InvokerFunction | null {\n        // Check whether the agent contains the specified function.\n        const agentFunction = agent[name];\n        if (agentFunction && typeof agentFunction === \"function\") {\n            return (args: any[]) => agentFunction.apply(agent, args);\n        }\n\n        // The agent does not contain the specified function but it may have been registered at some point.\n        if (this.registeredFunctions[name] && typeof this.registeredFunctions[name] === \"function\") {\n            const registeredFunction = this.registeredFunctions[name];\n            return (args: any[]) => registeredFunction(agent, ...args);\n        }\n\n        // We have no function to invoke.\n        return null;\n    }\n\n    /**\n     * Gets all registered subtree root node definitions.\n     */\n    static getSubtrees(): { [key: string]: RootNodeDefinition } {\n        return this.registeredSubtrees;\n    }\n\n    /**\n     * Sets the subtree with the specified name for later lookup.\n     * @param name The name of the subtree.\n     * @param subtree The subtree.\n     */\n    static setSubtree(name: string, subtree: RootNodeDefinition) {\n        this.registeredSubtrees[name] = subtree;\n    }\n\n    /**\n     * Removes the registered function or subtree with the specified name.\n     * @param name The name of the registered function or subtree.\n     */\n    static remove(name: string) {\n        delete this.registeredFunctions[name];\n        delete this.registeredSubtrees[name];\n    }\n\n    /**\n     * Remove all registered functions and subtrees.\n     */\n    static empty() {\n        this.registeredFunctions = {};\n        this.registeredSubtrees = {};\n    }\n}\n", "import {\n    NodeDefinition,\n    RootNodeDefinition,\n    DecoratorNodeDefinition,\n    CompositeNodeDefinition,\n    AnyNodeDefinition,\n    BranchNodeDefinition\n} from \"./BehaviourTreeDefinition\";\n\n/**\n * A type guard function that returns true if the specified node satisfies the RootNodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the RootNodeDefinition type.\n */\nexport function isRootNodeDefinition(node: NodeDefinition): node is RootNodeDefinition {\n    return node.type === \"root\";\n}\n\n/**\n * A type guard function that returns true if the specified node satisfies the BranchNodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the BranchNodeDefinition type.\n */\nexport function isBranchNodeDefinition(node: NodeDefinition): node is BranchNodeDefinition {\n    return node.type === \"branch\";\n}\n\n/**\n * A type guard function that returns true if the specified node satisfies the NodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the NodeDefinition type.\n */\nexport function isLeafNodeDefinition(node: NodeDefinition): node is NodeDefinition {\n    return [\"branch\", \"action\", \"condition\", \"wait\"].includes(node.type);\n}\n\n/**\n * A type guard function that returns true if the specified node satisfies the DecoratorNodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the DecoratorNodeDefinition type.\n */\nexport function isDecoratorNodeDefinition(node: NodeDefinition): node is DecoratorNodeDefinition {\n    return [\"root\", \"repeat\", \"retry\", \"flip\", \"succeed\", \"fail\"].includes(node.type);\n}\n\n/**\n * A type guard function that returns true if the specified node satisfies the CompositeNodeDefinition type.\n * @param node The node.\n * @returns A value of true if the specified node satisfies the CompositeNodeDefinition type.\n */\nexport function isCompositeNodeDefinition(node: NodeDefinition): node is CompositeNodeDefinition {\n    return [\"sequence\", \"selector\", \"lotto\", \"parallel\", \"race\", \"all\"].includes(node.type);\n}\n\n/**\n * Flatten a node definition into an array of all of its nested node definitions.\n * @param nodeDefinition The node definition to flatten.\n * @returns An array of all of nested node definitions.\n */\nexport function flattenDefinition(nodeDefinition: AnyNodeDefinition): AnyNodeDefinition[] {\n    const nodes: AnyNodeDefinition[] = [];\n\n    const processNode = (currentNodeDefinition: AnyNodeDefinition) => {\n        nodes.push(currentNodeDefinition);\n\n        if (isCompositeNodeDefinition(currentNodeDefinition)) {\n            currentNodeDefinition.children.forEach(processNode);\n        } else if (isDecoratorNodeDefinition(currentNodeDefinition)) {\n            processNode(currentNodeDefinition.child);\n        }\n    };\n\n    processNode(nodeDefinition);\n\n    return nodes;\n}\n\n/**\n * Determines whether the passed value is an integer.\n * @param value The value to check.\n * @returns Whether the passed value is an integer.\n */\nexport function isInteger(value: unknown): boolean {\n    return typeof value === \"number\" && Math.floor(value) === value;\n}\n\n/**\n * Determines whether the passed value is null or undefined.\n * @param value The value to check.\n * @returns Whether the passed value is null or undefined.\n */\nexport function isNullOrUndefined(value: unknown): boolean {\n    return typeof value === \"undefined\" || value === null;\n}\n", "/**\n * This file contains definitions for types representing node arguments parsed from MDSL.\n * These definition do not, and are not supposed to, match any argument typings for user-defined JSON tree definitions.\n */\n\n/**\n * A type representing a node function argument parsed from MDSL.\n */\nexport type Argument<T> = {\n    /**\n     * The argument value.\n     */\n    value: T;\n};\n\n/**\n * A type representing a node function argument with a value of null parsed from MDSL.\n */\nexport type NullArgument = Argument<null> & {\n    /**\n     * The argument type.\n     */\n    type: \"null\";\n};\n\n/**\n * A type representing a node function argument with a value of boolean parsed from MDSL.\n */\nexport type BooleanArgument = Argument<boolean> & {\n    /**\n     * The argument type.\n     */\n    type: \"boolean\";\n};\n\n/**\n * A type representing a node function argument with a value of number parsed from MDSL.\n */\nexport type NumberArgument = Argument<number> & {\n    /**\n     * The argument type.\n     */\n    type: \"number\";\n    /**\n     * A flag defining whether the number argument value is a valid integer.\n     */\n    isInteger: boolean;\n};\n\n/**\n * A type representing a node function argument with a value of string which is a placeholder reference for a string literal argument parsed from MDSL.\n */\nexport type StringPlaceholderArgument = Argument<string> & {\n    /**\n     * The argument type.\n     */\n    type: \"string\";\n};\n\n/**\n * A type representing a node function argument with a value of an identifier parsed from MDSL.\n */\nexport type IdentifierArgument = Argument<string> & {\n    /**\n     * The argument type.\n     */\n    type: \"identifier\";\n};\n\n/**\n * A type representing a node function argument with a value of an agent property reference parsed from MDSL.\n */\nexport type AgentPropertyReferenceArgument = Argument<string> & {\n    /**\n     * The argument type.\n     */\n    type: \"property_reference\";\n};\n\n/**\n * A type representing a reference to any node function argument parsed from MDSL.\n */\nexport type AnyArgument =\n    | NullArgument\n    | BooleanArgument\n    | NumberArgument\n    | StringPlaceholderArgument\n    | IdentifierArgument\n    | AgentPropertyReferenceArgument;\n\n/**\n * Gets the JSON value of the specified argument object.\n * @param arg The argument object.\n * @returns The JSON value of the specified argument object.\n */\nexport function getArgumentJsonValue(arg: AnyArgument): any {\n    // If the argument is an agent property reference then the value format will be `{ $: \"some_property_name\" }`.\n    if (arg.type === \"property_reference\") {\n        return { $: arg.value };\n    }\n\n    // We can just return the value as-is.\n    return arg.value;\n}\n", "/**\n * A type defining an object that holds a reference to substituted string literals parsed from the definition.\n */\nexport type StringLiteralPlaceholders = { [key: string]: string };\n\n/**\n * An object representing the result of tokenising an MDSL definition.\n */\nexport type TokeniseResult = {\n    /**\n     * The array of tokens parsed from the definition.\n     */\n    tokens: string[];\n    /*\n     * An object that holds a reference to substituted string literals parsed from the definition.\n     */\n    placeholders: StringLiteralPlaceholders;\n};\n\n/**\n * Pop the next raw token from the specified array of tokens and throw an error if it wasn't the expected one.\n * @param tokens The array of tokens.\n * @param expected An optional string or array or items, one of which must match the next popped token.\n * @returns The popped token.\n */\nexport function popAndCheck(tokens: string[], expected?: string | string[]): string {\n    // Get and remove the next token.\n    const popped = tokens.shift();\n\n    // We were expecting another token but there aren't any.\n    if (popped === undefined) {\n        throw new Error(\"unexpected end of definition\");\n    }\n\n    // Do we have an expected token/tokens array?\n    if (expected != undefined) {\n        // Get an array of expected values, if the popped token matches any then we are all good.\n        const expectedValues = typeof expected === \"string\" ? [expected] : expected;\n\n        // Check whether the popped token matches at least one of our expected items.\n        const tokenMatchesExpectation = expectedValues.some((item) => popped.toUpperCase() === item.toUpperCase());\n\n        // Throw an error if the popped token didn't match any of our expected items.\n        if (!tokenMatchesExpectation) {\n            const expectationString = expectedValues.map((item) => \"'\" + item + \"'\").join(\" or \");\n            throw new Error(\"unexpected token found. Expected \" + expectationString + \" but got '\" + popped + \"'\");\n        }\n    }\n\n    // Return the popped token.\n    return popped;\n}\n\n/**\n * Parse the MDSL definition into an array of raw tokens.\n * @param definition The MDSL definition.\n * @returns An object representing the result of tokenising the MDSL definition.\n */\nexport function tokenise(definition: string): TokeniseResult {\n    // Clean the definition by removing any comments.\n    definition = definition.replace(/\\/\\*(.|\\n)*?\\*\\//g, \"\");\n\n    // Swap out any node/attribute argument string literals with a placeholder and get a mapping of placeholders to original values as well as the processed definition.\n    const { placeholders, processedDefinition } = substituteStringLiterals(definition);\n\n    // Add some space around various important characters so that they can be plucked out easier as individual tokens.\n    definition = processedDefinition.replace(/\\(/g, \" ( \");\n    definition = definition.replace(/\\)/g, \" ) \");\n    definition = definition.replace(/\\{/g, \" { \");\n    definition = definition.replace(/\\}/g, \" } \");\n    definition = definition.replace(/\\]/g, \" ] \");\n    definition = definition.replace(/\\[/g, \" [ \");\n    definition = definition.replace(/,/g, \" , \");\n\n    return {\n        // Split the definition into raw token form.\n        tokens: definition.replace(/\\s+/g, \" \").trim().split(\" \"),\n        // The placeholders for string literals that were found in the definition.\n        placeholders\n    };\n}\n\n/**\n * Swaps out any node/attribute argument string literals with placeholders.\n * @param definition The definition.\n * @returns An object containing a mapping of placeholders to original string values as well as the processed definition string.\n */\nfunction substituteStringLiterals(definition: string): {\n    placeholders: StringLiteralPlaceholders;\n    processedDefinition: string;\n} {\n    // Create an object to hold the mapping of placeholders to original string values.\n    const placeholders: StringLiteralPlaceholders = {};\n\n    // Replace any string literals wrapped with double quotes in our definition with placeholders to be processed later.\n    const processedDefinition = definition.replace(/\"(\\\\.|[^\"\\\\])*\"/g, (match) => {\n        const strippedMatch = match.substring(1, match.length - 1);\n        let placeholder = Object.keys(placeholders).find((key) => placeholders[key] === strippedMatch);\n\n        // If we have no existing string literal match then create a new placeholder.\n        if (!placeholder) {\n            placeholder = `@@${Object.keys(placeholders).length}@@`;\n            placeholders[placeholder] = strippedMatch;\n        }\n\n        return placeholder;\n    });\n\n    return { placeholders, processedDefinition };\n}\n", "import { AnyArgument } from \"./MDSLArguments\";\nimport { StringLiteralPlaceholders, popAndCheck } from \"./MDSLUtilities\";\n\n/**\n * Parse an array of argument definitions from the specified tokens array.\n * @param tokens The array tokens to parse the argument definitions from.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @param argumentValidator The argument validator function.\n * @param validationFailedMessage  The exception message to throw if argument validation fails.\n * @returns An array of argument definitions parsed from the specified tokens array.\n */\nexport function parseArgumentTokens(\n    tokens: string[],\n    stringArgumentPlaceholders: StringLiteralPlaceholders\n): AnyArgument[] {\n    const argumentList: AnyArgument[] = [];\n\n    // If the next token is not a '[' or '(' then we have no arguments to parse.\n    if (![\"[\", \"(\"].includes(tokens[0])) {\n        return argumentList;\n    }\n\n    // Any lists of arguments will always be wrapped in '[]' for node arguments or '()' for attribute arguments.\n    // We are looking for a '[' or '(' opener that wraps the argument tokens and the relevant closer.\n    const closingToken = popAndCheck(tokens, [\"[\", \"(\"]) === \"[\" ? \"]\" : \")\";\n\n    const argumentListTokens: string[] = [];\n\n    // Grab all tokens between the '[' and ']' or '(' and ')'.\n    while (tokens.length && tokens[0] !== closingToken) {\n        // The next token is part of our arguments list.\n        argumentListTokens.push(tokens.shift()!);\n    }\n\n    // Validate the order of the argument tokens. Each token must either be a ',' or a single argument that satisfies the validator.\n    argumentListTokens.forEach((token, index) => {\n        // Get whether this token should be an actual argument.\n        const shouldBeArgumentToken = !(index & 1);\n\n        // If the current token should be an actual argument then validate it, otherwise it should be a ',' token.\n        if (shouldBeArgumentToken) {\n            // Get the argument definition.\n            const argumentDefinition = getArgumentDefinition(token, stringArgumentPlaceholders);\n\n            // This is a valid argument!\n            argumentList.push(argumentDefinition);\n        } else {\n            // The current token should be a ',' token.\n            if (token !== \",\") {\n                throw new Error(`invalid argument list, expected ',' or ']' but got '${token}'`);\n            }\n        }\n    });\n\n    // The arguments list should terminate with a ']' or ')' token, depending on the opener.\n    popAndCheck(tokens, closingToken);\n\n    // Return the arguments.\n    return argumentList;\n}\n\n/**\n * Gets an argument value definition.\n * @param token The argument token.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @returns An argument value definition.\n */\nfunction getArgumentDefinition(token: string, stringArgumentPlaceholders: StringLiteralPlaceholders): AnyArgument {\n    // Check whether the token represents a null value.\n    if (token === \"null\") {\n        return {\n            value: null,\n            type: \"null\"\n        };\n    }\n\n    // Check whether the token represents a boolean value.\n    if (token === \"true\" || token === \"false\") {\n        return {\n            value: token === \"true\",\n            type: \"boolean\"\n        };\n    }\n\n    // Check whether the token represents a number value.\n    // TODO: Relies on broken isNaN - see MDN.\n    // if (!Number.isNaN(token)) {\n    if (!isNaN(token as any)) {\n        return {\n            value: parseFloat(token),\n            isInteger: parseFloat(token) === parseInt(token, 10),\n            type: \"number\"\n        };\n    }\n\n    // Check whether the token is a placeholder (e.g. @@0@@) representing a string literal.\n    if (token.match(/^@@\\d+@@$/g)) {\n        return {\n            value: stringArgumentPlaceholders[token].replace('\\\\\"', '\"'),\n            type: \"string\"\n        };\n    }\n\n    // Check whether the token is a valid javascript identifier with the '$' prefix (e.g. $someProperty, $another_Property_123) which references an agent property.\n    if (token.match(/^\\$[_a-zA-Z][_a-zA-Z0-9]*/g)) {\n        return {\n            // The value is the identifier name with the '$' prefix removed.\n            value: token.slice(1),\n            type: \"property_reference\"\n        };\n    }\n\n    // The only remaining option is that the argument value is an identifier.\n    return {\n        value: token,\n        type: \"identifier\"\n    };\n}\n", "import { NodeAttributeDefinition, NodeGuardDefinition } from \"../BehaviourTreeDefinition\";\nimport { getArgumentJsonValue } from \"./MDSLArguments\";\nimport { parseArgumentTokens } from \"./MDSLNodeArgumentParser\";\nimport { popAndCheck, StringLiteralPlaceholders } from \"./MDSLUtilities\";\n\n/**\n * A type defining the attribute definitions of a node.\n */\ntype NodeAttributes = {\n    while?: NodeGuardDefinition;\n    until?: NodeGuardDefinition;\n    entry?: NodeAttributeDefinition;\n    exit?: NodeAttributeDefinition;\n    step?: NodeAttributeDefinition;\n};\n\n/**\n * Parse any node attribute definitions from the specified tokens array.\n * @param tokens The array of remaining tokens.\n * @param stringArgumentPlaceholders The mapping of string literal node argument placeholders to original values.\n * @returns An object of attribute definitions defined by any directly following tokens.\n */\nexport function parseAttributeTokens(\n    tokens: string[],\n    stringArgumentPlaceholders: StringLiteralPlaceholders\n): NodeAttributes {\n    const nodeAttributeNames: (keyof NodeAttributes)[] = [\"while\", \"until\", \"entry\", \"exit\", \"step\"];\n\n    // Create an object to hold any attributes found.\n    const attributes: NodeAttributes = {};\n\n    // Try to get the name of the attribute for the next token.\n    let nextAttributeName = tokens[0]?.toLowerCase() as keyof NodeAttributes;\n\n    // Pull attribute tokens as well as their arguments off of the tokens stack until we have no more.\n    while (nodeAttributeNames.includes(nextAttributeName)) {\n        // Check to make sure that we have not already created an attribute definition of this type.\n        if (attributes[nextAttributeName]) {\n            throw new Error(`duplicate attribute '${tokens[0].toUpperCase()}' found for node`);\n        }\n\n        // Remove the attribute name token from the array of tokens.\n        tokens.shift();\n\n        // Grab the attribute arguments, assuming the first to be an identifier.\n        const [attributeCallIdentifier, ...attributeArguments] = parseArgumentTokens(\n            tokens,\n            stringArgumentPlaceholders\n        );\n\n        // The first attribute argument has to be an agent function reference.\n        if (attributeCallIdentifier?.type !== \"identifier\") {\n            throw new Error(\"expected agent function or registered function name identifier argument for attribute\");\n        }\n\n        // Any attribute arguments (other than the expected function reference token) must have a type of string, number, boolean, null or agent property reference.\n        attributeArguments\n            .filter((arg) => arg.type === \"identifier\")\n            .forEach((arg) => {\n                throw new Error(\n                    `invalid attribute argument value '${arg.value}', must be string, number, boolean, null or agent property reference`\n                );\n            });\n\n        // Are we dealing with a guard attribute or a normal attribute?\n        if (nextAttributeName === \"while\" || nextAttributeName === \"until\") {\n            // By default, an aborted running node will move to the FAILED state.\n            let succeedOnAbort = false;\n\n            // The resolved abort state could also be defined. Check for the token 'then' followed by 'succeed' or 'fail'.\n            if (tokens[0]?.toLowerCase() === \"then\") {\n                // Remove the \"then\" token from the array of tokens.\n                tokens.shift();\n\n                // The next token should be either the 'succeed' or 'fail' resolved status.\n                const resolvedStatusToken = popAndCheck(tokens, [\"succeed\", \"fail\"]);\n\n                succeedOnAbort = resolvedStatusToken.toLowerCase() === \"succeed\";\n            }\n\n            // Create the guard definition and add it to the object of attribute definitions found.\n            attributes[nextAttributeName] = {\n                call: attributeCallIdentifier.value,\n                args: attributeArguments.map(getArgumentJsonValue),\n                succeedOnAbort\n            };\n        } else {\n            // Create the attribute definition and add it to the object of attribute definitions found.\n            attributes[nextAttributeName] = {\n                call: attributeCallIdentifier.value,\n                args: attributeArguments.map(getArgumentJsonValue)\n            };\n        }\n\n        // Try to get the next attribute name token, as there could be multiple.\n        nextAttributeName = tokens[0]?.toLowerCase() as keyof NodeAttributes;\n    }\n\n    return attributes;\n}\n", "import {\n    ActionNodeDefinition,\n    AnyChildNodeDefinition,\n    AnyNodeDefinition,\n    BranchNodeDefinition,\n    ConditionNodeDefinition,\n    FailNodeDefinition,\n    FlipNodeDefinition,\n    LottoNodeDefinition,\n    ParallelNodeDefinition,\n    RaceNodeDefinition,\n    AllNodeDefinition,\n    RepeatNodeDefinition,\n    RetryNodeDefinition,\n    RootNodeDefinition,\n    SelectorNodeDefinition,\n    SequenceNodeDefinition,\n    SucceedNodeDefinition,\n    WaitNodeDefinition\n} from \"../BehaviourTreeDefinition\";\nimport {\n    isCompositeNodeDefinition,\n    isDecoratorNodeDefinition,\n    isLeafNodeDefinition,\n    isNullOrUndefined,\n    isRootNodeDefinition\n} from \"../BehaviourTreeDefinitionUtilities\";\nimport { getArgumentJsonValue } from \"./MDSLArguments\";\nimport { parseArgumentTokens } from \"./MDSLNodeArgumentParser\";\nimport { parseAttributeTokens } from \"./MDSLNodeAttributeParser\";\nimport { StringLiteralPlaceholders, tokenise, popAndCheck } from \"./MDSLUtilities\";\n\n/**\n * Convert the MDSL tree definition string into an equivalent JSON definition.\n * @param definition The tree definition string as MDSL.\n * @returns The root node JSON definitions.\n */\nexport function convertMDSLToJSON(definition: string): RootNodeDefinition[] {\n    // Parse our definition string into a bunch of tokens.\n    const { tokens, placeholders } = tokenise(definition);\n\n    // Convert the tokens that we parsed from the MDSL definition into JSON and return it.\n    return convertTokensToJSONDefinition(tokens, placeholders);\n}\n\n/**\n * Converts the specified tree definition tokens into a JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The root node JSON definitions.\n */\nfunction convertTokensToJSONDefinition(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): RootNodeDefinition[] {\n    // There must be at least 3 tokens for the tree definition to be valid. 'ROOT', '{' and '}'.\n    if (tokens.length < 3) {\n        throw new Error(\"invalid token count\");\n    }\n\n    // We should have a matching number of '{' and '}' tokens. If not, then there are scopes that have not been properly closed.\n    if (tokens.filter((token) => token === \"{\").length !== tokens.filter((token) => token === \"}\").length) {\n        throw new Error(\"scope character mismatch\");\n    }\n\n    // Create an array of tree stack arrays where root nodes will always be at the botton and the current composite/decorator node at the top.\n    // There should be an element in this array for every root node defined and every element should be an array with a root note as the first element.\n    // E.g. A definition with two root nodes defined:\n    // [\n    //    [root, lotto, sequence],\n    //    [root, selector]\n    // ]\n    const treeStacks: [Partial<RootNodeDefinition>, ...Partial<AnyChildNodeDefinition>[]][] = [];\n\n    // Create an array of all root node definitions that we create.\n    const rootNodes: Partial<RootNodeDefinition>[] = [];\n\n    // A helper function used to push node definitions onto the tree stack.\n    const pushNode = (node: AnyNodeDefinition) => {\n        // If the node is a root node then we need to create a new tree stack array with the root node at the root.\n        if (isRootNodeDefinition(node)) {\n            // We need to double-check that this root node is not the child of another node.\n            // We can do this by checking whether the top tree stack is not empty (contains an existing node)\n            if (treeStacks[treeStacks.length - 1]?.length) {\n                throw new Error(\"a root node cannot be the child of another node\");\n            }\n\n            // Add the root node definition to our array of all parsed root node definitions.\n            rootNodes.push(node);\n\n            // Add the root node definition to the root of a new tree stack.\n            treeStacks.push([node]);\n\n            return;\n        }\n\n        // All non-root nodes should be pushed after their root nodes so handle cases\n        // where we may not have any tree stacks or our top-most tree stack is empty.\n        if (!treeStacks.length || !treeStacks[treeStacks.length - 1].length) {\n            throw new Error(\"expected root node at base of definition\");\n        }\n\n        // Get the current tree stack that we are populating.\n        const topTreeStack = treeStacks[treeStacks.length - 1];\n\n        // Get the top-most node in the current tree stack, this will be a composite/decorator node\n        // for which we will populate its children array if composite or setting its child if a decorator.\n        const topTreeStackTopNode = topTreeStack[topTreeStack.length - 1] as AnyNodeDefinition;\n\n        // If the top-most node in the current root stack is a composite or decorator\n        // node then the current node should be added as a child of the top-most node.\n        if (isCompositeNodeDefinition(topTreeStackTopNode)) {\n            topTreeStackTopNode.children = topTreeStackTopNode.children || [];\n            topTreeStackTopNode.children.push(node);\n        } else if (isDecoratorNodeDefinition(topTreeStackTopNode)) {\n            // If the top node already has a child node set then throw an error as a decorator should only have a single child.\n            if (topTreeStackTopNode.child) {\n                throw new Error(\"a decorator node must only have a single child node\");\n            }\n\n            topTreeStackTopNode.child = node;\n        }\n\n        // If the node we are adding is also a composite or decorator node, then we should push it\n        // onto the current tree stack, as subsequent nodes will be added as its child/children.\n        if (!isLeafNodeDefinition(node)) {\n            topTreeStack.push(node);\n        }\n    };\n\n    // A helper function used to pop the top-most node definition off of the tree stack and return it.\n    const popNode = (): AnyNodeDefinition | null => {\n        let poppedNode: AnyNodeDefinition | null = null;\n\n        // Get the current tree stack that we are populating.\n        const topTreeStack = treeStacks[treeStacks.length - 1];\n\n        // Pop the top-most node in the current tree stack if there is one.\n        if (topTreeStack.length) {\n            poppedNode = topTreeStack.pop() as AnyNodeDefinition;\n        }\n\n        // We don't want any empty tree stacks in our stack of tree stacks.\n        if (!topTreeStack.length) {\n            treeStacks.pop();\n        }\n\n        return poppedNode;\n    };\n\n    // We should keep processing the raw tokens until we run out of them.\n    while (tokens.length) {\n        // Grab the next token.\n        const token = tokens.shift()!;\n\n        // How we create the next node depends on the current raw token value.\n        switch (token.toUpperCase()) {\n            case \"ROOT\": {\n                pushNode(createRootNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"SUCCEED\": {\n                pushNode(createSucceedNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"FAIL\": {\n                pushNode(createFailNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"FLIP\": {\n                pushNode(createFlipNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"REPEAT\": {\n                pushNode(createRepeatNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"RETRY\": {\n                pushNode(createRetryNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"SEQUENCE\": {\n                pushNode(createSequenceNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"SELECTOR\": {\n                pushNode(createSelectorNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"PARALLEL\": {\n                pushNode(createParallelNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"RACE\": {\n                pushNode(createRaceNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"ALL\": {\n                pushNode(createAllNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"LOTTO\": {\n                pushNode(createLottoNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"ACTION\": {\n                pushNode(createActionNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"CONDITION\": {\n                pushNode(createConditionNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"WAIT\": {\n                pushNode(createWaitNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"BRANCH\": {\n                pushNode(createBranchNode(tokens, stringLiteralPlaceholders));\n                break;\n            }\n\n            case \"}\": {\n                // The '}' character closes the current scope and means that we have to pop a node off of the current stack.\n                const poppedNode = popNode();\n\n                // Now that we have a node definition we can carry out any validation that may require the node to be fully populated.\n                if (poppedNode) {\n                    validatePoppedNode(poppedNode);\n                }\n\n                break;\n            }\n\n            default: {\n                throw new Error(`unexpected token: ${token}`);\n            }\n        }\n    }\n\n    return rootNodes as RootNodeDefinition[];\n}\n\n/**\n * Creates a root node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The root node JSON definition.\n */\nfunction createRootNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): RootNodeDefinition {\n    // Create the root node definition.\n    let node = {\n        type: \"root\"\n    } as Partial<RootNodeDefinition>;\n\n    // Parse any node arguments, we should only have one if any which will be an identifier argument for the root identifier.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // Check whether any node arguments were defined.\n    if (nodeArguments.length) {\n        // We should only have one argument, if any, which will be an identifier argument for the root identifier.\n        if (nodeArguments.length === 1 && nodeArguments[0].type === \"identifier\") {\n            // The root node identifier will be the first and only node argument value.\n            node.id = nodeArguments[0].value as string;\n        } else {\n            throw new Error(\"expected single root name argument\");\n        }\n    }\n\n    // Grab any node attribute definitions and spread them into the node definition.\n    node = { ...node, ...parseAttributeTokens(tokens, stringLiteralPlaceholders) };\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the root node definition.\n    return node as RootNodeDefinition;\n}\n\n/**\n * Creates a succeed node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The succeed node JSON definition.\n */\nfunction createSucceedNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): SucceedNodeDefinition {\n    const node = {\n        type: \"succeed\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as SucceedNodeDefinition;\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the succeed node definition.\n    return node;\n}\n\n/**\n * Creates a fail node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The fail node JSON definition.\n */\nfunction createFailNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): FailNodeDefinition {\n    const node = {\n        type: \"fail\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as FailNodeDefinition;\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the fail node definition.\n    return node;\n}\n\n/**\n * Creates a flip node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The flip node JSON definition.\n */\nfunction createFlipNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): FlipNodeDefinition {\n    const node = {\n        type: \"flip\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as FlipNodeDefinition;\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the flip node definition.\n    return node;\n}\n\n/**\n * Creates a repeat node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The repeat node JSON definition.\n */\nfunction createRepeatNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): RepeatNodeDefinition {\n    let node = { type: \"repeat\" } as RepeatNodeDefinition;\n\n    // Get the node arguments.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // The arguments of a repeat node are optional. We may have:\n    // - No node arguments, in which case the repeat note will iterate indefinitely.\n    // - One node argument which will be the explicit number of iterations to make.\n    // - Two node arguments which define the min and max iteration bounds from which a random iteration count will be picked.\n    if (nodeArguments.length) {\n        // All repeat node arguments MUST be of type number and must be integer.\n        nodeArguments\n            .filter((arg) => arg.type !== \"number\" || !arg.isInteger)\n            .forEach(() => {\n                throw new Error(`repeat node iteration counts must be integer values`);\n            });\n\n        // We should have got one or two iteration counts.\n        if (nodeArguments.length === 1) {\n            // A static iteration count was defined.\n            node.iterations = nodeArguments[0].value as number;\n\n            // A repeat node must have a positive number of iterations if defined.\n            if (node.iterations < 0) {\n                throw new Error(\"a repeat node must have a positive number of iterations if defined\");\n            }\n        } else if (nodeArguments.length === 2) {\n            // A minimum and maximum iteration count was defined.\n            node.iterations = [nodeArguments[0].value as number, nodeArguments[1].value as number];\n\n            // A repeat node must have a positive min and max iteration count if they are defined.\n            if (node.iterations[0] < 0 || node.iterations[1] < 0) {\n                throw new Error(\"a repeat node must have a positive minimum and maximum iteration count if defined\");\n            }\n\n            // A repeat node must not have an minimum iteration count that exceeds the maximum iteration count.\n            if (node.iterations[0] > node.iterations[1]) {\n                throw new Error(\n                    \"a repeat node must not have a minimum iteration count that exceeds the maximum iteration count\"\n                );\n            }\n        } else {\n            // An incorrect number of iteration counts was defined.\n            throw new Error(\"invalid number of repeat node iteration count arguments defined\");\n        }\n    }\n\n    // Grab any node attribute definitions and spread them into the node definition.\n    node = { ...node, ...parseAttributeTokens(tokens, stringLiteralPlaceholders) };\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the repeat node definition.\n    return node;\n}\n\n/**\n * Creates a retry node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The retry node JSON definition.\n */\nfunction createRetryNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): RetryNodeDefinition {\n    let node = { type: \"retry\" } as RetryNodeDefinition;\n\n    // Get the node arguments.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // The arguments of a retry node are optional. We may have:\n    // - No node arguments, in which case the retry note will attempt indefinitely.\n    // - One node argument which will be the explicit number of attempts to make.\n    // - Two node arguments which define the min and max attempt bounds from which a random attempt count will be picked.\n    if (nodeArguments.length) {\n        // All retry node arguments MUST be of type number and must be integer.\n        nodeArguments\n            .filter((arg) => arg.type !== \"number\" || !arg.isInteger)\n            .forEach(() => {\n                throw new Error(`retry node attempt counts must be integer values`);\n            });\n\n        // We should have got one or two attempt counts.\n        if (nodeArguments.length === 1) {\n            // A static attempt count was defined.\n            node.attempts = nodeArguments[0].value as number;\n\n            // A retry node must have a positive number of attempts if defined.\n            if (node.attempts < 0) {\n                throw new Error(\"a retry node must have a positive number of attempts if defined\");\n            }\n        } else if (nodeArguments.length === 2) {\n            // A minimum and maximum attempt count was defined.\n            node.attempts = [nodeArguments[0].value as number, nodeArguments[1].value as number];\n\n            // A retry node must have a positive min and max attempts count if they are defined.\n            if (node.attempts[0] < 0 || node.attempts[1] < 0) {\n                throw new Error(\"a retry node must have a positive minimum and maximum attempt count if defined\");\n            }\n\n            // A retry node must not have a minimum attempt count that exceeds the maximum attempt count.\n            if (node.attempts[0] > node.attempts[1]) {\n                throw new Error(\n                    \"a retry node must not have a minimum attempt count that exceeds the maximum attempt count\"\n                );\n            }\n        } else {\n            // An incorrect number of attempt counts was defined.\n            throw new Error(\"invalid number of retry node attempt count arguments defined\");\n        }\n    }\n\n    // Grab any node attribute definitions and spread them into the node definition.\n    node = { ...node, ...parseAttributeTokens(tokens, stringLiteralPlaceholders) };\n\n    // This is a decorator node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the retry node definition.\n    return node;\n}\n\n/**\n * Creates a sequence node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The sequence node JSON definition.\n */\nfunction createSequenceNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): SequenceNodeDefinition {\n    const node = {\n        type: \"sequence\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as SequenceNodeDefinition;\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the sequence node definition.\n    return node;\n}\n\n/**\n * Creates a selector node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The selector node JSON definition.\n */\nfunction createSelectorNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): SelectorNodeDefinition {\n    const node = {\n        type: \"selector\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as SelectorNodeDefinition;\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the selector node definition.\n    return node;\n}\n\n/**\n * Creates a parallel node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The parallel node JSON definition.\n */\nfunction createParallelNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): ParallelNodeDefinition {\n    const node = {\n        type: \"parallel\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as ParallelNodeDefinition;\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the parallel node definition.\n    return node;\n}\n\n/**\n * Creates a race node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The race node JSON definition.\n */\nfunction createRaceNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): RaceNodeDefinition {\n    const node = {\n        type: \"race\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as RaceNodeDefinition;\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the race node definition.\n    return node;\n}\n\n/**\n * Creates an all node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The all node JSON definition.\n */\nfunction createAllNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): AllNodeDefinition {\n    const node = {\n        type: \"all\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as AllNodeDefinition;\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the all node definition.\n    return node;\n}\n\n/**\n * Creates a lotto node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The lotto node JSON definition.\n */\nfunction createLottoNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): LottoNodeDefinition {\n    // If any node arguments have been defined then they must be our weights.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // All lotto node arguments MUST be of type number and must be positive integers.\n    nodeArguments\n        .filter((arg) => arg.type !== \"number\" || !arg.isInteger || arg.value < 0)\n        .forEach(() => {\n            throw new Error(`lotto node weight arguments must be positive integer values`);\n        });\n\n    const node = {\n        type: \"lotto\",\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    } as LottoNodeDefinition;\n\n    // Apply the weights if any were defined.\n    if (nodeArguments.length) {\n        node.weights = nodeArguments.map(({ value }) => value) as number[];\n    }\n\n    // This is a composite node, so we expect an opening '{'.\n    popAndCheck(tokens, \"{\");\n\n    // Return the lotto node definition.\n    return node;\n}\n\n/**\n * Creates an action node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The action node JSON definition.\n */\nfunction createActionNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): ActionNodeDefinition {\n    // Parse any node arguments, we should have at least one which will be an identifier argument for the action name\n    // and agent function to invoke for the action, all other arguments are to be passed as arguments to that function.\n    const [actionNameIdentifier, ...agentFunctionArgs] = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // Our first argument MUST be defined and be an identifier as we require an action name argument.\n    if (actionNameIdentifier?.type !== \"identifier\") {\n        throw new Error(\"expected action name identifier argument\");\n    }\n\n    // Return the action node definition.\n    return {\n        type: \"action\",\n        call: actionNameIdentifier.value,\n        args: agentFunctionArgs.map(getArgumentJsonValue),\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    };\n}\n\n/**\n * Creates a condition node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The condition node JSON definition.\n */\nfunction createConditionNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): ConditionNodeDefinition {\n    // Parse any node arguments, we should have at least one which will be an identifier argument for the condition name\n    // and agent function to invoke for the condition, all other arguments are to be passed as arguments to that function.\n    const [conditionNameIdentifier, ...agentFunctionArgs] = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // Our first argument MUST be defined and be an identifier as we require a condition name argument.\n    if (conditionNameIdentifier?.type !== \"identifier\") {\n        throw new Error(\"expected condition name identifier argument\");\n    }\n\n    // Return the condition node definition.\n    return {\n        type: \"condition\",\n        call: conditionNameIdentifier.value,\n        args: agentFunctionArgs.map(getArgumentJsonValue),\n        ...parseAttributeTokens(tokens, stringLiteralPlaceholders)\n    };\n}\n\n/**\n * Creates a wait node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The wait node JSON definition.\n */\nfunction createWaitNode(tokens: string[], stringLiteralPlaceholders: StringLiteralPlaceholders): WaitNodeDefinition {\n    const node = { type: \"wait\" } as WaitNodeDefinition;\n\n    // Get the node arguments.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // The arguments of a wait node are optional. We may have:\n    // - No node arguments, in which case the wait will be indefinite until it is aborted.\n    // - One node argument which will be the explicit duration of the wait.\n    // - Two node arguments which define the min and max duration bounds from which a random duration will be picked.\n    if (nodeArguments.length) {\n        // All wait node arguments MUST be of type number and must be integer.\n        nodeArguments\n            .filter((arg) => arg.type !== \"number\" || !arg.isInteger)\n            .forEach(() => {\n                throw new Error(`wait node durations must be integer values`);\n            });\n\n        // We may have:\n        // - One node argument which will be the explicit duration of the wait.\n        // - Two node arguments which define the min and max duration bounds from which a random duration will be picked.\n        // - Too many arguments, which is not valid.\n        if (nodeArguments.length === 1) {\n            // An explicit duration was defined.\n            node.duration = nodeArguments[0].value as number;\n\n            // If an explict duration was defined then it must be a positive number.\n            if (node.duration < 0) {\n                throw new Error(\"a wait node must have a positive duration\");\n            }\n        } else if (nodeArguments.length === 2) {\n            // Min and max duration bounds were defined from which a random duration will be picked.\n            node.duration = [nodeArguments[0].value as number, nodeArguments[1].value as number];\n\n            // A wait node must have a positive min and max duration.\n            if (node.duration[0] < 0 || node.duration[1] < 0) {\n                throw new Error(\"a wait node must have a positive minimum and maximum duration\");\n            }\n\n            // A wait node must not have a minimum duration that exceeds the maximum duration.\n            if (node.duration[0] > node.duration[1]) {\n                throw new Error(\"a wait node must not have a minimum duration that exceeds the maximum duration\");\n            }\n        } else if (nodeArguments.length > 2) {\n            // An incorrect number of duration arguments were defined.\n            throw new Error(\"invalid number of wait node duration arguments defined\");\n        }\n    }\n\n    // Return the wait node definition.\n    return { ...node, ...parseAttributeTokens(tokens, stringLiteralPlaceholders) };\n}\n\n/**\n * Creates a branch node JSON definition.\n * @param tokens The tree definition tokens.\n * @param stringLiteralPlaceholders The substituted string literal placeholders.\n * @returns The branch node JSON definition.\n */\nfunction createBranchNode(\n    tokens: string[],\n    stringLiteralPlaceholders: StringLiteralPlaceholders\n): BranchNodeDefinition {\n    // Parse any node arguments, we should have one which will be an identifier argument for the root ref.\n    const nodeArguments = parseArgumentTokens(tokens, stringLiteralPlaceholders);\n\n    // We should have only a single identifer argument for a branch node, which is the root ref.\n    if (nodeArguments.length !== 1 || nodeArguments[0].type !== \"identifier\") {\n        throw new Error(\"expected single branch name argument\");\n    }\n\n    // Return the branch node definition.\n    return { type: \"branch\", ref: nodeArguments[0].value };\n}\n\n/**\n * Validate a fully-populated node definition that was popped off of the tree stack.\n * @param definition The popped node to validate.\n */\nfunction validatePoppedNode(definition: AnyNodeDefinition): void {\n    // Decorators MUST have a child defined.\n    if (isDecoratorNodeDefinition(definition) && isNullOrUndefined(definition.child)) {\n        throw new Error(`a ${definition.type} node must have a single child node defined`);\n    }\n\n    // Composites MUST have at least one child defined.\n    if (isCompositeNodeDefinition(definition) && !definition.children?.length) {\n        throw new Error(`a ${definition.type} node must have at least a single child node defined`);\n    }\n\n    // We need to make sure that lotto nodes that have weights defined have a number of weights matching the number of child nodes.\n    if (definition.type === \"lotto\") {\n        // Check whether a 'weights' property has been defined, if it has we expect it to be an array of weights.\n        if (typeof definition.weights !== \"undefined\") {\n            // Check that the weights property is an array of positive integers with an element for each child node element.\n            if (definition.weights.length !== definition.children.length) {\n                throw new Error(\n                    \"expected a number of weight arguments matching the number of child nodes for lotto node\"\n                );\n            }\n        }\n    }\n}\n", "import { RootNodeDefinition } from \"./BehaviourTreeDefinition\";\nimport { flattenDefinition, isBranchNodeDefinition, isInteger } from \"./BehaviourTreeDefinitionUtilities\";\nimport { convertMDSLToJSON } from \"./mdsl/MDSLDefinitionParser\";\n\n/**\n * An object representing the result of validating a tree definition.\n */\nexport type DefinitionValidationResult = {\n    /**\n     * A flag defining whether validation succeeded.\n     */\n    succeeded: boolean;\n    /**\n     * A string containing the error message if validation did not succeed.\n     */\n    errorMessage?: string;\n    /**\n     * The definition as json if the validation was successful, or undefined if validation did not succeed.\n     */\n    json?: RootNodeDefinition[];\n};\n\n/**\n * Validates the specified behaviour tree definition in the form of JSON or MDSL, not taking any globally registered subtrees into consideration.\n * @param definition The behaviour tree definition in the form of JSON or MDSL.\n * @returns An object representing the result of validating the given tree definition.\n */\nexport function validateDefinition(definition: any): DefinitionValidationResult {\n    // The definition must be defined.\n    if (definition === null || typeof definition === \"undefined\") {\n        return createValidationFailureResult(\"definition is null or undefined\");\n    }\n\n    // We are expecting a definition in one of three different forms:\n    // - A string which we will assume is MDSL and we will parse this to JSON before validation.\n    // - An array which we will assume is an array of root node definitions with at least one being the primary root node (no 'id' property)\n    // - An object which we will assume is the primary root node and should not have an 'id' property.\n    if (typeof definition === \"string\") {\n        // The definition is a string which we can assume is MDSL, so attempt to validate it.\n        return validateMDSLDefinition(definition);\n    } else if (typeof definition === \"object\") {\n        // The definition will either be an array (of root node definitions) or an object (the single primary root node definition).\n        return validateJSONDefinition(definition);\n    } else {\n        return createValidationFailureResult(`unexpected definition type of '${typeof definition}'`);\n    }\n}\n\n/**\n * Validates the specified behaviour tree definition in the form of MDSL.\n * @param definition The behaviour tree definition in the form of MDSL.\n * @returns An object representing the result of validating the given tree definition.\n */\nfunction validateMDSLDefinition(definition: string): DefinitionValidationResult {\n    let rootNodeDefinitions;\n\n    // The first thing the we need to do is to attempt to convert our MDSL into JSON.\n    try {\n        // The definition is a string which we can assume is MDSL, so attempt to parse it to a JSON definition in the form of an array of root node definitions.\n        rootNodeDefinitions = convertMDSLToJSON(definition);\n    } catch (exception) {\n        // We failed to parse the JSON from the MDSL, this is likely to be the result of it not being a valid MDSL string.\n        return createValidationFailureResult((exception as Error).message);\n    }\n\n    // Unpack all of the root node definitions into arrays of main ('id' defined) and sub ('id' not defined) root node definitions.\n    const mainRootNodeDefinitions = rootNodeDefinitions.filter(({ id }) => typeof id === \"undefined\");\n    const subRootNodeDefinitions = rootNodeDefinitions.filter(({ id }) => typeof id === \"string\" && id.length > 0);\n\n    // We should ALWAYS have exactly one root node definition without an 'id' property defined, which is out main root node definition.\n    if (mainRootNodeDefinitions.length !== 1) {\n        return createValidationFailureResult(\n            \"expected single unnamed root node at base of definition to act as main root\"\n        );\n    }\n\n    // We should never have duplicate 'id' properties across our sub root node definitions.\n    const subRootNodeIdenitifers: string[] = [];\n    for (const { id } of subRootNodeDefinitions) {\n        // Have we already come across this 'id' property value?\n        if (subRootNodeIdenitifers.includes(id!)) {\n            return createValidationFailureResult(`multiple root nodes found with duplicate name '${id}'`);\n        }\n\n        subRootNodeIdenitifers.push(id!);\n    }\n\n    try {\n        // Validate our branch -> subtree links and check for any circular dependencies, we don't care about checking for broken subtree links here.\n        validateBranchSubtreeLinks(rootNodeDefinitions, false);\n    } catch (exception) {\n        return createValidationFailureResult((exception as Error).message);\n    }\n\n    // Our definition was valid!\n    return {\n        succeeded: true,\n        json: rootNodeDefinitions\n    };\n}\n\n/**\n * Validates the specified behaviour tree definition in the form of JSON.\n * @param definition The behaviour tree definition in the form of JSON.\n * @returns An object representing the result of validating the given tree definition.\n */\nexport function validateJSONDefinition(\n    definition: RootNodeDefinition | RootNodeDefinition[]\n): DefinitionValidationResult {\n    // The definition will either be an array (of root node definitions) or an object (the single primary root node definition).\n    const rootNodeDefinitions = Array.isArray(definition) ? definition : [definition];\n\n    // Iterate over our array of root nodes and call validateNode for each, passing an initial depth of 0, wrapped in a try catch to handle validation failures.\n    try {\n        rootNodeDefinitions.forEach((rootNodeDefinition) => validateNode(rootNodeDefinition, 0));\n    } catch (error) {\n        // Handle cases where we have caught a thrown Error and return a failure result with the error message.\n        if (error instanceof Error) {\n            return createValidationFailureResult(error.message);\n        }\n\n        // No idea what happened here!\n        return createValidationFailureResult(`unexpected error: ${error}`);\n    }\n\n    // Unpack all of the root node definitions into arrays of main ('id' defined) and sub ('id' not defined) root node definitions.\n    const mainRootNodeDefinitions = rootNodeDefinitions.filter(({ id }) => typeof id === \"undefined\");\n    const subRootNodeDefinitions = rootNodeDefinitions.filter(({ id }) => typeof id === \"string\" && id.length > 0);\n\n    // We should ALWAYS have exactly one root node definition without an 'id' property defined, which is out main root node definition.\n    if (mainRootNodeDefinitions.length !== 1) {\n        return createValidationFailureResult(\n            \"expected single root node without 'id' property defined to act as main root\"\n        );\n    }\n\n    // We should never have duplicate 'id' properties across our sub root node definitions.\n    const subRootNodeIdenitifers: string[] = [];\n    for (const { id } of subRootNodeDefinitions) {\n        // Have we already come across this 'id' property value?\n        if (subRootNodeIdenitifers.includes(id!)) {\n            return createValidationFailureResult(\n                `multiple root nodes found with duplicate 'id' property value of '${id}'`\n            );\n        }\n\n        subRootNodeIdenitifers.push(id!);\n    }\n\n    try {\n        // Validate our branch -> subtree links and check for any circular dependencies, we don't care about checking for broken subtree links here.\n        validateBranchSubtreeLinks(rootNodeDefinitions, false);\n    } catch (exception) {\n        return createValidationFailureResult((exception as Error).message);\n    }\n\n    // Our definition was valid!\n    return {\n        succeeded: true,\n        json: rootNodeDefinitions\n    };\n}\n\n/**\n * Validates the branch -> subtree links across all provided root node definitions.\n * This will not consider branch nodes that reference any globally registered subtrees unless includesGlobalSubtrees\n * is set to true, in which case we will also verify that there are no broken branch -> subtree links.\n * @param rootNodeDefinitions The array of root node definitions.\n * @param includesGlobalSubtrees A flag defining whether the array includes all global subtree root node definitions.\n */\nexport function validateBranchSubtreeLinks(rootNodeDefinitions: RootNodeDefinition[], includesGlobalSubtrees: boolean) {\n    // Create a mapping of root node identifiers to other root nodes that they reference via branch nodes.\n    // Below is an example of a mapping that includes a circular dependency (root => a => b => c => a)\n    // [{ refs: [\"a\", \"b\"] }, { id: \"a\", refs: [\"b\"] }, { id: \"b\", refs: [\"c\"] }, { id: \"c\", refs: [\"a\"] }]\n    const rootNodeMappings: { id: string | undefined; refs: string[] }[] = rootNodeDefinitions.map(\n        (rootNodeDefinition) => ({\n            id: rootNodeDefinition.id,\n            refs: flattenDefinition(rootNodeDefinition)\n                .filter(isBranchNodeDefinition)\n                .map(({ ref }) => ref)\n        })\n    );\n\n    // A recursive function to walk through the mappings, keeping track of which root nodes we have visited in the form of a path of root node identifiers.\n    const followRefs = (mapping: { id: string | undefined; refs: string[] }, path: (string | undefined)[] = []) => {\n        // Have we found a circular dependency?\n        if (path.includes(mapping.id)) {\n            // We found a circular dependency! Get the bad path of root node identifiers.\n            const badPath = [...path, mapping.id];\n\n            // Create the formatted path value. [undefined, \"a\", \"b\", \"c\", \"a\"] would be formatted as \"a -> b -> c -> a\".\n            const badPathFormatted = badPath.filter((element) => !!element).join(\" => \");\n\n            // No need to continue, we found a circular dependency.\n            throw new Error(`circular dependency found in branch node references: ${badPathFormatted}`);\n        }\n\n        for (const ref of mapping.refs) {\n            // Find the mapping for the root node with an identifer matching the current ref.\n            const subMapping = rootNodeMappings.find(({ id }) => id === ref);\n\n            // We may not have a mapping for this ref, which is normal when we aren't considering all globally registered subtrees.\n            if (subMapping) {\n                followRefs(subMapping, [...path, mapping.id]);\n            } else if (includesGlobalSubtrees) {\n                // We found a reference to a root node that doesn't exist, which is a problem seeing as the root node definitons includes all globally registered subtrees.\n                throw new Error(\n                    mapping.id\n                        ? `subtree '${mapping.id}' has branch node that references root node '${ref}' which has not been defined`\n                        : `primary tree has branch node that references root node '${ref}' which has not been defined`\n                );\n            }\n        }\n    };\n\n    // Start looking for circular dependencies and broken references from the primary root node definition.\n    followRefs(rootNodeMappings.find((mapping) => typeof mapping.id === \"undefined\")!);\n}\n\n/**\n * Validate an object that we expect to be a node definition.\n * @param definition An object that we expect to be a node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateNode(definition: any, depth: number): void {\n    // Every node must be valid object and have a non-empty 'type' string property.\n    if (typeof definition !== \"object\" || typeof definition.type !== \"string\" || definition.type.length === 0) {\n        throw new Error(\n            `node definition is not an object or 'type' property is not a non-empty string at depth '${depth}'`\n        );\n    }\n\n    // If this node is at the very base of the definition then it MUST be a root node.\n    if (depth === 0 && definition.type !== \"root\") {\n        throw new Error(`expected root node at base of definition but got node of type '${definition.type}'`);\n    }\n\n    // How we validate this node definition will depend on its type.\n    switch (definition.type) {\n        case \"action\":\n            validateActionNode(definition, depth);\n            break;\n\n        case \"condition\":\n            validateConditionNode(definition, depth);\n            break;\n\n        case \"wait\":\n            validateWaitNode(definition, depth);\n            break;\n\n        case \"branch\":\n            validateBranchNode(definition, depth);\n            break;\n\n        case \"root\":\n            validateRootNode(definition, depth);\n            break;\n\n        case \"succeed\":\n            validateSucceedNode(definition, depth);\n            break;\n\n        case \"fail\":\n            validateFailNode(definition, depth);\n            break;\n\n        case \"flip\":\n            validateFlipNode(definition, depth);\n            break;\n\n        case \"repeat\":\n            validateRepeatNode(definition, depth);\n            break;\n\n        case \"retry\":\n            validateRetryNode(definition, depth);\n            break;\n\n        case \"sequence\":\n            validateSequenceNode(definition, depth);\n            break;\n\n        case \"selector\":\n            validateSelectorNode(definition, depth);\n            break;\n\n        case \"parallel\":\n            validateParallelNode(definition, depth);\n            break;\n\n        case \"race\":\n            validateRaceNode(definition, depth);\n            break;\n\n        case \"all\":\n            validateAllNode(definition, depth);\n            break;\n\n        case \"lotto\":\n            validateLottoNode(definition, depth);\n            break;\n\n        default:\n            throw new Error(`unexpected node type of '${definition.type}' at depth '${depth}'`);\n    }\n}\n\n/**\n * Validate any attributes for a given node definition.\n * @param definition The node definition.\n * @param depth The depth of the node in the behaviour tree definition.\n */\nfunction validateNodeAttributes(definition: any, depth: number): void {\n    // Validate each of the attribute types for this node.\n    [\"while\", \"until\", \"entry\", \"exit\", \"step\"].forEach((attributeName) => {\n        // Attempt to grab the definition for the current attribute from the node definition.\n        const attributeDefinition = definition[attributeName];\n\n        // All node attributes are optional, so there is nothing to do if the current attribute is not defined.\n        if (typeof attributeDefinition === \"undefined\") {\n            return;\n        }\n\n        // The attribute definition must be an object.\n        if (typeof attributeDefinition !== \"object\") {\n            throw new Error(\n                `expected attribute '${attributeName}' to be an object for '${definition.type}' node at depth '${depth}'`\n            );\n        }\n\n        // The 'call' property must be defined for any attribute definition.\n        if (typeof attributeDefinition.call !== \"string\" || attributeDefinition.call.length === 0) {\n            throw new Error(\n                `expected 'call' property for attribute '${attributeName}' to be a non-empty string for '${definition.type}' node at depth '${depth}'`\n            );\n        }\n\n        // If any node attribute arguments have been defined then they must have been defined in an array.\n        if (typeof attributeDefinition.args !== \"undefined\" && !Array.isArray(attributeDefinition.args)) {\n            throw new Error(\n                `expected 'args' property for attribute '${attributeName}' to be an array for '${definition.type}' node at depth '${depth}'`\n            );\n        }\n    });\n}\n\n/**\n * Validate an object that we expect to be a root node definition.\n * @param definition An object that we expect to be a root node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateRootNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"root\") {\n        throw new Error(\"expected node type of 'root' for root node\");\n    }\n\n    // A root node cannot be the child of another node.\n    if (depth > 0) {\n        throw new Error(\"a root node cannot be the child of another node\");\n    }\n\n    // Check that, if the root node 'id' property is defined, it is a non-empty string.\n    if (typeof definition.id !== \"undefined\" && (typeof definition.id !== \"string\" || definition.id.length === 0)) {\n        throw new Error(\"expected non-empty string for 'id' property if defined for root node\");\n    }\n\n    // A root node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(\"expected property 'child' to be defined for root node\");\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a succeed node definition.\n * @param definition An object that we expect to be a succeed node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateSucceedNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"succeed\") {\n        throw new Error(`expected node type of 'succeed' for succeed node at depth '${depth}'`);\n    }\n\n    // A succeed node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for succeed node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a fail node definition.\n * @param definition An object that we expect to be a fail node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateFailNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"fail\") {\n        throw new Error(`expected node type of 'fail' for fail node at depth '${depth}'`);\n    }\n\n    // A fail node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for fail node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a flip node definition.\n * @param definition An object that we expect to be a flip node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateFlipNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"flip\") {\n        throw new Error(`expected node type of 'flip' for flip node at depth '${depth}'`);\n    }\n\n    // A flip node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for flip node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a repeat node definition.\n * @param definition An object that we expect to be a repeat node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateRepeatNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"repeat\") {\n        throw new Error(`expected node type of 'repeat' for repeat node at depth '${depth}'`);\n    }\n\n    // A repeat node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for repeat node at depth '${depth}'`);\n    }\n\n    // Check whether an 'iterations' property has been defined, it may not have been if this node is to repeat indefinitely.\n    if (typeof definition.iterations !== \"undefined\") {\n        if (Array.isArray(definition.iterations)) {\n            // Check whether any elements of the array are not integer values.\n            const containsNonInteger = !!definition.iterations.filter((value: unknown) => !isInteger(value)).length;\n\n            // If the 'iterations' property is an array then it MUST contain two integer values.\n            if (definition.iterations.length !== 2 || containsNonInteger) {\n                throw new Error(\n                    `expected array containing two integer values for 'iterations' property if defined for repeat node at depth '${depth}'`\n                );\n            }\n\n            // A repeat node must have a positive min and max iterations count if they are defined.\n            if (definition.iterations[0] < 0 || definition.iterations[1] < 0) {\n                throw new Error(\n                    `expected positive minimum and maximum iterations count for 'iterations' property if defined for repeat node at depth '${depth}'`\n                );\n            }\n\n            // A repeat node must not have a minimum iterations count that exceeds the maximum iterations count.\n            if (definition.iterations[0] > definition.iterations[1]) {\n                throw new Error(\n                    `expected minimum iterations count that does not exceed the maximum iterations count for 'iterations' property if defined for repeat node at depth '${depth}'`\n                );\n            }\n        } else if (isInteger(definition.iterations)) {\n            // A repeat node must have a positive number of iterations if defined.\n            if (definition.iterations < 0) {\n                throw new Error(\n                    `expected positive iterations count for 'iterations' property if defined for repeat node at depth '${depth}'`\n                );\n            }\n        } else {\n            throw new Error(\n                `expected integer value or array containing two integer values for 'iterations' property if defined for repeat node at depth '${depth}'`\n            );\n        }\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a retry node definition.\n * @param definition An object that we expect to be a retry node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateRetryNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"retry\") {\n        throw new Error(`expected node type of 'retry' for retry node at depth '${depth}'`);\n    }\n\n    // A retry node is a decorator node, so must have a child node defined.\n    if (typeof definition.child === \"undefined\") {\n        throw new Error(`expected property 'child' to be defined for retry node at depth '${depth}'`);\n    }\n\n    // Check whether an 'attempts' property has been defined, it may not have been if this node is to retry indefinitely.\n    if (typeof definition.attempts !== \"undefined\") {\n        if (Array.isArray(definition.attempts)) {\n            // Check whether any elements of the array are not integer values.\n            const containsNonInteger = !!definition.attempts.filter((value: unknown) => !isInteger(value)).length;\n\n            // If the 'attempts' property is an array then it MUST contain two integer values.\n            if (definition.attempts.length !== 2 || containsNonInteger) {\n                throw new Error(\n                    `expected array containing two integer values for 'attempts' property if defined for retry node at depth '${depth}'`\n                );\n            }\n\n            // A retry node must have a positive min and max attempts count if they are defined.\n            if (definition.attempts[0] < 0 || definition.attempts[1] < 0) {\n                throw new Error(\n                    `expected positive minimum and maximum attempts count for 'attempts' property if defined for retry node at depth '${depth}'`\n                );\n            }\n\n            // A retry node must not have a minimum attempts count that exceeds the maximum attempts count.\n            if (definition.attempts[0] > definition.attempts[1]) {\n                throw new Error(\n                    `expected minimum attempts count that does not exceed the maximum attempts count for 'attempts' property if defined for retry node at depth '${depth}'`\n                );\n            }\n        } else if (isInteger(definition.attempts)) {\n            // A retry node must have a positive number of attempts if defined.\n            if (definition.attempts < 0) {\n                throw new Error(\n                    `expected positive attempts count for 'attempts' property if defined for retry node at depth '${depth}'`\n                );\n            }\n        } else {\n            throw new Error(\n                `expected integer value or array containing two integer values for 'attempts' property if defined for retry node at depth '${depth}'`\n            );\n        }\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child node of this decorator node.\n    validateNode(definition.child, depth + 1);\n}\n\n/**\n * Validate an object that we expect to be a branch node definition.\n * @param definition An object that we expect to be a branch node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateBranchNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"branch\") {\n        throw new Error(`expected node type of 'branch' for branch node at depth '${depth}'`);\n    }\n\n    // Check that the branch node 'ref' property is defined and is a non-empty string.\n    if (typeof definition.ref !== \"string\" || definition.ref.length === 0) {\n        throw new Error(`expected non-empty string for 'ref' property for branch node at depth '${depth}'`);\n    }\n\n    // It is invalid to define guard attributes for a branch node as they should be defined on the referenced root node.\n    [\"while\", \"until\"].forEach((attributeName) => {\n        if (typeof definition[attributeName] !== \"undefined\") {\n            throw new Error(\n                `guards should not be defined for branch nodes but guard '${attributeName}' was defined for branch node at depth '${depth}'`\n            );\n        }\n    });\n\n    // It is invalid to define callback attributes for a branch node as they should be defined on the referenced root node.\n    [\"entry\", \"exit\", \"step\"].forEach((attributeName) => {\n        if (typeof definition[attributeName] !== \"undefined\") {\n            throw new Error(\n                `callbacks should not be defined for branch nodes but callback '${attributeName}' was defined for branch node at depth '${depth}'`\n            );\n        }\n    });\n}\n\n/**\n * Validate an object that we expect to be a action node definition.\n * @param definition An object that we expect to be a action node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateActionNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"action\") {\n        throw new Error(`expected node type of 'action' for action node at depth '${depth}'`);\n    }\n\n    // The 'call' property must be defined for a action node definition.\n    if (typeof definition.call !== \"string\" || definition.call.length === 0) {\n        throw new Error(`expected non-empty string for 'call' property of action node at depth '${depth}'`);\n    }\n\n    // If any action function arguments have been defined then they must have been defined in an array.\n    if (typeof definition.args !== \"undefined\" && !Array.isArray(definition.args)) {\n        throw new Error(`expected array for 'args' property if defined for action node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n}\n\n/**\n * Validate an object that we expect to be a condition node definition.\n * @param definition An object that we expect to be a condition node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateConditionNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"condition\") {\n        throw new Error(`expected node type of 'condition' for condition node at depth '${depth}'`);\n    }\n\n    // The 'call' property must be defined for a condition node definition.\n    if (typeof definition.call !== \"string\" || definition.call.length === 0) {\n        throw new Error(`expected non-empty string for 'call' property of condition node at depth '${depth}'`);\n    }\n\n    // If any condition function arguments have been defined then they must have been defined in an array.\n    if (typeof definition.args !== \"undefined\" && !Array.isArray(definition.args)) {\n        throw new Error(`expected array for 'args' property if defined for condition node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n}\n\n/**\n * Validate an object that we expect to be a wait node definition.\n * @param definition An object that we expect to be a wait node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateWaitNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"wait\") {\n        throw new Error(`expected node type of 'wait' for wait node at depth '${depth}'`);\n    }\n\n    // Check whether a 'duration' property has been defined, it may not have been if this node is to wait indefinitely.\n    if (typeof definition.duration !== \"undefined\") {\n        if (Array.isArray(definition.duration)) {\n            // Check whether any elements of the array are not integer values.\n            const containsNonInteger = !!definition.duration.filter((value: unknown) => !isInteger(value)).length;\n\n            // If the 'duration' property is an array then it MUST contain two integer values.\n            if (definition.duration.length !== 2 || containsNonInteger) {\n                throw new Error(\n                    `expected array containing two integer values for 'duration' property if defined for wait node at depth '${depth}'`\n                );\n            }\n\n            // A wait node must have a positive min and max duration value if they are defined.\n            if (definition.duration[0] < 0 || definition.duration[1] < 0) {\n                throw new Error(\n                    `expected positive minimum and maximum duration for 'duration' property if defined for wait node at depth '${depth}'`\n                );\n            }\n\n            // A wait node must not have a minimum duration value that exceeds the maximum duration value.\n            if (definition.duration[0] > definition.duration[1]) {\n                throw new Error(\n                    `expected minimum duration value that does not exceed the maximum duration value for 'duration' property if defined for wait node at depth '${depth}'`\n                );\n            }\n        } else if (isInteger(definition.duration)) {\n            // A wait node must have a positive duration value if defined.\n            if (definition.duration < 0) {\n                throw new Error(\n                    `expected positive duration value for 'duration' property if defined for wait node at depth '${depth}'`\n                );\n            }\n        } else {\n            throw new Error(\n                `expected integer value or array containing two integer values for 'duration' property if defined for wait node at depth '${depth}'`\n            );\n        }\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n}\n\n/**\n * Validate an object that we expect to be a sequence node definition.\n * @param definition An object that we expect to be a sequence node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateSequenceNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"sequence\") {\n        throw new Error(`expected node type of 'sequence' for sequence node at depth '${depth}'`);\n    }\n\n    // A sequence node is a composite node, so must have a children nodes array defined.\n    if (!Array.isArray(definition.children) || definition.children.length === 0) {\n        throw new Error(`expected non-empty 'children' array to be defined for sequence node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child nodes of this composite node.\n    definition.children.forEach((child: any) => validateNode(child, depth + 1));\n}\n\n/**\n * Validate an object that we expect to be a selector node definition.\n * @param definition An object that we expect to be a selector node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateSelectorNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"selector\") {\n        throw new Error(`expected node type of 'selector' for selector node at depth '${depth}'`);\n    }\n\n    // A selector node is a composite node, so must have a children nodes array defined.\n    if (!Array.isArray(definition.children) || definition.children.length === 0) {\n        throw new Error(`expected non-empty 'children' array to be defined for selector node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child nodes of this composite node.\n    definition.children.forEach((child: any) => validateNode(child, depth + 1));\n}\n\n/**\n * Validate an object that we expect to be a parallel node definition.\n * @param definition An object that we expect to be a parallel node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateParallelNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"parallel\") {\n        throw new Error(`expected node type of 'parallel' for parallel node at depth '${depth}'`);\n    }\n\n    // A parallel node is a composite node, so must have a children nodes array defined.\n    if (!Array.isArray(definition.children) || definition.children.length === 0) {\n        throw new Error(`expected non-empty 'children' array to be defined for parallel node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child nodes of this composite node.\n    definition.children.forEach((child: any) => validateNode(child, depth + 1));\n}\n\n/**\n * Validate an object that we expect to be a race node definition.\n * @param definition An object that we expect to be a race node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateRaceNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"race\") {\n        throw new Error(`expected node type of 'race' for race node at depth '${depth}'`);\n    }\n\n    // A race node is a composite node, so must have a children nodes array defined.\n    if (!Array.isArray(definition.children) || definition.children.length === 0) {\n        throw new Error(`expected non-empty 'children' array to be defined for race node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child nodes of this composite node.\n    definition.children.forEach((child: any) => validateNode(child, depth + 1));\n}\n\n/**\n * Validate an object that we expect to be an all node definition.\n * @param definition An object that we expect to be an all node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateAllNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"all\") {\n        throw new Error(`expected node type of 'all' for all node at depth '${depth}'`);\n    }\n\n    // A all node is a composite node, so must have a children nodes array defined.\n    if (!Array.isArray(definition.children) || definition.children.length === 0) {\n        throw new Error(`expected non-empty 'children' array to be defined for all node at depth '${depth}'`);\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child nodes of this composite node.\n    definition.children.forEach((child: any) => validateNode(child, depth + 1));\n}\n\n/**\n * Validate an object that we expect to be a lotto node definition.\n * @param definition An object that we expect to be a lotto node definition.\n * @param depth The depth of the node in the definition tree.\n */\nfunction validateLottoNode(definition: any, depth: number): void {\n    // Check that the node type is correct.\n    if (definition.type !== \"lotto\") {\n        throw new Error(`expected node type of 'lotto' for lotto node at depth '${depth}'`);\n    }\n\n    // A lotto node is a composite node, so must have a children nodes array defined.\n    if (!Array.isArray(definition.children) || definition.children.length === 0) {\n        throw new Error(`expected non-empty 'children' array to be defined for lotto node at depth '${depth}'`);\n    }\n\n    // Check whether a 'weights' property has been defined, if it has we expect it to be an array of weights.\n    if (typeof definition.weights !== \"undefined\") {\n        // Check that the weights property is an array of positive integers with an element for each child node element.\n        if (\n            !Array.isArray(definition.weights) ||\n            definition.weights.length !== definition.children.length ||\n            definition.weights.filter((value: unknown) => !isInteger(value)).length ||\n            definition.weights.filter((value: number) => value < 0).length\n        ) {\n            throw new Error(\n                `expected an array of positive integer weight values with a length matching the number of child nodes for 'weights' property if defined for lotto node at depth '${depth}'`\n            );\n        }\n    }\n\n    // Validate the node attributes.\n    validateNodeAttributes(definition, depth);\n\n    // Validate the child nodes of this composite node.\n    definition.children.forEach((child: any) => validateNode(child, depth + 1));\n}\n\n/**\n * A helper function to create a failure validation result with the given error message.\n * @param errorMessage The validation failure error message.\n * @returns A failure validation result with the given error message.\n */\nfunction createValidationFailureResult(errorMessage: string): DefinitionValidationResult {\n    return { succeeded: false, errorMessage };\n}\n", "import Node from \"../../nodes/Node\";\nimport Guard from \"./Guard\";\n\n/**\n * An exception thrown when evaluating node guard path conditions and a conditions fails.\n */\nexport default class GuardUnsatisifedException extends Error {\n    /**\n     * @param source The node at which a guard condition failed.\n     * @param guard The guard.\n     */\n    constructor(private source: Node, public guard: Guard) {\n        super(\"A guard path condition has failed\");\n    }\n\n    /**\n     * Gets whether the specified node is the node at which a guard condition failed.\n     * @param node The node to check against the source node.\n     * @returns Whether the specified node is the node at which a guard condition failed.\n     */\n    public isSourceNode(node: Node): boolean {\n        return node === this.source;\n    }\n}\n", "import { Agent } from \"../../Agent\";\nimport Guard from \"./Guard\";\nimport Node from \"../../nodes/Node\";\nimport GuardUnsatisifedException from \"./GuardUnsatisifedException\";\n\nexport type GuardPathPart = {\n    node: Node;\n    guards: Guard[];\n};\n\n/**\n * Represents a path of node guards along a root-to-leaf tree path.\n */\nexport default class GuardPath {\n    /**\n     * @param nodes An array of objects defining a node instance -> guard link, ordered by node depth.\n     */\n    constructor(private nodes: GuardPathPart[]) {}\n\n    /**\n     * Evaluate guard conditions for all guards in the tree path, moving outwards from the root.\n     * @param agent The agent, required for guard evaluation.\n     * @returns An evaluation results object.\n     */\n    public evaluate(agent: Agent): void {\n        // We need to evaluate guard conditions for nodes up the tree, moving outwards from the root.\n        for (const details of this.nodes) {\n            // There can be multiple guards per node.\n            for (const guard of details.guards) {\n                // Check whether the guard condition passes, and throw an exception if not.\n                if (!guard.isSatisfied(agent)) {\n                    throw new GuardUnsatisifedException(details.node, guard);\n                }\n            }\n        }\n    }\n}\n", "/**\n * Create a randomly generated node uid.\n * @returns A randomly generated node uid.\n */\nexport function createUid(): string {\n    const S4 = function () {\n        return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n    };\n    return S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4();\n}\n", "import { BehaviourTreeOptions } from \"../BehaviourTreeOptions\";\nimport State, { AnyState } from \"../State\";\nimport { Agent } from \"../Agent\";\nimport Leaf from \"./leaf/Leaf\";\nimport Attribute from \"../attributes/Attribute\";\nimport Entry from \"../attributes/callbacks/Entry\";\nimport Exit from \"../attributes/callbacks/Exit\";\nimport Step from \"../attributes/callbacks/Step\";\nimport While from \"../attributes/guards/While\";\nimport Until from \"../attributes/guards/Until\";\nimport GuardPath from \"../attributes/guards/GuardPath\";\nimport GuardUnsatisifedException from \"../attributes/guards/GuardUnsatisifedException\";\nimport { GuardAttributeDetails } from \"../attributes/guards/Guard\";\nimport { CallbackAttributeDetails } from \"../attributes/callbacks/Callback\";\nimport { createUid } from \"../Utilities\";\n\n/**\n * Details of a tree node instance.\n */\nexport type NodeDetails = {\n    /**\n     * The tree node identifier.\n     */\n    id: string;\n    /**\n     * The tree node type.\n     */\n    type: string;\n    /**\n     * The tree node name.\n     */\n    name: string;\n    /**\n     * The current state of the tree node.\n     */\n    state: AnyState;\n    /**\n     * The array of agent or globally registered function arguments, defined if this is an action or condition node.\n     */\n    args?: any[];\n    /**\n     * The 'while' guard attribute configured for this node.\n     */\n    while?: GuardAttributeDetails;\n    /**\n     * The 'until' guard attribute configured for this node.\n     */\n    until?: GuardAttributeDetails;\n    /**\n     * The 'entry' callback attribute configured for this node.\n     */\n    entry?: CallbackAttributeDetails;\n    /**\n     * The 'step' callback attribute configured for this node.\n     */\n    step?: CallbackAttributeDetails;\n    /**\n     * The 'exit' callback attribute configured for this node.\n     */\n    exit?: CallbackAttributeDetails;\n    /**\n     * The array of the child nodes of this node, defined if this node is a composite or decorator node.\n     */\n    children?: NodeDetails[];\n};\n\n/**\n * A mapping of attribute names to attributes configured for a node.\n */\ntype Attributes = {\n    /**\n     * The 'entry' callback attribute configured for this node.\n     */\n    entry?: Entry;\n    /**\n     * The 'step' callback attribute configured for this node.\n     */\n    step?: Step;\n    /**\n     * The 'exit' callback attribute configured for this node.\n     */\n    exit?: Exit;\n    /**\n     * The 'while' guard attribute configured for this node.\n     */\n    while?: While;\n    /**\n     * The 'until' guard attribute configured for this node.\n     */\n    until?: Until;\n};\n\n/**\n * A base node.\n */\nexport default abstract class Node {\n    /**\n     * The node unique identifier.\n     */\n    protected readonly uid: string;\n    /**\n     * The node attributes.\n     */\n    protected readonly attributes: Attributes;\n    /**\n     * The node state.\n     */\n    private _state: AnyState = State.READY;\n    /**\n     * The guard path to evaluate as part of a node update.\n     */\n    private _guardPath: GuardPath | undefined;\n\n    /**\n     * @param type The node type.\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     */\n    constructor(private type: string, attributes: Attribute[], protected options: BehaviourTreeOptions) {\n        // Create a unique identifier for this node.\n        this.uid = createUid();\n\n        // Create our attribute mapping.\n        this.attributes = {\n            entry: attributes.find(({ type }) => type === \"entry\") as Entry,\n            step: attributes.find(({ type }) => type === \"step\") as Step,\n            exit: attributes.find(({ type }) => type === \"exit\") as Exit,\n            while: attributes.find(({ type }) => type === \"while\") as While,\n            until: attributes.find(({ type }) => type === \"until\") as Until\n        };\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected abstract onUpdate(agent: Agent): void;\n\n    /**\n     * Gets the name of the node.\n     */\n    public abstract getName(): string;\n\n    /**\n     * Gets/Sets the state of the node.\n     */\n    getState = (): AnyState => this._state;\n    setState = (value: AnyState): void => {\n        // Grab the original state of this node.\n        const previousState = this._state;\n\n        // Set the new node state.\n        this._state = value;\n\n        // If the state actually changed we should handle it.\n        if (previousState !== value) {\n            this.onStateChanged(previousState);\n        }\n    };\n\n    /**\n     * Gets the unique id of the node.\n     */\n    getUid = () => this.uid;\n\n    /**\n     * Gets the type of the node.\n     */\n    getType = () => this.type;\n\n    /**\n     * Gets the node attributes.\n     */\n    getAttributes = () => Object.values(this.attributes).filter((attribute) => !!attribute);\n\n    /**\n     * Sets the guard path to evaluate as part of a node update.\n     */\n    setGuardPath = (value: GuardPath) => (this._guardPath = value);\n\n    /**\n     * Gets whether a guard path is assigned to this node.\n     */\n    hasGuardPath = () => !!this._guardPath;\n\n    /**\n     * Gets whether this node is in the specified state.\n     * @param value The value to compare to the node state.\n     */\n    public is(value: AnyState): boolean {\n        return this._state === value;\n    }\n\n    /**\n     * Reset the state of the node.\n     */\n    public reset(): void {\n        this.setState(State.READY);\n    }\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    public abort(agent: Agent): void {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Reset the state of this node.\n        this.reset();\n\n        this.attributes.exit?.callAgentFunction(agent, false, true);\n    }\n\n    /**\n     * Update the node.\n     * @param agent The agent.\n     * @returns The result of the update.\n     */\n    public update(agent: Agent): void {\n        // If this node is already in a 'SUCCEEDED' or 'FAILED' state then there is nothing to do.\n        if (this.is(State.SUCCEEDED) || this.is(State.FAILED)) {\n            return;\n        }\n\n        try {\n            // Evaluate all of the guard path conditions for the current tree path.\n            this._guardPath!.evaluate(agent);\n\n            // If this node is in the READY state then call the ENTRY for this node if it exists.\n            if (this.is(State.READY)) {\n                this.attributes.entry?.callAgentFunction(agent);\n            }\n\n            this.attributes.step?.callAgentFunction(agent);\n\n            // Do the actual update.\n            this.onUpdate(agent);\n\n            // If this node is now in a 'SUCCEEDED' or 'FAILED' state then call the EXIT for this node if it exists.\n            if (this.is(State.SUCCEEDED) || this.is(State.FAILED)) {\n                this.attributes.exit?.callAgentFunction(agent, this.is(State.SUCCEEDED), false);\n            }\n        } catch (error) {\n            // If the error is a GuardUnsatisfiedException then we need to determine if this node is the source.\n            if (error instanceof GuardUnsatisifedException && error.isSourceNode(this)) {\n                // Abort the current node.\n                this.abort(agent);\n\n                // Any node that is the source of an abort will move to a resolved state.\n                this.setState(error.guard.succeedOnAbort ? State.SUCCEEDED : State.FAILED);\n            } else {\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Gets the details of this node instance.\n     * @returns The details of this node instance.\n     */\n    public getDetails(): NodeDetails {\n        return {\n            id: this.uid,\n            name: this.getName(),\n            type: this.type,\n            while: this.attributes.while?.getDetails(),\n            until: this.attributes.until?.getDetails(),\n            entry: this.attributes.entry?.getDetails(),\n            step: this.attributes.step?.getDetails(),\n            exit: this.attributes.exit?.getDetails(),\n            state: this._state\n        };\n    }\n\n    /**\n     * Called when the state of this node changes.\n     * @param previousState The previous node state.\n     */\n    protected onStateChanged(previousState: State): void {\n        // We should call the onNodeStateChange callback if it was defined.\n        this.options.onNodeStateChange?.({\n            id: this.uid,\n            type: this.type,\n            while: this.attributes.while?.getDetails(),\n            until: this.attributes.until?.getDetails(),\n            entry: this.attributes.entry?.getDetails(),\n            step: this.attributes.step?.getDetails(),\n            exit: this.attributes.exit?.getDetails(),\n            previousState,\n            state: this._state\n        });\n    }\n}\n", "import Node from \"../Node\";\n\n/**\n * A leaf node.\n */\nexport default abstract class Leaf extends Node {}\n", "import Node, { NodeDetails } from \"../Node\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A composite node that wraps child nodes.\n */\nexport default abstract class Composite extends Node {\n    /**\n     * @param type The node type.\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param children The child nodes.\n     */\n    constructor(type: string, attributes: Attribute[], options: BehaviourTreeOptions, protected children: Node[]) {\n        super(type, attributes, options);\n    }\n\n    /**\n     * Gets the children of this node.\n     */\n    getChildren = () => this.children;\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the state of any child nodes.\n        this.children.forEach((child) => child.reset());\n    };\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    abort = (agent: Agent) => {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Abort any child nodes.\n        this.children.forEach((child) => child.abort(agent));\n\n        // Reset the state of this node.\n        this.reset();\n\n        this.attributes.exit?.callAgentFunction(agent, false, true);\n    };\n\n    /**\n     * Gets the details of this node instance.\n     * @returns The details of this node instance.\n     */\n    public getDetails(): NodeDetails {\n        return {\n            ...super.getDetails(),\n            children: this.children.map((child) => child.getDetails())\n        };\n    }\n}\n", "import Composite from \"./Composite\";\nimport State from \"../../State\";\nimport Node from \"../Node\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A PARALLEL node.\n * The child nodes are executed concurrently until one fails or all succeed.\n */\nexport default class Parallel extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param children The child nodes.\n     */\n    constructor(attributes: Attribute[], options: BehaviourTreeOptions, children: Node[]) {\n        super(\"parallel\", attributes, options, children);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // Iterate over all of the children of this node, updating any that aren't in a settled state.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent);\n            }\n        }\n\n        // If any of our child nodes have failed then this node has also failed.\n        if (this.children.find((child) => child.is(State.FAILED))) {\n            // This node is a 'FAILED' node.\n            this.setState(State.FAILED);\n\n            // Abort every running child.\n            for (const child of this.children) {\n                if (child.getState() === State.RUNNING) {\n                    child.abort(agent);\n                }\n            }\n\n            return;\n        }\n\n        // A parallel node will move into the succeeded state if all child nodes move into the succeeded state.\n        if (this.children.every((child) => child.is(State.SUCCEEDED))) {\n            // This node is a 'SUCCEEDED' node.\n            this.setState(State.SUCCEEDED);\n\n            return;\n        }\n\n        // If we didn't move to a succeeded or failed state then this node is still running.\n        this.setState(State.RUNNING);\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"PARALLEL\";\n}\n", "import Composite from \"./Composite\";\nimport State from \"../../State\";\nimport Node from \"../Node\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A RACE node.\n * The child nodes are executed concurrently until one succeeds or all fail.\n */\nexport default class Race extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param children The child nodes.\n     */\n    constructor(attributes: Attribute[], options: BehaviourTreeOptions, children: Node[]) {\n        super(\"race\", attributes, options, children);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // Iterate over all of the children of this node, updating any that aren't in a settled state.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent);\n            }\n        }\n\n        // If any of our child nodes have succeeded then this node has also succeeded.\n        if (this.children.find((child) => child.is(State.SUCCEEDED))) {\n            // This node is a 'SUCCEEDED' node.\n            this.setState(State.SUCCEEDED);\n\n            // Abort every running child.\n            for (const child of this.children) {\n                if (child.getState() === State.RUNNING) {\n                    child.abort(agent);\n                }\n            }\n\n            return;\n        }\n\n        // A race node will move into the failed state if all child nodes move into the failed state as none can succeed.\n        if (this.children.every((child) => child.is(State.FAILED))) {\n            // This node is a 'FAILED' node.\n            this.setState(State.FAILED);\n\n            return;\n        }\n\n        // If we didn't move to a succeeded or failed state then this node is still running.\n        this.setState(State.RUNNING);\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"RACE\";\n}\n", "import Composite from \"./Composite\";\nimport State from \"../../State\";\nimport Node from \"../Node\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * An ALL node.\n * The child nodes are executed concurrently until all child nodes move to a completed state.\n */\nexport default class All extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param children The child nodes.\n     */\n    constructor(attributes: Attribute[], options: BehaviourTreeOptions, children: Node[]) {\n        super(\"all\", attributes, options, children);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // Iterate over all of the children of this node, updating any that aren't in a settled state.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent);\n            }\n        }\n\n        // An all node will move into a completed state if all child nodes move into a completed state.\n        if (this.children.every((child) => child.is(State.SUCCEEDED) || child.is(State.FAILED))) {\n            // If any of our child nodes have succeeded then this node has also succeeded, otherwise it has failed.\n            this.setState(this.children.find((child) => child.is(State.SUCCEEDED)) ? State.SUCCEEDED : State.FAILED);\n\n            return;\n        }\n\n        // If we didn't move to a succeeded or failed state then this node is still running.\n        this.setState(State.RUNNING);\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"ALL\";\n}\n", "import Composite from \"./Composite\";\nimport Node from \"../Node\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A SELECTOR node.\n * The child nodes are executed in sequence until one succeeds or all fail.\n */\nexport default class Selector extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param children The child nodes.\n     */\n    constructor(attributes: Attribute[], options: BehaviourTreeOptions, protected children: Node[]) {\n        super(\"selector\", attributes, options, children);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // Iterate over all of the children of this node.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent);\n            }\n\n            // If the current child has a state of 'SUCCEEDED' then this node is also a 'SUCCEEDED' node.\n            if (child.getState() === State.SUCCEEDED) {\n                // This node is a 'SUCCEEDED' node.\n                this.setState(State.SUCCEEDED);\n\n                // There is no need to check the rest of the selector nodes.\n                return;\n            }\n\n            // If the current child has a state of 'FAILED' then we should move on to the next child.\n            if (child.getState() === State.FAILED) {\n                // Find out if the current child is the last one in the selector.\n                // If it is then this sequence node has also failed.\n                if (this.children.indexOf(child) === this.children.length - 1) {\n                    // This node is a 'FAILED' node.\n                    this.setState(State.FAILED);\n\n                    // There is no need to check the rest of the selector as we have completed it.\n                    return;\n                } else {\n                    // The child node failed, try the next one.\n                    continue;\n                }\n            }\n\n            // The node should be in the 'RUNNING' state.\n            if (child.getState() === State.RUNNING) {\n                // This node is a 'RUNNING' node.\n                this.setState(State.RUNNING);\n\n                // There is no need to check the rest of the selector as the current child is still running.\n                return;\n            }\n\n            // The child node was not in an expected state.\n            throw new Error(\"child node was not in an expected state.\");\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"SELECTOR\";\n}\n", "import Composite from \"./Composite\";\nimport Node from \"../Node\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A SEQUENCE node.\n * The child nodes are executed in sequence until one fails or all succeed.\n */\nexport default class Sequence extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param children The child nodes.\n     */\n    constructor(attributes: Attribute[], options: BehaviourTreeOptions, protected children: Node[]) {\n        super(\"sequence\", attributes, options, children);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // Iterate over all of the children of this node.\n        for (const child of this.children) {\n            // If the child has never been updated or is running then we will need to update it now.\n            if (child.getState() === State.READY || child.getState() === State.RUNNING) {\n                // Update the child of this node.\n                child.update(agent);\n            }\n\n            // If the current child has a state of 'SUCCEEDED' then we should move on to the next child.\n            if (child.getState() === State.SUCCEEDED) {\n                // Find out if the current child is the last one in the sequence.\n                // If it is then this sequence node has also succeeded.\n                if (this.children.indexOf(child) === this.children.length - 1) {\n                    // This node is a 'SUCCEEDED' node.\n                    this.setState(State.SUCCEEDED);\n\n                    // There is no need to check the rest of the sequence as we have completed it.\n                    return;\n                } else {\n                    // The child node succeeded, but we have not finished the sequence yet.\n                    continue;\n                }\n            }\n\n            // If the current child has a state of 'FAILED' then this node is also a 'FAILED' node.\n            if (child.getState() === State.FAILED) {\n                // This node is a 'FAILED' node.\n                this.setState(State.FAILED);\n\n                // There is no need to check the rest of the sequence.\n                return;\n            }\n\n            // The node should be in the 'RUNNING' state.\n            if (child.getState() === State.RUNNING) {\n                // This node is a 'RUNNING' node.\n                this.setState(State.RUNNING);\n\n                // There is no need to check the rest of the sequence as the current child is still running.\n                return;\n            }\n\n            // The child node was not in an expected state.\n            throw new Error(\"child node was not in an expected state.\");\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"SEQUENCE\";\n}\n", "import createLotto from \"lotto-draw\";\n\nimport Node from \"../Node\";\nimport Composite from \"./Composite\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A LOTTO node.\n * A winning child is picked on the initial update of this node, based on ticket weighting.\n * The state of this node will match the state of the winning child.\n */\nexport default class Lotto extends Composite {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param weights The child node weights.\n     * @param children The child nodes.\n     */\n    constructor(\n        attributes: Attribute[],\n        options: BehaviourTreeOptions,\n        private weights: number[] | undefined,\n        children: Node[]\n    ) {\n        super(\"lotto\", attributes, options, children);\n    }\n\n    /**\n     * The child node selected to be the active one.\n     */\n    private selectedChild: Node | undefined;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // If this node is in the READY state then we need to pick a winning child node.\n        if (this.is(State.READY)) {\n            // Create a lotto draw with which to randomly pick a child node to become the active one.\n            const lottoDraw = createLotto<Node>({\n                // Hook up the optional 'random' behaviour tree function option to the one used by 'lotto-draw'.\n                random: this.options.random,\n                // Pass in each child node as a participant in the lotto draw with their respective ticket count.\n                participants: this.children.map((child, index) => [child, this.weights?.[index] || 1])\n            });\n\n            // Randomly pick a child based on ticket weighting, this will become the active child for this composite node.\n            this.selectedChild = lottoDraw.draw() || undefined;\n        }\n\n        // If something went wrong and we don't have an active child then we should throw an error.\n        if (!this.selectedChild) {\n            throw new Error(\"failed to update lotto node as it has no active child\");\n        }\n\n        // If the selected child has never been updated or is running then we will need to update it now.\n        if (this.selectedChild.getState() === State.READY || this.selectedChild.getState() === State.RUNNING) {\n            this.selectedChild.update(agent);\n        }\n\n        // The state of the lotto node is the state of its selected child.\n        this.setState(this.selectedChild.getState());\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => (this.weights ? `LOTTO [${this.weights.join(\",\")}]` : \"LOTTO\");\n}\n", "import Node, { NodeDetails } from \"../Node\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A decorator node that wraps a single child node.\n */\nexport default abstract class Decorator extends Node {\n    /**\n     * @param type The node type.\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param child The child node.\n     */\n    constructor(type: string, attributes: Attribute[], options: BehaviourTreeOptions, protected child: Node) {\n        super(type, attributes, options);\n    }\n\n    /**\n     * Gets the children of this node.\n     */\n    getChildren = () => [this.child];\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the state of the child node.\n        this.child.reset();\n    };\n\n    /**\n     * Abort the running of this node.\n     * @param agent The agent.\n     */\n    abort = (agent: Agent) => {\n        // There is nothing to do if this node is not in the running state.\n        if (!this.is(State.RUNNING)) {\n            return;\n        }\n\n        // Abort the child node.\n        this.child.abort(agent);\n\n        // Reset the state of this node.\n        this.reset();\n\n        this.attributes.exit?.callAgentFunction(agent, false, true);\n    };\n\n    /**\n     * Gets the details of this node instance.\n     * @returns The details of this node instance.\n     */\n    public getDetails(): NodeDetails {\n        return {\n            ...super.getDetails(),\n            children: [this.child.getDetails()]\n        };\n    }\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A Fail node.\n * This node wraps a single child and will always move to the 'FAILED' state when the child moves to a 'SUCCEEDED' or 'FAILED' state.\n */\nexport default class Fail extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param child The child node.\n     */\n    constructor(attributes: Attribute[], options: BehaviourTreeOptions, child: Node) {\n        super(\"fail\", attributes, options, child);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            this.child.update(agent);\n        }\n\n        // The state of this node will depend in the state of its child.\n        switch (this.child.getState()) {\n            case State.RUNNING:\n                this.setState(State.RUNNING);\n                break;\n\n            case State.SUCCEEDED:\n            case State.FAILED:\n                this.setState(State.FAILED);\n                break;\n\n            default:\n                this.setState(State.READY);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"FAIL\";\n}\n", "import Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport Node from \"../Node\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A Flip node.\n * This node wraps a single child and will flip the state of the child state.\n */\nexport default class Flip extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param child The child node.\n     */\n    constructor(attributes: Attribute[], options: BehaviourTreeOptions, child: Node) {\n        super(\"flip\", attributes, options, child);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            this.child.update(agent);\n        }\n\n        // The state of this node will depend in the state of its child.\n        switch (this.child.getState()) {\n            case State.RUNNING:\n                this.setState(State.RUNNING);\n                break;\n\n            case State.SUCCEEDED:\n                this.setState(State.FAILED);\n                break;\n\n            case State.FAILED:\n                this.setState(State.SUCCEEDED);\n                break;\n\n            default:\n                this.setState(State.READY);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"FLIP\";\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A REPEAT node.\n * The node has a single child which can have:\n * -- A number of iterations for which to repeat the child node.\n * -- An infinite repeat loop if neither an iteration count or a condition function is defined.\n * The REPEAT node will stop and have a 'FAILED' state if its child is ever in a 'FAILED' state after an update.\n * The REPEAT node will attempt to move on to the next iteration if its child is ever in a 'SUCCEEDED' state.\n */\nexport default class Repeat extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param iterations The number of iterations to repeat the child node.\n     * @param iterationsMin The minimum possible number of iterations to repeat the child node.\n     * @param iterationsMax The maximum possible number of iterations to repeat the child node.\n     * @param child The child node.\n     */\n    constructor(\n        attributes: Attribute[],\n        options: BehaviourTreeOptions,\n        private iterations: number | null,\n        private iterationsMin: number | null,\n        private iterationsMax: number | null,\n        child: Node\n    ) {\n        super(\"repeat\", attributes, options, child);\n    }\n\n    /**\n     * The number of target iterations to make.\n     */\n    private targetIterationCount: number | null = null;\n\n    /**\n     * The current iteration count.\n     */\n    private currentIterationCount: number = 0;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // If this node is in the READY state then we need to reset the child and the target iteration count.\n        if (this.is(State.READY)) {\n            // Reset the child node.\n            this.child.reset();\n\n            // Reset the current iteration count.\n            this.currentIterationCount = 0;\n\n            // Set the target iteration count.\n            this.setTargetIterationCount();\n        }\n\n        // Do a check to see if we can iterate. If we can then this node will move into the 'RUNNING' state.\n        // If we cannot iterate then we have hit our target iteration count, which means that the node has succeeded.\n        if (this.canIterate()) {\n            // This node is in the running state and can do its initial iteration.\n            this.setState(State.RUNNING);\n\n            // We may have already completed an iteration, meaning that the child node will be in the SUCCEEDED state.\n            // If this is the case then we will have to reset the child node now.\n            if (this.child.getState() === State.SUCCEEDED) {\n                this.child.reset();\n            }\n\n            // Update the child of this node.\n            this.child.update(agent);\n\n            // If the child moved into the FAILED state when we updated it then there is nothing left to do and this node has also failed.\n            // If it has moved into the SUCCEEDED state then we have completed the current iteration.\n            if (this.child.getState() === State.FAILED) {\n                // The child has failed, meaning that this node has failed.\n                this.setState(State.FAILED);\n\n                return;\n            } else if (this.child.getState() === State.SUCCEEDED) {\n                // We have completed an iteration.\n                this.currentIterationCount += 1;\n            }\n        } else {\n            // This node is in the 'SUCCEEDED' state as we cannot iterate any more.\n            this.setState(State.SUCCEEDED);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => {\n        if (this.iterations !== null) {\n            return `REPEAT ${this.iterations}x`;\n        } else if (this.iterationsMin !== null && this.iterationsMax !== null) {\n            return `REPEAT ${this.iterationsMin}x-${this.iterationsMax}x`;\n        } else {\n            return \"REPEAT\";\n        }\n    };\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the current iteration count.\n        this.currentIterationCount = 0;\n\n        // Reset the child node.\n        this.child.reset();\n    };\n\n    /**\n     * Gets whether an iteration can be made.\n     * @returns Whether an iteration can be made.\n     */\n    private canIterate = () => {\n        if (this.targetIterationCount !== null) {\n            // We can iterate as long as we have not reached our target iteration count.\n            return this.currentIterationCount < this.targetIterationCount;\n        }\n\n        // If neither an iteration count or a condition function were defined then we can iterate indefinitely.\n        return true;\n    };\n\n    /**\n     * Sets the target iteration count.\n     */\n    private setTargetIterationCount = () => {\n        // Are we dealing with an explicit iteration count or will we be randomly picking a iteration count between the min and max iteration count.\n        if (this.iterations !== null) {\n            this.targetIterationCount = this.iterations;\n        } else if (this.iterationsMin !== null && this.iterationsMax !== null) {\n            // We will be picking a random iteration count between a min and max iteration count, if the optional 'random'\n            // behaviour tree function option is defined then we will be using that, otherwise we will fall back to using Math.random.\n            const random = typeof this.options.random === \"function\" ? this.options.random : Math.random;\n\n            // Pick a random iteration count between a min and max iteration count.\n            this.targetIterationCount = Math.floor(\n                random() * (this.iterationsMax - this.iterationsMin + 1) + this.iterationsMin\n            );\n        } else {\n            this.targetIterationCount = null;\n        }\n    };\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A RETRY node.\n * The node has a single child which can have:\n * -- A number of iterations for which to repeat the child node.\n * -- An infinite repeat loop if neither an iteration count or a condition function is defined.\n * The RETRY node will stop and have a 'SUCCEEDED' state if its child is ever in a 'SUCCEEDED' state after an update.\n * The RETRY node will attempt to move on to the next iteration if its child is ever in a 'FAILED' state.\n */\nexport default class Retry extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param attempts The number of attempts to retry the child node.\n     * @param attemptsMin The minimum possible number of attempts to retry the child node.\n     * @param attemptsMax The maximum possible number of attempts to retry the child node.\n     * @param child The child node.\n     */\n    constructor(\n        attributes: Attribute[],\n        options: BehaviourTreeOptions,\n        private attempts: number | null,\n        private attemptsMin: number | null,\n        private attemptsMax: number | null,\n        child: Node\n    ) {\n        super(\"retry\", attributes, options, child);\n    }\n\n    /**\n     * The number of target attempts to make.\n     */\n    private targetAttemptCount: number | null = null;\n\n    /**\n     * The current attempt count.\n     */\n    private currentAttemptCount: number = 0;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // If this node is in the READY state then we need to reset the child and the target attempt count.\n        if (this.is(State.READY)) {\n            // Reset the child node.\n            this.child.reset();\n\n            // Reset the current attempt count.\n            this.currentAttemptCount = 0;\n\n            // Set the target attempt count.\n            this.setTargetAttemptCount();\n        }\n\n        // Do a check to see if we can attempt. If we can then this node will move into the 'RUNNING' state.\n        // If we cannot attempt then we have hit our target attempt count, which means that the node has succeeded.\n        if (this.canAttempt()) {\n            // This node is in the running state and can do its initial attempt.\n            this.setState(State.RUNNING);\n\n            // We may have already completed an attempt, meaning that the child node will be in the FAILED state.\n            // If this is the case then we will have to reset the child node now.\n            if (this.child.getState() === State.FAILED) {\n                this.child.reset();\n            }\n\n            // Update the child of this node.\n            this.child.update(agent);\n\n            // If the child moved into the SUCCEEDED state when we updated it then there is nothing left to do and this node has also succeeded.\n            // If it has moved into the FAILED state then we have completed the current attempt.\n            if (this.child.getState() === State.SUCCEEDED) {\n                // The child has succeeded, meaning that this node has succeeded.\n                this.setState(State.SUCCEEDED);\n\n                return;\n            } else if (this.child.getState() === State.FAILED) {\n                // We have completed an attempt.\n                this.currentAttemptCount += 1;\n            }\n        } else {\n            // This node is in the 'FAILED' state as we cannot iterate any more.\n            this.setState(State.FAILED);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => {\n        if (this.attempts !== null) {\n            return `RETRY ${this.attempts}x`;\n        } else if (this.attemptsMin !== null && this.attemptsMax !== null) {\n            return `RETRY ${this.attemptsMin}x-${this.attemptsMax}x`;\n        } else {\n            return \"RETRY\";\n        }\n    };\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // Reset the current attempt count.\n        this.currentAttemptCount = 0;\n\n        // Reset the child node.\n        this.child.reset();\n    };\n\n    /**\n     * Gets whether an attempt can be made.\n     * @returns Whether an attempt can be made.\n     */\n    canAttempt = () => {\n        if (this.targetAttemptCount !== null) {\n            // We can attempt as long as we have not reached our target attempt count.\n            return this.currentAttemptCount < this.targetAttemptCount;\n        }\n\n        // If neither an attempt count or a condition function were defined then we can attempt indefinitely.\n        return true;\n    };\n\n    /**\n     * Sets the target attempt count.\n     */\n    setTargetAttemptCount = () => {\n        // Are we dealing with an explicit attempt count or will we be randomly picking an attempt count between the min and max attempt count.\n        if (this.attempts !== null) {\n            this.targetAttemptCount = this.attempts;\n        } else if (this.attemptsMin !== null && this.attemptsMax !== null) {\n            // We will be picking a random attempt count between a min and max attempt count, if the optional 'random'\n            // behaviour tree function option is defined then we will be using that, otherwise we will fall back to using Math.random.\n            const random = typeof this.options.random === \"function\" ? this.options.random : Math.random;\n\n            // Pick a random attempt count between a min and max attempt count.\n            this.targetAttemptCount = Math.floor(\n                random() * (this.attemptsMax - this.attemptsMin + 1) + this.attemptsMin\n            );\n        } else {\n            this.targetAttemptCount = null;\n        }\n    };\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A Root node.\n * The root node will have a single child.\n */\nexport default class Root extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param child The child node.\n     */\n    constructor(attributes: Attribute[], options: BehaviourTreeOptions, child: Node) {\n        super(\"root\", attributes, options, child);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            // Update the child of this node.\n            this.child.update(agent);\n        }\n\n        // The state of the root node is the state of its child.\n        this.setState(this.child.getState());\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"ROOT\";\n}\n", "import Node from \"../Node\";\nimport Decorator from \"./Decorator\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A Succeed node.\n * This node wraps a single child and will always move to the 'SUCCEEDED' state when the child moves to a 'SUCCEEDED' or 'FAILED' state.\n */\nexport default class Succeed extends Decorator {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param child The child node.\n     */\n    constructor(attributes: Attribute[], options: BehaviourTreeOptions, child: Node) {\n        super(\"succeed\", attributes, options, child);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // If the child has never been updated or is running then we will need to update it now.\n        if (this.child.getState() === State.READY || this.child.getState() === State.RUNNING) {\n            this.child.update(agent);\n        }\n\n        // The state of this node will depend in the state of its child.\n        switch (this.child.getState()) {\n            case State.RUNNING:\n                this.setState(State.RUNNING);\n                break;\n\n            case State.SUCCEEDED:\n            case State.FAILED:\n                this.setState(State.SUCCEEDED);\n                break;\n\n            default:\n                this.setState(State.READY);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => \"SUCCEED\";\n}\n", "import { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\nimport { NodeDetails } from \"../Node\";\nimport State, { CompleteState } from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Leaf from \"./Leaf\";\nimport Lookup from \"../../Lookup\";\nimport Attribute from \"../../attributes/Attribute\";\n\n/**\n * The type representing a resolved/rejected update promise.\n */\ntype UpdatePromiseResult = {\n    /**\n     * Whether the promise was resolved rather than rejected.\n     */\n    isResolved: boolean;\n\n    /**\n     * The promise resolved value or rejection reason.\n     */\n    value: any;\n};\n\n/**\n * An Action leaf node.\n * This represents an immediate or ongoing state of behaviour.\n */\nexport default class Action extends Leaf {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param actionName The action name.\n     * @param actionArguments The array of action arguments.\n     */\n    constructor(\n        attributes: Attribute[],\n        options: BehaviourTreeOptions,\n        private actionName: string,\n        public actionArguments: any[]\n    ) {\n        super(\"action\", attributes, options);\n    }\n\n    /**\n     * Whether there is a pending update promise.\n     */\n    private isUsingUpdatePromise = false;\n\n    /**\n     * The finished state result of an update promise.\n     */\n    private updatePromiseResult: UpdatePromiseResult | null = null;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // If the result of this action depends on an update promise then there is nothing to do until it settles.\n        if (this.isUsingUpdatePromise) {\n            // Are we still waiting for our update promise to settle?\n            if (!this.updatePromiseResult) {\n                return;\n            }\n\n            const { isResolved, value } = this.updatePromiseResult;\n\n            // Our update promise settled, was it resolved or rejected?\n            if (isResolved) {\n                // Our promise resolved so check to make sure the result is a valid finished state.\n                if (value !== State.SUCCEEDED && value !== State.FAILED) {\n                    throw new Error(\n                        \"action node promise resolved with an invalid value, expected a State.SUCCEEDED or State.FAILED value to be returned\"\n                    );\n                }\n\n                // Set the state of this node to match the state returned by the promise.\n                this.setState(value);\n\n                return;\n            } else {\n                // The promise was rejected, which isn't great.\n                throw new Error(`action function '${this.actionName}' promise rejected with '${value}'`);\n            }\n        }\n\n        // Attempt to get the invoker for the action function.\n        const actionFuncInvoker = Lookup.getFuncInvoker(agent, this.actionName);\n\n        // The action function should be defined.\n        if (actionFuncInvoker === null) {\n            throw new Error(\n                `cannot update action node as the action '${this.actionName}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        let actionFunctionResult;\n\n        try {\n            // Call the action function, the result of which may be:\n            // - The finished state of this action node.\n            // - A promise to return a finished node state.\n            // - Undefined if the node should remain in the running state.\n            actionFunctionResult = actionFuncInvoker(this.actionArguments) as CompleteState | Promise<CompleteState>;\n        } catch (error) {\n            // An uncaught error was thrown.\n            if (error instanceof Error) {\n                throw new Error(`action function '${this.actionName}' threw: ${error.stack}`);\n            } else {\n                throw new Error(`action function '${this.actionName}' threw: ${error}`);\n            }\n        }\n\n        if (actionFunctionResult instanceof Promise) {\n            actionFunctionResult.then(\n                (result) => {\n                    // If 'isUpdatePromisePending' is not set then the promise was cleared as it was resolving, probably via an abort of reset.\n                    if (!this.isUsingUpdatePromise) {\n                        return;\n                    }\n\n                    // Set the resolved update promise result so that it can be handled on the next update of this node.\n                    this.updatePromiseResult = {\n                        isResolved: true,\n                        value: result\n                    };\n                },\n                (reason) => {\n                    // If 'isUpdatePromisePending' is not set then the promise was cleared as it was resolving, probably via an abort or reset.\n                    if (!this.isUsingUpdatePromise) {\n                        return;\n                    }\n\n                    // Set the rejected update promise result so that it can be handled on the next update of this node.\n                    this.updatePromiseResult = {\n                        isResolved: false,\n                        value: reason\n                    };\n                }\n            );\n\n            // This node will be in the 'RUNNING' state until the update promise resolves.\n            this.setState(State.RUNNING);\n\n            // We are now waiting for the promise returned by the use to resolve before we know what state this node is in.\n            this.isUsingUpdatePromise = true;\n        } else {\n            // Validate the returned value.\n            this.validateUpdateResult(actionFunctionResult);\n\n            // Set the state of this node, this may be undefined, which just means that the node is still in the 'RUNNING' state.\n            this.setState(actionFunctionResult || State.RUNNING);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => this.actionName;\n\n    /**\n     * Reset the state of the node.\n     */\n    reset = () => {\n        // Reset the state of this node.\n        this.setState(State.READY);\n\n        // There is no longer an update promise that we care about.\n        this.isUsingUpdatePromise = false;\n        this.updatePromiseResult = null;\n    };\n\n    /**\n     * Gets the details of this node instance.\n     * @returns The details of this node instance.\n     */\n    public getDetails(): NodeDetails {\n        return {\n            ...super.getDetails(),\n            args: this.actionArguments\n        };\n    }\n\n    /**\n     * Called when the state of this node changes.\n     * @param previousState The previous node state.\n     */\n    protected onStateChanged(previousState: State): void {\n        this.options.onNodeStateChange?.({\n            id: this.uid,\n            type: this.getType(),\n            args: this.actionArguments,\n            while: this.attributes.while?.getDetails(),\n            until: this.attributes.until?.getDetails(),\n            entry: this.attributes.entry?.getDetails(),\n            step: this.attributes.step?.getDetails(),\n            exit: this.attributes.exit?.getDetails(),\n            previousState,\n            state: this.getState()\n        });\n    }\n\n    /**\n     * Validate the result of an update function call.\n     * @param result The result of an update function call.\n     */\n    private validateUpdateResult = (result: CompleteState | State.RUNNING) => {\n        switch (result) {\n            case State.SUCCEEDED:\n            case State.FAILED:\n            case State.RUNNING:\n            case undefined:\n                return;\n            default:\n                throw new Error(\n                    `expected action function '${this.actionName}' to return an optional State.SUCCEEDED or State.FAILED value but returned '${result}'`\n                );\n        }\n    };\n}\n", "import { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\nimport { NodeDetails } from \"../Node\";\nimport State from \"../../State\";\nimport { Agent } from \"../../Agent\";\nimport Leaf from \"./Leaf\";\nimport Lookup from \"../../Lookup\";\nimport Attribute from \"../../attributes/Attribute\";\n\n/**\n * A Condition leaf node.\n * This will succeed or fail immediately based on an agent predicate, without moving to the 'RUNNING' state.\n */\nexport default class Condition extends Leaf {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param conditionName The name of the condition function.\n     * @param conditionArguments The array of condition arguments.\n     */\n    constructor(\n        attributes: Attribute[],\n        options: BehaviourTreeOptions,\n        private conditionName: string,\n        public conditionArguments: any[]\n    ) {\n        super(\"condition\", attributes, options);\n    }\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // Attempt to get the invoker for the condition function.\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.conditionName);\n\n        // The condition function should be defined.\n        if (conditionFuncInvoker === null) {\n            throw new Error(\n                `cannot update condition node as the condition '${this.conditionName}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        let conditionFunctionResult;\n\n        try {\n            // Call the condition function to determine the state of this node, the result of which should be a boolean.\n            conditionFunctionResult = conditionFuncInvoker(this.conditionArguments);\n        } catch (error) {\n            // An uncaught error was thrown.\n            if (error instanceof Error) {\n                throw new Error(`condition function '${this.conditionName}' threw: ${error.stack}`);\n            } else {\n                throw new Error(`condition function '${this.conditionName}' threw: ${error}`);\n            }\n        }\n\n        // The result of calling the condition function must be a boolean value.\n        if (typeof conditionFunctionResult !== \"boolean\") {\n            throw new Error(\n                `expected condition function '${this.conditionName}' to return a boolean but returned '${conditionFunctionResult}'`\n            );\n        }\n\n        // Set the state of this node based on the result of calling the condition function.\n        this.setState(conditionFunctionResult ? State.SUCCEEDED : State.FAILED);\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => this.conditionName;\n\n    /**\n     * Gets the details of this node instance.\n     * @returns The details of this node instance.\n     */\n    public getDetails(): NodeDetails {\n        return {\n            ...super.getDetails(),\n            args: this.conditionArguments\n        };\n    }\n\n    /**\n     * Called when the state of this node changes.\n     * @param previousState The previous node state.\n     */\n    protected onStateChanged(previousState: State): void {\n        this.options.onNodeStateChange?.({\n            id: this.uid,\n            type: this.getType(),\n            args: this.conditionArguments,\n            while: this.attributes.while?.getDetails(),\n            until: this.attributes.until?.getDetails(),\n            entry: this.attributes.entry?.getDetails(),\n            step: this.attributes.step?.getDetails(),\n            exit: this.attributes.exit?.getDetails(),\n            previousState,\n            state: this.getState()\n        });\n    }\n}\n", "import Leaf from \"./Leaf\";\nimport State from \"../../State\";\nimport Attribute from \"../../attributes/Attribute\";\nimport { Agent } from \"../../Agent\";\nimport { BehaviourTreeOptions } from \"../../BehaviourTreeOptions\";\n\n/**\n * A WAIT node.\n * The state of this node will change to SUCCEEDED after a duration of time\n */\nexport default class Wait extends Leaf {\n    /**\n     * @param attributes The node attributes.\n     * @param options The behaviour tree options.\n     * @param duration The duration that this node will wait to succeed in milliseconds.\n     * @param durationMin The minimum possible duration in milliseconds that this node will wait to succeed.\n     * @param durationMax The maximum possible duration in milliseconds that this node will wait to succeed.\n     */\n    constructor(\n        attributes: Attribute[],\n        options: BehaviourTreeOptions,\n        private duration: number | null,\n        private durationMin: number | null,\n        private durationMax: number | null\n    ) {\n        super(\"wait\", attributes, options);\n    }\n\n    /**\n     * The time in milliseconds at which this node was first updated.\n     */\n    private initialUpdateTime: number = 0;\n\n    /**\n     * The total duration in milliseconds that this node will be waiting for.\n     */\n    private totalDuration: number | null = null;\n\n    /**\n     * The duration in milliseconds that this node has been waiting for.\n     */\n    private waitedDuration: number = 0;\n\n    /**\n     * Called when the node is being updated.\n     * @param agent The agent.\n     */\n    protected onUpdate(agent: Agent): void {\n        // If this node is in the READY state then we need to set the initial update time.\n        if (this.is(State.READY)) {\n            // Set the initial update time.\n            this.initialUpdateTime = new Date().getTime();\n\n            // Set the initial waited duration.\n            this.waitedDuration = 0;\n\n            // Are we dealing with an explicit duration or will we be randomly picking a duration between the min and max duration.\n            if (this.duration !== null) {\n                this.totalDuration = this.duration;\n            } else if (this.durationMin !== null && this.durationMax !== null) {\n                // We will be picking a random duration between a min and max duration, if the optional 'random' behaviour tree\n                // function option is defined then we will be using that, otherwise we will fall back to using Math.random.\n                const random = typeof this.options.random === \"function\" ? this.options.random : Math.random;\n\n                // Pick a random duration between a min and max duration.\n                this.totalDuration = Math.floor(\n                    random() * (this.durationMax - this.durationMin + 1) + this.durationMin\n                );\n            } else {\n                this.totalDuration = null;\n            }\n\n            // The node is now running until we finish waiting.\n            this.setState(State.RUNNING);\n        }\n\n        // If we have no total duration then this wait node will wait indefinitely until it is aborted.\n        if (this.totalDuration === null) {\n            return;\n        }\n\n        // If we have a 'getDeltaTime' function defined as part of our options then we will use it to figure out how long we have waited for.\n        if (typeof this.options.getDeltaTime === \"function\") {\n            // Get the delta time.\n            const deltaTime = this.options.getDeltaTime();\n\n            // Our delta time must be a valid number and cannot be NaN.\n            if (typeof deltaTime !== \"number\" || isNaN(deltaTime)) {\n                throw new Error(\"The delta time must be a valid number and not NaN.\");\n            }\n\n            // Update the amount of time that this node has been waiting for based on the delta time.\n            this.waitedDuration += deltaTime * 1000;\n        } else {\n            // We are not using a delta time, so we will just work out hom much time has passed since the first update.\n            this.waitedDuration = new Date().getTime() - this.initialUpdateTime;\n        }\n\n        // Have we waited long enough?\n        if (this.waitedDuration >= this.totalDuration) {\n            // We have finished waiting!\n            this.setState(State.SUCCEEDED);\n        }\n    }\n\n    /**\n     * Gets the name of the node.\n     */\n    getName = () => {\n        if (this.duration !== null) {\n            return `WAIT ${this.duration}ms`;\n        } else if (this.durationMin !== null && this.durationMax !== null) {\n            return `WAIT ${this.durationMin}ms-${this.durationMax}ms`;\n        } else {\n            return \"WAIT\";\n        }\n    };\n}\n", "import Guard from \"./guards/Guard\";\n\nexport type AttributeDetails = {\n    /** The attribute type. */\n    type: string;\n\n    /** The attribute arguments. */\n    args: any[];\n};\n\n/**\n * A base node attribute.\n */\nexport default abstract class Attribute<TAttributeDetails extends AttributeDetails = AttributeDetails> {\n    /**\n     * @param type The node attribute type.\n     * @param args The array of attribute arguments.\n     */\n    constructor(public type: string, public args: any[]) {}\n\n    /**\n     * Gets the attribute details.\n     */\n    abstract getDetails(): TAttributeDetails;\n}\n", "import { Agent } from \"../../Agent\";\nimport { NodeGuardDefinition } from \"../../BehaviourTreeDefinition\";\nimport Attribute, { AttributeDetails } from \"../Attribute\";\n\n/**\n * Details of a node guard attribute.\n */\nexport type GuardAttributeDetails = {\n    /** The name of the condition function that determines whether the guard is satisfied. */\n    calls: string;\n} & AttributeDetails;\n\n/**\n * A base node guard attribute.\n */\nexport default abstract class Guard extends Attribute<GuardAttributeDetails> {\n    /**\n     * Creates a new instance of the Guard class.\n     * @param type The node attribute type.\n     * @param definition The node guard definition.\n     */\n    constructor(type: string, private definition: NodeGuardDefinition) {\n        super(type, definition.args ?? []);\n    }\n\n    /**\n     * Gets the name of the condition function that determines whether the guard is satisfied.\n     */\n    public get condition(): string {\n        return this.definition.call;\n    }\n\n    /**\n     * Gets a flag defining whether the running node should move to the succeeded state when aborted, otherwise failed.\n     */\n    public get succeedOnAbort(): boolean {\n        return !!this.definition.succeedOnAbort;\n    }\n\n    /**\n     * Gets the attribute details.\n     */\n    public getDetails(): GuardAttributeDetails {\n        return {\n            type: this.type,\n            args: this.args,\n            calls: this.condition\n        };\n    }\n\n    /**\n     * Gets whether the guard is satisfied.\n     * @param agent The agent.\n     * @returns Whether the guard is satisfied.\n     */\n    abstract isSatisfied(agent: Agent): boolean;\n}\n", "import Guard from \"./Guard\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\nimport { NodeGuardDefinition } from \"../../BehaviourTreeDefinition\";\n\n/**\n * A WHILE guard which is satisfied as long as the given condition remains true.\n */\nexport default class While extends Guard {\n    /**\n     * Creates a new instance of the While class.\n     * @param definition The while node guard definition.\n     */\n    constructor(definition: NodeGuardDefinition) {\n        super(\"while\", definition);\n    }\n\n    /**\n     * Gets whether the guard is satisfied.\n     * @param agent The agent.\n     * @returns Whether the guard is satisfied.\n     */\n    isSatisfied = (agent: Agent) => {\n        // Attempt to get the invoker for the condition function.\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.condition);\n\n        // The condition function should be defined.\n        if (conditionFuncInvoker === null) {\n            throw new Error(\n                `cannot evaluate node guard as the condition '${this.condition}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        let conditionFunctionResult;\n\n        try {\n            // Call the guard condition function to determine the state of this node, the result of which should be a boolean.\n            conditionFunctionResult = conditionFuncInvoker(this.args);\n        } catch (error) {\n            // An uncaught error was thrown.\n            if (error instanceof Error) {\n                throw new Error(`guard condition function '${this.condition}' threw: ${error.stack}`);\n            } else {\n                throw new Error(`guard condition function '${this.condition}' threw: ${error}`);\n            }\n        }\n\n        // The result of calling the guard condition function must be a boolean value.\n        if (typeof conditionFunctionResult !== \"boolean\") {\n            throw new Error(\n                `expected guard condition function '${this.condition}' to return a boolean but returned '${conditionFunctionResult}'`\n            );\n        }\n\n        // Return whether this guard is satisfied.\n        return conditionFunctionResult;\n    };\n}\n", "import Guard from \"./Guard\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\nimport { NodeGuardDefinition } from \"../../BehaviourTreeDefinition\";\n\n/**\n * An UNTIL guard which is satisfied as long as the given condition remains false.\n */\nexport default class Until extends Guard {\n    /**\n     * Creates a new instance of the Until class.\n     * @param definition The while node guard definition.\n     */\n    constructor(definition: NodeGuardDefinition) {\n        super(\"until\", definition);\n    }\n\n    /**\n     * Gets whether the guard is satisfied.\n     * @param agent The agent.\n     * @returns Whether the guard is satisfied.\n     */\n    isSatisfied = (agent: Agent) => {\n        // Attempt to get the invoker for the condition function.\n        const conditionFuncInvoker = Lookup.getFuncInvoker(agent, this.condition);\n\n        // The condition function should be defined.\n        if (conditionFuncInvoker === null) {\n            throw new Error(\n                `cannot evaluate node guard as the condition '${this.condition}' function is not defined on the agent and has not been registered`\n            );\n        }\n\n        let conditionFunctionResult;\n\n        try {\n            // Call the guard condition function to determine the state of this node, the result of which should be a boolean.\n            conditionFunctionResult = conditionFuncInvoker(this.args);\n        } catch (error) {\n            // An uncaught error was thrown.\n            if (error instanceof Error) {\n                throw new Error(`guard condition function '${this.condition}' threw: ${error.stack}`);\n            } else {\n                throw new Error(`guard condition function '${this.condition}' threw: ${error}`);\n            }\n        }\n\n        // The result of calling the guard condition function must be a boolean value.\n        if (typeof conditionFunctionResult !== \"boolean\") {\n            throw new Error(\n                `expected guard condition function '${this.condition}' to return a boolean but returned '${conditionFunctionResult}'`\n            );\n        }\n\n        // Return whether this guard is satisfied.\n        return !conditionFunctionResult;\n    };\n}\n", "import { Agent } from \"../../Agent\";\nimport Attribute, { AttributeDetails } from \"../Attribute\";\n\n/**\n * Details of a node callback attribute.\n */\nexport type CallbackAttributeDetails = {\n    /** The name of the agent function that is called. */\n    calls: string;\n} & AttributeDetails;\n\n/**\n * A base node callback attribute.\n */\nexport default abstract class Callback extends Attribute<CallbackAttributeDetails> {\n    /**\n     * @param type The node attribute type.\n     * @param args The array of decorator argument definitions.\n     * @param functionName The name of the agent function to call.\n     */\n    constructor(type: string, args: any[], private functionName: string) {\n        super(type, args);\n    }\n\n    /**\n     * Gets the name of the agent function to call.\n     */\n    getFunctionName = () => this.functionName;\n\n    /**\n     * Gets the attribute details.\n     */\n    getDetails(): CallbackAttributeDetails {\n        return {\n            type: this.type,\n            args: this.args,\n            calls: this.getFunctionName()\n        };\n    }\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     */\n    abstract callAgentFunction: (agent: Agent, isSuccess: boolean, isAborted: boolean) => void;\n}\n", "import Callback from \"./Callback\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\n\n/**\n * An ENTRY callback which defines an agent function to call when the associated node is updated and moves out of running state.\n */\nexport default class Entry extends Callback {\n    /**\n     * @param functionName The name of the agent function to call.\n     * @param args The array of callback argument definitions.\n     */\n    constructor(functionName: string, args: any[]) {\n        super(\"entry\", args, functionName);\n    }\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     */\n    callAgentFunction = (agent: Agent) => {\n        // Attempt to get the invoker for the callback function.\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.getFunctionName());\n\n        // The callback function should be defined.\n        if (callbackFuncInvoker === null) {\n            throw new Error(\n                `cannot call entry function '${this.getFunctionName()}' as is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the callback function.\n        callbackFuncInvoker(this.args);\n    };\n}\n", "import Callback from \"./Callback\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\n\n/**\n * A STEP callback which defines an agent function to call when the associated node is updated.\n */\nexport default class Step extends Callback {\n    /**\n     * @param functionName The name of the agent function to call.\n     * @param args The array of callback argument definitions.\n     */\n    constructor(functionName: string, args: any[]) {\n        super(\"step\", args, functionName);\n    }\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     */\n    callAgentFunction = (agent: Agent) => {\n        // Attempt to get the invoker for the callback function.\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.getFunctionName());\n\n        // The callback function should be defined.\n        if (callbackFuncInvoker === null) {\n            throw new Error(\n                `cannot call step function '${this.getFunctionName()}' as is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the callback function.\n        callbackFuncInvoker(this.args);\n    };\n}\n", "import Callback from \"./Callback\";\nimport Lookup from \"../../Lookup\";\nimport { Agent } from \"../../Agent\";\n\n/**\n * An EXIT callback which defines an agent function to call when the associated node is updated and moves to a finished state or is aborted.\n */\nexport default class Exit extends Callback {\n    /**\n     * @param functionName The name of the agent function to call.\n     * @param args The array of callback argument definitions.\n     */\n    constructor(functionName: string, args: any[]) {\n        super(\"exit\", args, functionName);\n    }\n\n    /**\n     * Attempt to call the agent function that this callback refers to.\n     * @param agent The agent.\n     * @param isSuccess Whether the decorated node was left with a success state.\n     * @param isAborted Whether the decorated node was aborted.\n     */\n    callAgentFunction = (agent: Agent, isSuccess: boolean, isAborted: boolean) => {\n        // Attempt to get the invoker for the callback function.\n        const callbackFuncInvoker = Lookup.getFuncInvoker(agent, this.getFunctionName());\n\n        // The callback function should be defined.\n        if (callbackFuncInvoker === null) {\n            throw new Error(\n                `cannot call exit function '${this.getFunctionName()}' as is not defined on the agent and has not been registered`\n            );\n        }\n\n        // Call the callback function\n        callbackFuncInvoker([{ succeeded: isSuccess, aborted: isAborted }, ...this.args]);\n    };\n}\n", "import { AnyNodeDefinition, RootNodeDefinition } from \"./BehaviourTreeDefinition\";\nimport GuardPath, { GuardPathPart } from \"./attributes/guards/GuardPath\";\nimport { validateBranchSubtreeLinks } from \"./BehaviourTreeDefinitionValidator\";\nimport { isInteger } from \"./BehaviourTreeDefinitionUtilities\";\nimport Node from \"./nodes/Node\";\nimport Leaf from \"./nodes/leaf/Leaf\";\nimport Composite from \"./nodes/composite/Composite\";\nimport Decorator from \"./nodes/decorator/Decorator\";\nimport Parallel from \"./nodes/composite/Parallel\";\nimport Race from \"./nodes/composite/Race\";\nimport All from \"./nodes/composite/All\";\nimport Selector from \"./nodes/composite/Selector\";\nimport Sequence from \"./nodes/composite/Sequence\";\nimport Lotto from \"./nodes/composite/Lotto\";\nimport Fail from \"./nodes/decorator/Fail\";\nimport Flip from \"./nodes/decorator/Flip\";\nimport Repeat from \"./nodes/decorator/Repeat\";\nimport Retry from \"./nodes/decorator/Retry\";\nimport Root from \"./nodes/decorator/Root\";\nimport Succeed from \"./nodes/decorator/Succeed\";\nimport Action from \"./nodes/leaf/Action\";\nimport Condition from \"./nodes/leaf/Condition\";\nimport Wait from \"./nodes/leaf/Wait\";\nimport Lookup from \"./Lookup\";\nimport Attribute from \"./attributes/Attribute\";\nimport Guard from \"./attributes/guards/Guard\";\nimport While from \"./attributes/guards/While\";\nimport Until from \"./attributes/guards/Until\";\nimport Entry from \"./attributes/callbacks/Entry\";\nimport Step from \"./attributes/callbacks/Step\";\nimport Exit from \"./attributes/callbacks/Exit\";\nimport { BehaviourTreeOptions } from \"./BehaviourTreeOptions\";\n\n/**\n * A type representing any node instance in a behaviour tree.\n */\ntype AnyNode =\n    | Root\n    | Action\n    | Condition\n    | Wait\n    | Sequence\n    | Selector\n    | Lotto\n    | Parallel\n    | Race\n    | All\n    | Repeat\n    | Retry\n    | Flip\n    | Succeed\n    | Fail;\n\n/**\n * A type defining a mapping of root node identifiers to root node definitions.\n */\ntype RootNodeDefinitionMap = { [key: string | symbol]: RootNodeDefinition };\n\n/**\n * A symbol to use as the main root key in any root node mappings.\n */\nconst MAIN_ROOT_NODE_KEY = Symbol(\"__root__\");\n\n/**\n * Build and populate the root nodes based on the provided definition, assuming that the definition has been validated.\n * @param definition The root node definitions.\n * @param options The behaviour tree options.\n * @returns The built and populated root node definitions.\n */\nexport default function buildRootNode(definition: RootNodeDefinition[], options: BehaviourTreeOptions): Root {\n    // Create a mapping of root node identifers to root node definitions, including globally registered subtree root node definitions.\n    const rootNodeDefinitionMap = createRootNodeDefinitionMap(definition);\n\n    // Now that we have all of our root node definitions (those part of the tree definition and those globally registered)\n    // we should validate the branch-subtree links. This will also double-check that we dont have any circular dependencies\n    // in our branch-subtree references and that we have no broken branch-subtree links.\n    validateBranchSubtreeLinks(\n        [rootNodeDefinitionMap[MAIN_ROOT_NODE_KEY], ...Object.values(rootNodeDefinitionMap)],\n        true\n    );\n\n    // Create our populated tree of node instances, starting with our main root node.\n    const rootNode = nodeFactory(rootNodeDefinitionMap[MAIN_ROOT_NODE_KEY], rootNodeDefinitionMap, options) as Root;\n\n    // Set a guard path on every leaf of the tree to evaluate as part of each update.\n    applyLeafNodeGuardPaths(rootNode);\n\n    // We only need to return the main root node.\n    return rootNode;\n}\n\n/**\n * A factory function which creates a node instance based on the specified definition.\n * @param definition The node definition.\n * @param rootNodeDefinitionMap The mapping of root node identifers to root node definitions, including globally registered subtree root node definitions.\n * @param options The behaviour tree options.\n * @returns A node instance based on the specified definition.\n */\nfunction nodeFactory(\n    definition: AnyNodeDefinition,\n    rootNodeDefinitionMap: RootNodeDefinitionMap,\n    options: BehaviourTreeOptions\n): AnyNode {\n    // Create the attributes for the node.\n    const attributes = createNodeAttributes(definition);\n\n    // Create the node instance based on the definition type.\n    switch (definition.type) {\n        case \"root\":\n            return new Root(attributes, options, nodeFactory(definition.child, rootNodeDefinitionMap, options));\n\n        case \"repeat\": {\n            let iterations: number | null = null;\n            let iterationsMin: number | null = null;\n            let iterationsMax: number | null = null;\n\n            if (Array.isArray(definition.iterations)) {\n                iterationsMin = definition.iterations[0];\n                iterationsMax = definition.iterations[1];\n            } else if (isInteger(definition.iterations)) {\n                iterations = definition.iterations!;\n            }\n\n            return new Repeat(\n                attributes,\n                options,\n                iterations,\n                iterationsMin,\n                iterationsMax,\n                nodeFactory(definition.child, rootNodeDefinitionMap, options)\n            );\n        }\n\n        case \"retry\": {\n            let attempts: number | null = null;\n            let attemptsMin: number | null = null;\n            let attemptsMax: number | null = null;\n\n            if (Array.isArray(definition.attempts)) {\n                attemptsMin = definition.attempts[0];\n                attemptsMax = definition.attempts[1];\n            } else if (isInteger(definition.attempts)) {\n                attempts = definition.attempts!;\n            }\n\n            return new Retry(\n                attributes,\n                options,\n                attempts,\n                attemptsMin,\n                attemptsMax,\n                nodeFactory(definition.child, rootNodeDefinitionMap, options)\n            );\n        }\n\n        case \"flip\":\n            return new Flip(attributes, options, nodeFactory(definition.child, rootNodeDefinitionMap, options));\n\n        case \"succeed\":\n            return new Succeed(attributes, options, nodeFactory(definition.child, rootNodeDefinitionMap, options));\n\n        case \"fail\":\n            return new Fail(attributes, options, nodeFactory(definition.child, rootNodeDefinitionMap, options));\n\n        case \"sequence\":\n            return new Sequence(\n                attributes,\n                options,\n                definition.children.map((child) => nodeFactory(child, rootNodeDefinitionMap, options))\n            );\n\n        case \"selector\":\n            return new Selector(\n                attributes,\n                options,\n                definition.children.map((child) => nodeFactory(child, rootNodeDefinitionMap, options))\n            );\n\n        case \"parallel\":\n            return new Parallel(\n                attributes,\n                options,\n                definition.children.map((child) => nodeFactory(child, rootNodeDefinitionMap, options))\n            );\n\n        case \"race\":\n            return new Race(\n                attributes,\n                options,\n                definition.children.map((child) => nodeFactory(child, rootNodeDefinitionMap, options))\n            );\n\n        case \"all\":\n            return new All(\n                attributes,\n                options,\n                definition.children.map((child) => nodeFactory(child, rootNodeDefinitionMap, options))\n            );\n\n        case \"lotto\":\n            return new Lotto(\n                attributes,\n                options,\n                definition.weights,\n                definition.children.map((child) => nodeFactory(child, rootNodeDefinitionMap, options))\n            );\n\n        case \"branch\":\n            return nodeFactory(rootNodeDefinitionMap[definition.ref].child, rootNodeDefinitionMap, options);\n\n        case \"action\":\n            return new Action(attributes, options, definition.call, definition.args || []);\n\n        case \"condition\":\n            return new Condition(attributes, options, definition.call, definition.args || []);\n\n        case \"wait\": {\n            let duration: number | null = null;\n            let durationMin: number | null = null;\n            let durationMax: number | null = null;\n\n            if (Array.isArray(definition.duration)) {\n                durationMin = definition.duration[0];\n                durationMax = definition.duration[1];\n            } else if (isInteger(definition.duration)) {\n                duration = definition.duration!;\n            }\n\n            return new Wait(attributes, options, duration, durationMin, durationMax);\n        }\n    }\n}\n\n/**\n * Creates an array of node attribute instances based on the specified node definition.\n * @param definition The node definition.\n * @returns An array of node attribute instances based on the specified node definition.\n */\nfunction createNodeAttributes(definition: AnyNodeDefinition): Attribute[] {\n    const attributes: Attribute[] = [];\n\n    if (definition.while) {\n        attributes.push(new While(definition.while));\n    }\n\n    if (definition.until) {\n        attributes.push(new Until(definition.until));\n    }\n\n    if (definition.entry) {\n        attributes.push(new Entry(definition.entry.call, definition.entry.args ?? []));\n    }\n\n    if (definition.step) {\n        attributes.push(new Step(definition.step.call, definition.step.args ?? []));\n    }\n\n    if (definition.exit) {\n        attributes.push(new Exit(definition.exit.call, definition.exit.args ?? []));\n    }\n\n    return attributes;\n}\n\n/**\n * Creates a mapping of root node identifers to root node definitions, mixing in globally registered subtree root node definitions.\n * @param definition The root node definitions.\n * @returns A mapping of root node identifers to root node definitions, including globally registered subtree root node definitions.\n */\nfunction createRootNodeDefinitionMap(definition: RootNodeDefinition[]): RootNodeDefinitionMap {\n    // Create a mapping of root node identifers to root node definitions.\n    const rootNodeMap: RootNodeDefinitionMap = {};\n\n    // Add in any registered subtree root node definitions.\n    for (const [name, rootNodeDefinition] of Object.entries(Lookup.getSubtrees())) {\n        // The name used when registering the subtree will be used as the root node identifier.\n        rootNodeMap[name] = { ...rootNodeDefinition, id: name };\n    }\n\n    // Populate the map with the root node definitions that were included with the tree definition.\n    // We do this after adding any registered subtrees as we want these to take presedence.\n    for (const rootNodeDefinition of definition) {\n        rootNodeMap[rootNodeDefinition.id ?? MAIN_ROOT_NODE_KEY] = rootNodeDefinition;\n    }\n\n    return rootNodeMap;\n}\n\n/**\n * Applies a guard path to every leaf of the tree to evaluate as part of each update.\n * @param root The main root tree node.\n */\nfunction applyLeafNodeGuardPaths(root: Root) {\n    const nodePaths: Node[][] = [];\n\n    const findLeafNodes = (path: Node[], node: Node) => {\n        // Add the current node to the path.\n        path = path.concat(node);\n\n        // Check whether the current node is a leaf node.\n        if (node instanceof Leaf) {\n            nodePaths.push(path);\n        } else {\n            (node as Composite | Decorator).getChildren().forEach((child) => findLeafNodes(path, child));\n        }\n    };\n\n    // Find all leaf node paths, starting from the root.\n    findLeafNodes([], root);\n\n    nodePaths.forEach((path) => {\n        // Each node in the current path will have to be assigned a guard path, working from the root outwards.\n        for (let depth = 0; depth < path.length; depth++) {\n            // Get the node in the path at the current depth.\n            const currentNode = path[depth];\n\n            // The node may already have been assigned a guard path, if so just skip it.\n            if (currentNode.hasGuardPath()) {\n                continue;\n            }\n\n            // Create the guard path for the current node.\n            const guardPath = new GuardPath(\n                path\n                    .slice(0, depth + 1)\n                    .map<GuardPathPart>((node) => ({\n                        node,\n                        guards: node.getAttributes().filter((attribute) => attribute instanceof Guard)\n                    }))\n                    .filter((details) => details.guards.length > 0)\n            );\n\n            // Assign the guard path to the current node.\n            currentNode.setGuardPath(guardPath);\n        }\n    });\n}\n", "import State from \"./State\";\nimport Lookup from \"./Lookup\";\nimport { NodeDetails } from \"./nodes/Node\";\nimport Root from \"./nodes/decorator/Root\";\nimport { Agent, GlobalFunction } from \"./Agent\";\nimport { BehaviourTreeOptions } from \"./BehaviourTreeOptions\";\nimport { convertMDSLToJSON } from \"./mdsl/MDSLDefinitionParser\";\nimport { RootNodeDefinition } from \"./BehaviourTreeDefinition\";\nimport { validateDefinition, validateJSONDefinition } from \"./BehaviourTreeDefinitionValidator\";\nimport buildRootNode from \"./BehaviourTreeBuilder\";\nimport { isNullOrUndefined } from \"./BehaviourTreeDefinitionUtilities\";\n\n/**\n * A representation of a behaviour tree.\n */\nexport class BehaviourTree {\n    /**\n     * The main root tree node.\n     */\n    private readonly _rootNode: Root;\n\n    /**\n     * Creates a new instance of the BehaviourTree class.\n     * @param definition The behaviour tree definition as either an MDSL string, root node definition object or array of root node definition objects.\n     * @param agent The agent instance that this behaviour tree is modelling behaviour for.\n     * @param options The behaviour tree options object.\n     */\n    constructor(\n        definition: string | RootNodeDefinition | RootNodeDefinition[],\n        private agent: Agent,\n        private options: BehaviourTreeOptions = {}\n    ) {\n        // The tree definition must be defined.\n        if (isNullOrUndefined(definition)) {\n            throw new Error(\"tree definition not defined\");\n        }\n\n        // The agent must be defined and not null.\n        if (typeof agent !== \"object\" || agent === null) {\n            throw new Error(\"the agent must be an object and not null\");\n        }\n\n        // We should validate the definition before we try to build the tree nodes.\n        const { succeeded, errorMessage, json } = validateDefinition(definition);\n\n        // Did our validation fail without error?\n        if (!succeeded) {\n            throw new Error(`invalid definition: ${errorMessage}`);\n        }\n\n        // Double check that we did actually get our json definition as part of our definition validtion.\n        if (!json) {\n            throw new Error(\n                \"expected json definition to be returned as part of successful definition validation response\"\n            );\n        }\n\n        try {\n            // Create the populated tree of behaviour tree nodes and get the root node.\n            this._rootNode = buildRootNode(json, options);\n        } catch (exception) {\n            // There was an issue in trying build and populate the behaviour tree.\n            throw new Error(`error building tree: ${(exception as Error).message}`);\n        }\n    }\n\n    /**\n     * Gets whether the tree is in the RUNNING state.\n     * @returns true if the tree is in the RUNNING state, otherwise false.\n     */\n    public isRunning(): boolean {\n        return this._rootNode.getState() === State.RUNNING;\n    }\n\n    /**\n     * Gets the current tree state of SUCCEEDED, FAILED, READY or RUNNING.\n     * @returns The current tree state.\n     */\n    public getState(): State {\n        return this._rootNode.getState();\n    }\n\n    /**\n     * Step the tree.\n     * Carries out a node update that traverses the tree from the root node outwards to any child nodes, skipping those that are already in a resolved state of SUCCEEDED or FAILED.\n     * After being updated, leaf nodes will have a state of SUCCEEDED, FAILED or RUNNING. Leaf nodes that are left in the RUNNING state as part of a tree step will be revisited each\n     * subsequent step until they move into a resolved state of either SUCCEEDED or FAILED, after which execution will move through the tree to the next node with a state of READY.\n     *\n     * Calling this method when the tree is already in a resolved state of SUCCEEDED or FAILED will cause it to be reset before tree traversal begins.\n     */\n    public step(): void {\n        // If the root node has already been stepped to completion then we need to reset it.\n        if (this._rootNode.getState() === State.SUCCEEDED || this._rootNode.getState() === State.FAILED) {\n            this._rootNode.reset();\n        }\n\n        try {\n            this._rootNode.update(this.agent);\n        } catch (exception) {\n            throw new Error(`error stepping tree: ${(exception as Error).message}`);\n        }\n    }\n\n    /**\n     * Resets the tree from the root node outwards to each nested node, giving each a state of READY.\n     */\n    public reset(): void {\n        this._rootNode.reset();\n    }\n\n    /**\n     * Gets the details of every node in the tree, starting from the root.\n     * @returns The details of every node in the tree, starting from the root.\n     */\n    public getTreeNodeDetails(): NodeDetails {\n        return this._rootNode.getDetails();\n    }\n\n    /**\n     * Registers the action/condition/guard/callback function or subtree with the given name.\n     * @param name The name of the function or subtree to register.\n     * @param value The function or subtree definition to register.\n     */\n    static register(name: string, value: GlobalFunction | string | RootNodeDefinition) {\n        // Are we going to register a action/condition/guard/callback function?\n        if (typeof value === \"function\") {\n            Lookup.setFunc(name, value);\n            return;\n        }\n\n        // We are not registering an action/condition/guard/callback function, so we must be registering a subtree.\n        if (typeof value === \"string\") {\n            let rootNodeDefinitions: RootNodeDefinition[];\n\n            // We will assume that any string passed in will be a mdsl definition.\n            try {\n                rootNodeDefinitions = convertMDSLToJSON(value);\n            } catch (exception) {\n                throw new Error(`error registering definition, invalid MDSL: ${(exception as Error).message}`);\n            }\n\n            // This function should only ever be called with a definition containing a single unnamed root node.\n            if (rootNodeDefinitions.length != 1 || typeof rootNodeDefinitions[0].id !== \"undefined\") {\n                throw new Error(\"error registering definition: expected a single unnamed root node\");\n            }\n\n            try {\n                // We should validate the subtree as we don't want invalid subtrees available via the lookup.\n                const { succeeded, errorMessage } = validateJSONDefinition(rootNodeDefinitions[0]);\n\n                // Did our validation fail without error?\n                if (!succeeded) {\n                    throw new Error(errorMessage);\n                }\n            } catch (exception) {\n                throw new Error(`error registering definition: ${(exception as Error).message}`);\n            }\n\n            // Everything seems hunky-dory, register the subtree.\n            Lookup.setSubtree(name, rootNodeDefinitions[0]);\n        } else if (typeof value === \"object\" && !Array.isArray(value)) {\n            // We will assume that any object passed in is a root node definition.\n\n            try {\n                // We should validate the subtree as we don't want invalid subtrees available via the lookup.\n                const { succeeded, errorMessage } = validateJSONDefinition(value);\n\n                // Did our validation fail without error?\n                if (!succeeded) {\n                    throw new Error(errorMessage);\n                }\n            } catch (exception) {\n                throw new Error(`error registering definition: ${(exception as Error).message}`);\n            }\n\n            // Everything seems hunky-dory, register the subtree.\n            Lookup.setSubtree(name, value);\n        } else {\n            throw new Error(\"unexpected value, expected string mdsl definition, root node json definition or function\");\n        }\n    }\n\n    /**\n     * Unregisters the registered action/condition/guard/callback function or subtree with the given name.\n     * @param name The name of the registered action/condition/guard/callback function or subtree to unregister.\n     */\n    static unregister(name: string): void {\n        Lookup.remove(name);\n    }\n\n    /**\n     * Unregister all registered action/condition/guard/callback functions and subtrees.\n     */\n    static unregisterAll(): void {\n        Lookup.empty();\n    }\n}\n"],
  "mappings": "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",
  "names": ["require_Participant", "__commonJSMin", "exports", "Participant", "participant", "tickets", "value", "require_Utilities", "__commonJSMin", "exports", "isNullOrUndefined", "value", "isNaturalNumber", "require_Lotto", "__commonJSMin", "exports", "Participant_1", "Utilities_1", "Lotto", "customRandom", "participant", "tickets", "existingParticipant", "part", "options", "redrawable", "pickable", "_a", "ticketCount", "random", "winner", "uniqueResults", "result", "unique", "_i", "result_1", "require_createLotto", "__commonJSMin", "exports", "Lotto_1", "createLotto", "participantsOrOptions", "participants", "lotto_1", "_a", "participant", "tokens", "random", "lotto_2", "require_dist", "__commonJSMin", "exports", "createLotto_1", "index_exports", "__export", "BehaviourTree", "State", "convertMDSLToJSON", "validateDefinition", "State", "Lookup", "name", "func", "agent", "agentFunction", "args", "registeredFunction", "subtree", "isRootNodeDefinition", "node", "isBranchNodeDefinition", "isLeafNodeDefinition", "isDecoratorNodeDefinition", "isCompositeNodeDefinition", "flattenDefinition", "nodeDefinition", "nodes", "processNode", "currentNodeDefinition", "isInteger", "value", "isNullOrUndefined", "getArgumentJsonValue", "arg", "popAndCheck", "tokens", "expected", "popped", "expectedValues", "item", "expectationString", "tokenise", "definition", "placeholders", "processedDefinition", "substituteStringLiterals", "match", "strippedMatch", "placeholder", "key", "parseArgumentTokens", "tokens", "stringArgumentPlaceholders", "argumentList", "closingToken", "popAndCheck", "argumentListTokens", "token", "index", "argumentDefinition", "getArgumentDefinition", "parseAttributeTokens", "tokens", "stringArgumentPlaceholders", "nodeAttributeNames", "attributes", "nextAttributeName", "attributeCallIdentifier", "attributeArguments", "parseArgumentTokens", "arg", "succeedOnAbort", "popAndCheck", "getArgumentJsonValue", "convertMDSLToJSON", "definition", "tokens", "placeholders", "tokenise", "convertTokensToJSONDefinition", "stringLiteralPlaceholders", "token", "treeStacks", "rootNodes", "pushNode", "node", "isRootNodeDefinition", "topTreeStack", "topTreeStackTopNode", "isCompositeNodeDefinition", "isDecoratorNodeDefinition", "isLeafNodeDefinition", "popNode", "poppedNode", "createRootNode", "createSucceedNode", "createFailNode", "createFlipNode", "createRepeatNode", "createRetryNode", "createSequenceNode", "createSelectorNode", "createParallelNode", "createRaceNode", "createAllNode", "createLottoNode", "createActionNode", "createConditionNode", "createWaitNode", "createBranchNode", "validatePoppedNode", "nodeArguments", "parseArgumentTokens", "parseAttributeTokens", "popAndCheck", "arg", "value", "actionNameIdentifier", "agentFunctionArgs", "getArgumentJsonValue", "conditionNameIdentifier", "isNullOrUndefined", "validateDefinition", "definition", "createValidationFailureResult", "validateMDSLDefinition", "validateJSONDefinition", "rootNodeDefinitions", "convertMDSLToJSON", "exception", "mainRootNodeDefinitions", "id", "subRootNodeDefinitions", "subRootNodeIdenitifers", "validateBranchSubtreeLinks", "rootNodeDefinition", "validateNode", "error", "includesGlobalSubtrees", "rootNodeMappings", "flattenDefinition", "isBranchNodeDefinition", "ref", "followRefs", "mapping", "path", "badPathFormatted", "element", "subMapping", "depth", "validateActionNode", "validateConditionNode", "validateWaitNode", "validateBranchNode", "validateRootNode", "validateSucceedNode", "validateFailNode", "validateFlipNode", "validateRepeatNode", "validateRetryNode", "validateSequenceNode", "validateSelectorNode", "validateParallelNode", "validateRaceNode", "validateAllNode", "validateLottoNode", "validateNodeAttributes", "attributeName", "attributeDefinition", "containsNonInteger", "value", "isInteger", "child", "errorMessage", "GuardUnsatisifedException", "source", "guard", "node", "GuardPath", "nodes", "agent", "details", "guard", "GuardUnsatisifedException", "createUid", "S4", "Node", "type", "attributes", "options", "createUid", "value", "previousState", "attribute", "agent", "error", "GuardUnsatisifedException", "Leaf", "Node", "Composite", "Node", "type", "attributes", "options", "children", "child", "agent", "Parallel", "Composite", "attributes", "options", "children", "agent", "child", "Race", "Composite", "attributes", "options", "children", "agent", "child", "All", "Composite", "attributes", "options", "children", "agent", "child", "Selector", "Composite", "attributes", "options", "children", "agent", "child", "Sequence", "Composite", "attributes", "options", "children", "agent", "child", "import_lotto_draw", "Lotto", "Composite", "attributes", "options", "weights", "children", "agent", "lottoDraw", "createLotto", "child", "index", "Decorator", "Node", "type", "attributes", "options", "child", "agent", "Fail", "Decorator", "attributes", "options", "child", "agent", "Flip", "Decorator", "attributes", "options", "child", "agent", "Repeat", "Decorator", "attributes", "options", "iterations", "iterationsMin", "iterationsMax", "child", "agent", "random", "Retry", "Decorator", "attributes", "options", "attempts", "attemptsMin", "attemptsMax", "child", "agent", "random", "Root", "Decorator", "attributes", "options", "child", "agent", "Succeed", "Decorator", "attributes", "options", "child", "agent", "Action", "Leaf", "attributes", "options", "actionName", "actionArguments", "agent", "isResolved", "value", "actionFuncInvoker", "Lookup", "actionFunctionResult", "error", "result", "reason", "previousState", "Condition", "Leaf", "attributes", "options", "conditionName", "conditionArguments", "agent", "conditionFuncInvoker", "Lookup", "conditionFunctionResult", "error", "previousState", "Wait", "Leaf", "attributes", "options", "duration", "durationMin", "durationMax", "agent", "random", "deltaTime", "Attribute", "type", "args", "Guard", "Attribute", "type", "definition", "While", "Guard", "definition", "agent", "conditionFuncInvoker", "Lookup", "conditionFunctionResult", "error", "Until", "Guard", "definition", "agent", "conditionFuncInvoker", "Lookup", "conditionFunctionResult", "error", "Callback", "Attribute", "type", "args", "functionName", "Entry", "Callback", "functionName", "args", "agent", "callbackFuncInvoker", "Lookup", "Step", "Callback", "functionName", "args", "agent", "callbackFuncInvoker", "Lookup", "Exit", "Callback", "functionName", "args", "agent", "isSuccess", "isAborted", "callbackFuncInvoker", "Lookup", "MAIN_ROOT_NODE_KEY", "buildRootNode", "definition", "options", "rootNodeDefinitionMap", "createRootNodeDefinitionMap", "validateBranchSubtreeLinks", "rootNode", "nodeFactory", "applyLeafNodeGuardPaths", "attributes", "createNodeAttributes", "Root", "iterations", "iterationsMin", "iterationsMax", "isInteger", "Repeat", "attempts", "attemptsMin", "attemptsMax", "Retry", "Flip", "Succeed", "Fail", "Sequence", "child", "Selector", "Parallel", "Race", "All", "Lotto", "Action", "Condition", "duration", "durationMin", "durationMax", "Wait", "While", "Until", "Entry", "Step", "Exit", "rootNodeMap", "name", "rootNodeDefinition", "Lookup", "root", "nodePaths", "findLeafNodes", "path", "node", "Leaf", "depth", "currentNode", "guardPath", "GuardPath", "attribute", "Guard", "details", "BehaviourTree", "definition", "agent", "options", "isNullOrUndefined", "succeeded", "errorMessage", "json", "validateDefinition", "buildRootNode", "exception", "name", "value", "Lookup", "rootNodeDefinitions", "convertMDSLToJSON", "validateJSONDefinition"]
}
